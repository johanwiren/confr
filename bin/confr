#!/usr/bin/env bb

(ns lambdaisland.clj-diff.miller
  "Algorithm from 'An O(NP) Sequence Comparison Algorithm' by
   Sun Wu, Udi Manber, Gene Myers and Web Miller.

   Please refer to the above paper while reading this code."
  #?@(:bb []
      :clj [(:require [lambdaisland.clj-diff.optimizations :as opt])]))

(defn- next-x
  "Get the next farthest x value by looking at previous farthest values on the
  diagonal above and below diagonal k. Choose the greater of the farthest x on
  the above diagonal and the farthest x on the diagonal below plus one. fp is
  a map of diagonals => farthest points."
  [k fp]
  (max (inc (get fp (dec k) -1))
       (get fp (inc k) -1)))

(defn- snake
  "Starting at the farthest point on diagonal k, return the x value of the
  point at the end of the longest snake on this diagonal. A snake is a
  sequence of diagonal moves connecting match points on the edit graph."
  [a b n m k fp]
  {:pre [(and (vector? a) (vector? b))]}
  (let [x (next-x k fp)
        y (- x k)]
    (loop [x x
           y y]
      (if (and (< x n) (< y m) (= (get a (inc x)) (get b (inc y))))
        (recur (inc x) (inc y))
        x))))

(defn- p-band-diagonals
  "Given a p value and a delta, return all diagonals in this p-band."
  [p delta]
  (concat (range (* -1 p) delta)
          (reverse (range (inc delta) (+ delta (inc p))))
          [delta]))

(defn- search-p-band
  "Given a p value, search all diagonals in the p-band for the furthest
  reaching endpoints. Record the furthest reaching endpoint for each p value
  in the map fp. Returns an updated fp map for p. a and b are the two
  sequences and n and m are their lengths respectively. delta is the
  diagonal of the sink and is equal to n - m."
  [a b n m delta p fp]
  (reduce (fn [fp next-k]
            (assoc fp next-k (snake a b n m next-k fp)))
          fp
          (p-band-diagonals p delta)))

(defn ses
  "Find the size of the shortest edit script (ses). Returns a 3-tuple of the
  size of the ses, the delta value (which is the diagonal of the sink)
  and the fp map. The optimal path from source to sink can be constructed from
  this information."
  [a b]
  {:pre [(>= (count a) (count b))]}
  (let [n (dec (count a))
        m (dec (count b))
        delta (- n m)]
    (loop [p 0
           fp {}]
      (if (= (-> (get fp (dec p) {})
                 (get delta))
             n)
        [(dec p) delta fp]
        (recur (inc p)
               (assoc fp p
                      (search-p-band a b n m delta p (get fp (dec p) {}))))))))

;;
;; Build the edit script from the map of farthest endpoints.
;;

(defn edit-dist
  "Given a delta, p and k value, calculate the edit distance."
  [delta p k]
  (if (> k delta)
    (+ (* 2 (- p (- k delta))) k)
    (+ (* 2 p) k)))

(defn- p-value-up
  "Calculate the p value that will be used to look up the farthest reaching
  end point for the diagonal above k."
  [delta p k]
  (if (> (inc k) delta) p (dec p)))

(defn- p-value-left
  "Calculate the p value that will be used to look up the farthest reaching
  end point for the diagonal below k."
  [delta p k]
  (if (< (dec k) delta) p (dec p)))

(defn- look-up
  "Get information about the vertex above the one at x on k. If this vertex
  is chosen, it will represent an insertion."
  [graph delta p x k]
  (when (> (- x k) 0)
    (let [up-k (inc k)
          up-p (p-value-up delta p k)
          x* (-> graph
                 (get up-p {})
                 (get up-k -1))]
      (when (and (>= x* 0) (= x x*))
        {:edit :insert
         :x x*
         :p up-p
         :k up-k
         :d (edit-dist delta up-p up-k)}))))

(defn- look-left
  "Get information about the vertex to the left of the one at x on k. If this
  vertex is chosen, it will represent an deletion."
  [graph delta p x k]
  (when (> x 0)
    (let [left-k (dec k)
          left-p (p-value-left delta p k)
          x* (-> graph
                 (get left-p {})
                 (get left-k -1))]
      (when (and (>= x* 0) (= (dec x) x*))
        {:edit :delete
         :x x*
         :p left-p
         :k left-k
         :d (edit-dist delta left-p left-k)}))))

(defn- backtrack-snake
  "Find the x value at the head of the longest snake ending at (x, y)."
  [a b x y]
  {:pre [(and (>= x 0) (>= y 0))]}
  (loop [x x
         y y]
    (if (or (= x 0) (= y 0) (not (= (get a x) (get b y))))
      x
      (recur (dec x) (dec y)))))

;; See the paper for an example of how there are multiple shortest
;; paths through an edit graph.

(defn- next-edit
  "Find the next move through the edit graph which will decrease the
  edit distance by 1."
  [a b graph delta p x k]
  {:post [(= (dec (edit-dist delta p k)) (:d %))]}
  (let [d (edit-dist delta p k)
        head-x (backtrack-snake a b x (- x k))]
    (loop [head-x head-x]
      (let [move (first (filter #(and (not (nil? %)) ;; <<<===
                                      (= (:d %) (dec d)))
                                (map #(% graph delta p head-x k)
                                     [look-left look-up])))]
        (if (and (< head-x x) (nil? move))
          (recur (inc head-x))
          move)))))

(defn- edits
  "Calculate the sequence of edits from the map of farthest reaching end
  points."
  [a b p delta graph]
  (let [next-fn (partial next-edit a b graph delta)]
    (loop [edits '()
           prev {:x (count a) :p p :k delta
                 :d (edit-dist delta p delta)}]
      (if (= (:d prev) 0)
        edits
        (let [next (next-fn (:p prev) (:x prev) (:k prev))]
          (recur (conj edits next) next))))))

(defn- transpose
  "If a is shorter than b, then the diff is calculated from b to a and this
  function is used to transpose the results into a diff from a to b."
  [edit]
  (-> edit
      (assoc :edit (if (= :insert (:edit edit)) :delete :insert))
      (assoc :x (- (:x edit) (:k edit)))
      (assoc :k (- (:k edit)))))

(defn- edits->script
  "Convert a sequence of edits into an edit script."
  [b edits f]
  (reduce (fn [script edit]
            (let [{:keys [edit x k]} (f edit)
                  y (inc (- x k))
                  insertions (:+ script)
                  last-insert (last insertions)]
              (if (= edit :delete)
                (assoc script :- (conj (:- script) x))
                (assoc script :+ (let [index (dec x)]
                                   (if (= index (first last-insert))
                                     (conj (vec (butlast insertions))
                                           (conj last-insert (get b y)))
                                     (conj insertions [(dec x) (get b y)])))))))
          {:+ []
           :- []}
          edits))

(defn vectorize [& more]
  (map #(vec (cons nil %)) more))

(defn order->ses
  [a b]
  (let [[a* b*] (if (> (count b) (count a)) [b a] [a b])]
    [(ses a* b*) a* b*]))

(defn seq-diff
  [a b]
  (let [[a b] (vectorize a b)
        [es a* b*] (order->ses a b)
        edits (apply edits a* b* es)]
    (edits->script b edits (if (= a* a) identity transpose))))

(defn string-dispatch [a b]
  (when (and (string? a) (string? b)) :string))

(defmulti ^{:arglists '([a b])} diff
  "Create an edit script that may be used to transform a into b. See doc string
  for clj-diff.core/diff. This function will ensure that diff* is called with
  arguments a and b where a >= b. If the passed values of a and b need to be
  swapped then the resulting path with will transposed."
  string-dispatch)

(defmethod diff :default
  [a b]
  (seq-diff a b))

#?(:bb nil
   :clj
   (defmethod diff :string
     [a b]
     (opt/diff a b seq-diff)))

(defn seq-edit-dist
  [a b]
  (let [[a b] (vectorize a b)
        [[p & more] a* b*] (order->ses a b)]
    (+ (* 2 p) (- (count a*) (count b*)))))

(defmulti edit-distance string-dispatch)

(defmethod edit-distance :default
  [a b]
  (seq-edit-dist a b))

;; TODO - Modify optimizations so that it can be used here and with
;; longest-common-subseq
(defmethod edit-distance :string
  [a b]
  (seq-edit-dist a b))

(defn seq-lcs
  [a b]
  (let [diff (seq-diff a b)
        deletions (:- diff)]
    (filter #(not= % ::d)
            (reduce (fn [coll next]
                      (assoc coll next ::d))
                    (vec (seq a))
                    deletions))))

(defmulti longest-common-subseq string-dispatch)

(defmethod longest-common-subseq :default
  [a b]
  (seq-lcs a b))

(defmethod longest-common-subseq :string
  [a b]
  (apply str (seq-lcs a b)))
(ns lambdaisland.clj-diff.core
  "Diff, patch and related functions for Clojure sequences."
  (:require [lambdaisland.clj-diff.miller :as miller]))

(defn diff
  "Create the edit script for transforming sequance a into sequence b.
  An edit script is a map with keys :+ and :- for additions and deletions.
  Additions are represented as a sequence of vectors. The first item in each
  vector is the index where the rest of the items in the vector are to be
  inserted. For example [3 b c] means to insert b an c after whatever is
  in index 3. Deletions are represented as a sequence of indexes to delete.

  For example: the diff of 'abcabba' and 'cbabac' would generate the edit
  script below.

      {:+ [[2 b] [6 c]], :- [0 1 5]}

  An index of -1 may appear in additions and is a special case which means to
  add the elements at the beginning of the sequence."
  [a b]
  (miller/diff a b))

(defn- merge-patch
  [s edit-script delete-symbol]
  (let [s (vec s)
        additions (:+ edit-script)
        deletions (:- edit-script)
        s (reduce (fn [a b]
                    (assoc a b delete-symbol))
                  s
                  deletions)
        s (reduce (fn [a b]
                    (let [index (first b)
                          items (rest b)]
                      (if (= index -1)
                        (assoc a 0 (conj (vec items) (get a 0)))
                        (assoc a index (conj items (get a index))))))
                  s
                  additions)]
    (flatten s)))

(defn patch*
  [s edit-script]
  (filter #(not (nil? %)) (merge-patch s edit-script nil)))

(defmulti ^{:arglists '([s edit-script])} patch
  "Use the instructions in the edit script to transform the sequence s into
  a new sequence. If the edit script was created by using diff on a and b then
  patch will use the edit script to transform a into b.

  (diff a b) -> x, (patch a x) -> b."
  #?(:clj  (fn [s _] (class s))
     :cljs (fn [s _] (when (string? s) :string))))

(defmethod patch :default
  [s edit-script]
  (patch* s edit-script))

(defmethod patch #?(:clj String :cljs :string)
  [s edit-script]
  (apply str (patch* s edit-script)))

(defn edit-distance
  "Returns the edit distance between the two passed sequences. May also be
  passed an edit script. The edit distance is the minimum number of insertions
  and deletions required to transform one sequence into another."
  ([a b]
     (miller/edit-distance a b))
  ([edit-script]
     (+ (count (:- edit-script))
        (reduce + (map #(count (drop 1 %)) (:+ edit-script))))))

(defn- max-or-zero [coll]
  (if (and (coll? coll)
           (not (empty? coll)))
    (apply max coll)
    0))

(defn levenshtein-distance
  "Returns the Levenshtein distance between two sequences. May either be passed
  the two sequences or a diff of the two sequences.

  From [Wikipedia](http://en.wikipedia.org/wiki/Levenshtein_distance):
  The Levenshtein distance between two strings is the minimum number of edits
  needed to transform one string into the other, with the allowable edit
  operations being insertion, deletion and substitution of a single character.

  This function works not only with strings but with any Clojure sequence.

  Warning! Technically this function is estimating the Levenshtein distance
  from a computed diff. Most of the time, it is the same as the real Levenshtein
  distance but in same cases it may be larger. The reason for this is that
  there may be multiple paths through an edit graph with the same edit
  distance but with differing Levenshtein distance. A future improvement to
  the diff algorithm whould be to find all paths and prefer the one with the
  minimum Levenshtein distance."
  ([a b]
     (levenshtein-distance (diff a b)))
  ([edit-script]
     (let [additions (map #(let [index (first %)
                                 items (rest %)]
                             (apply vector index (repeat (count items) :a)))
                          (:+ edit-script))
           max-index (max (max-or-zero (map first additions))
                          (max-or-zero (:- edit-script)))
           v (vec (repeat max-index :e))
           patched (merge-patch v (merge edit-script {:+ additions}) :d)
           edit-groups (filter #(not= :e (first %))
                               (partition-by #(if (= % :e) :e :edit)
                                             patched))]
       (reduce + (map (fn [group]
                        (max (count (filter #(= % :a) group))
                             (count (filter #(= % :d) group))))
                      edit-groups)))))

(defn longest-common-subseq [a b]
  (miller/longest-common-subseq a b))
(ns lambdaisland.deep-diff2.diff-impl
  (:require [clojure.data :as data]
            [clojure.set :as set]
            [lambdaisland.clj-diff.core :as seq-diff]))

(declare diff diff-similar)

(defrecord Mismatch [- +])
(defrecord Deletion [-])
(defrecord Insertion [+])

(defprotocol Diff
  (-diff-similar [x y]))

;; For property based testing
(defprotocol Undiff
  (left-undiff [x])
  (right-undiff [x]))

(defn shift-insertions [ins]
  (reduce (fn [res idx]
            (let [offset (apply + (map count (vals res)))]
              (assoc res (+ idx offset) (get ins idx))))
          {}
          (sort (keys ins))))

(defn replacements
  "Given a set of deletion indexes and a map of insertion index to value sequence,
  match up deletions and insertions into replacements, returning a map of
  replacements, a set of deletions, and a map of insertions."
  [[del ins]]
  ;; Loop over deletions, if they match up with an insertion, turn them into a
  ;; replacement. This could be a reduce over (sort del) tbh but it's already a
  ;; lot more readable than the first version.
  (loop [rep {}
         del del
         del-rest (sort del)
         ins ins]
    (if-let [d (first del-rest)]
      (if-let [i (seq (get ins d))] ;; matching insertion
        (recur (assoc rep d (first i))
               (disj del d)
               (next del-rest)
               (update ins d next))

        (if-let [i (seq (get ins (dec d)))]
          (recur (assoc rep d (first i))
                 (disj del d)
                 (next del-rest)
                 (-> ins
                     (dissoc (dec d))
                     (assoc d (seq (concat (next i)
                                           (get ins d))))))
          (recur rep
                 del
                 (next del-rest)
                 ins)))
      [rep del (into {}
                     (remove (comp nil? val))
                     (shift-insertions ins))])))

(defn del+ins
  "Wrapper around clj-diff that returns deletions and insertions as a set and map
  respectively."
  [exp act]
  (let [{del :- ins :+} (seq-diff/diff exp act)]
    [(into #{} del)
     (into {} (map (fn [[k & vs]] [k (vec vs)])) ins)]))

(defn diff-seq-replacements [replacements s]
  (map-indexed
   (fn [idx v]
     (if (contains? replacements idx)
       (diff v (get replacements idx))
       v))
   s))

(defn diff-seq-deletions [del s]
  (map
   (fn [v idx]
     (if (contains? del idx)
       (->Deletion v)
       v))
   s
   (range)))

(defn diff-seq-insertions [ins s]
  (reduce (fn [res [idx vs]]
            (concat (take (inc idx) res) (map ->Insertion vs) (drop (inc idx) res)))
          s
          ins))

(defn diff-seq [exp act]
  (let [[rep del ins] (replacements (del+ins exp act))]
    (->> exp
         (diff-seq-replacements rep)
         (diff-seq-deletions del)
         (diff-seq-insertions ins)
         (into []))))

(defn diff-set [exp act]
  (into
   (into #{}
         (map (fn [e]
                (if (contains? act e)
                  e
                  (->Deletion e))))
         exp)
   (map ->Insertion)
   (remove #(contains? exp %) act)))

(defn diff-map [exp act]
  (let [exp-ks (set (keys exp))
        act-ks (set (keys act))]
    (reduce
      (fn [m k]
        (case [(contains? exp-ks k) (contains? act-ks k)]
          [true false]
          (assoc m (->Deletion k) (get exp k))
          [false true]
          (assoc m (->Insertion k) (get act k))
          [true true]
          (assoc m k (diff (get exp k) (get act k)))
          ; `[false false]` will never occur because `k` necessarily
          ; originated from at least one of the two sets
          ))
      {}
      (set/union exp-ks act-ks))))

(defn primitive? [x]
  (or (number? x) (string? x) (boolean? x) (inst? x) (keyword? x) (symbol? x)))

(defn diff-atom [exp act]
  (if (= exp act)
    exp
    (->Mismatch exp act)))

(defn diff-similar [x y]
  (if (primitive? x)
    (diff-atom x y)
    (-diff-similar x y)))

(defn diffable? [exp]
  (satisfies? Diff exp))

;; ClojureScript has this, Clojure doesn't
#?(:clj
   (defn array? [x]
     (and x (.isArray (class x)))))

(defn diff [exp act]
  (cond
    (nil? exp)
    (diff-atom exp act)

    (and (diffable? exp)
         (= (data/equality-partition exp) (data/equality-partition act)))
    (diff-similar exp act)

    (array? exp)
    (diff-seq exp act)

    (record? exp)
    (diff-map exp act)

    :else
    (diff-atom exp act)))

(extend-protocol Diff
  #?(:clj java.util.Set :cljs cljs.core/PersistentHashSet)
  (-diff-similar [exp act]
    (diff-set exp act))
  #?@(:clj
      [java.util.List
       (-diff-similar [exp act] (diff-seq exp act))

       java.util.Map
       (-diff-similar [exp act] (diff-map exp act))]

      :cljs
      [cljs.core/List
       (-diff-similar [exp act] (diff-seq exp act))

       cljs.core/PersistentVector
       (-diff-similar [exp act] (diff-seq exp act))

       cljs.core/EmptyList
       (-diff-similar [exp act] (diff-seq exp act))

       cljs.core/PersistentHashMap
       (-diff-similar [exp act] (diff-map exp act))

       cljs.core/PersistentArrayMap
       (-diff-similar [exp act] (diff-map exp act))]))

(extend-protocol Undiff
  Mismatch
  (left-undiff [m] (get m :-))
  (right-undiff [m] (get m :+))

  Insertion
  (right-undiff [m] (get m :+))

  Deletion
  (left-undiff [m] (get m :-))

  nil
  (left-undiff [m] m)
  (right-undiff [m] m)

  #?(:clj Object :cljs default)
  (left-undiff [m] m)
  (right-undiff [m] m)

  #?@(:clj
      [java.util.List
       (left-undiff [s] (map left-undiff (remove #(instance? Insertion %) s)))
       (right-undiff [s] (map right-undiff (remove #(instance? Deletion %) s)))

       java.util.Set
       (left-undiff [s] (set (left-undiff (seq s))))
       (right-undiff [s] (set (right-undiff (seq s))))

       java.util.Map
       (left-undiff [m]
                    (into {}
                          (comp (remove #(instance? Insertion (key %)))
                                (map (juxt (comp left-undiff key) (comp left-undiff val))))
                          m))
       (right-undiff [m]
                     (into {}
                           (comp (remove #(instance? Deletion (key %)))
                                 (map (juxt (comp right-undiff key) (comp right-undiff val))))
                           m))]

      :cljs
      [cljs.core/List
       (left-undiff [s] (map left-undiff (remove #(instance? Insertion %) s)))
       (right-undiff [s] (map right-undiff (remove #(instance? Deletion %) s)))

       cljs.core/EmptyList
       (left-undiff [s] (map left-undiff (remove #(instance? Insertion %) s)))
       (right-undiff [s] (map right-undiff (remove #(instance? Deletion %) s)))

       cljs.core/PersistentHashSet
       (left-undiff [s] (set (left-undiff (seq s))))
       (right-undiff [s] (set (right-undiff (seq s))))

       cljs.core/PersistentTreeSet
       (left-undiff [s] (set (left-undiff (seq s))))
       (right-undiff [s] (set (right-undiff (seq s))))

       cljs.core/PersistentVector
       (left-undiff [s] (map left-undiff (remove #(instance? Insertion %) s)))
       (right-undiff [s] (map right-undiff (remove #(instance? Deletion %) s)))

       cljs.core/KeySeq
       (left-undiff [s] (map left-undiff (remove #(instance? Insertion %) s)))
       (right-undiff [s] (map right-undiff (remove #(instance? Deletion %) s)))

       cljs.core/PersistentArrayMap
       (left-undiff [m]
                    (into {}
                          (comp (remove #(instance? Insertion (key %)))
                                (map (juxt (comp left-undiff key) (comp left-undiff val))))
                          m))
       (right-undiff [m]
                     (into {}
                           (comp (remove #(instance? Deletion (key %)))
                                 (map (juxt (comp right-undiff key) (comp right-undiff val))))
                           m))

       cljs.core/PersistentHashMap
       (left-undiff [m]
                    (into {}
                          (comp (remove #(instance? Insertion (key %)))
                                (map (juxt (comp left-undiff key) (comp left-undiff val))))
                          m))
       (right-undiff [m]
                     (into {}
                           (comp (remove #(instance? Deletion (key %)))
                                 (map (juxt (comp right-undiff key) (comp right-undiff val))))
                           m))

       cljs.core/UUID
       (left-undiff [m] m)
       (right-undiff [m] m)]))
(ns lambdaisland.deep-diff2.minimize-impl
  "Provide API for manipulate the diff structure data "
  (:require [clojure.walk :refer [postwalk]]
            #?(:clj [lambdaisland.deep-diff2.diff-impl]
               :cljs [lambdaisland.deep-diff2.diff-impl :refer [Mismatch Deletion Insertion]]))
  #?(:clj (:import [lambdaisland.deep_diff2.diff_impl Mismatch Deletion Insertion])))

(defn diff-item?
  "Checks if x is a Mismatch, Deletion, or Insertion"
  [x]
  (or (instance? Mismatch x)
      (instance? Deletion x)
      (instance? Insertion x)))

(defn has-diff-item?
  "Checks if there are any diff items in x or sub-tree of x"
  [x]
  (or (diff-item? x)
      (and (map? x) (some #(or (has-diff-item? (key %))
                               (has-diff-item? (val %))) x))
      (and (coll? x) (some has-diff-item? x))))

(defn minimize
  "Postwalk diff, removing values that are unchanged"
  [diff]
  (let [y (postwalk
           (fn [x]
             (cond
               (map-entry? x)
               ;; Either k or v of a map-entry contains/is? diff-item,
               ;; keep the map-entry. Otherwise, remove it.
               (when (or (has-diff-item? (key x))
                         (has-diff-item? (val x)))
                 x)

               (map? x)
               x

               (coll? x)
               (into (empty x) (filter has-diff-item?) x)

               :else
               x))
           diff)]
    (cond
      (coll? y) y
      :else     nil)))
(ns lambdaisland.deep-diff2.puget.dispatch
  "Dispatch functions take a `Class` argument and return the looked-up value.
  This provides similar functionality to Clojure's protocols, but operates over
  locally-constructed logic rather than using a global dispatch table.

  A simple example is a map from classes to values, which can be used directly
  as a lookup function."
  (:require [clojure.string :as str]))

;; ## Logical Dispatch
(defn chained-lookup
  "Builds a dispatcher which looks up a type by checking multiple dispatchers
  in order until a matching entry is found. Takes either a single collection of
  dispatchers or a variable list of dispatcher arguments. Ignores nil
  dispatchers in the sequence."
  ([dispatchers]
   {:pre [(sequential? dispatchers)]}
   (let [candidates (remove nil? dispatchers)
         no-chain-lookup-provided-message "chained-lookup must be provided at least one dispatch function to try."]
     (when (empty? candidates)
       (throw (ex-info no-chain-lookup-provided-message
                       {:causes #{:no-chained-lookup-provided}})))
     (if (= 1 (count candidates))
       (first candidates)
       (fn lookup
         [t]
         (some #(% t) candidates)))))
  ([a b & more]
   (chained-lookup (list* a b more))))

(defn caching-lookup
  "Builds a dispatcher which caches values returned for each type. This improves
  performance when the underlying dispatcher may need to perform complex
  lookup logic to determine the dispatched value."
  [dispatch]
  (let [cache (atom {})]
    (fn lookup
      [t]
      (let [memory @cache]
        (if (contains? memory t)
          (get memory t)
          (let [v (dispatch t)]
            (swap! cache assoc t v)
            v))))))

;; Space for predicate-lookup. ClojureScript support
#?(:cljs
   (defn predicate-lookup
     "Look up a handler for a value based on a map from predicate to handler"
     [types]
     (fn lookup [value]
       (some (fn [[pred? handler]]
               (when (pred? value)
                 handler))
             types))))

;; ## Type Dispatch (Clojure)
#?(:clj
   (defn symbolic-lookup
     "Builds a dispatcher which looks up a type by checking the underlying lookup
  using the type's _symbolic_ name, rather than the class value itself. This is
  useful for checking configuration that must be created in situations where the
  classes themselves may not be loaded yet."
     [dispatch]
     (fn lookup
       [^Class t]
       (dispatch (symbol (.getName t))))))

#?(:clj
   (defn- lineage
     "Returns the ancestry of the given class, starting with the class and
  excluding the `java.lang.Object` base class."
     [cls]
     (take-while #(and (some? %) (not= Object %))
                 (iterate #(when (class? %) (.getSuperclass ^Class %)) cls))))

#?(:clj
   (defn- find-interfaces
     "Resolves all of the interfaces implemented by a class, both direct (through
  class ancestors) and indirect (through other interfaces)."
     [cls]
     (let [get-interfaces (fn [^Class c] (.getInterfaces c))
           direct-interfaces (mapcat get-interfaces (lineage cls))]
       (loop [queue (vec direct-interfaces)
              interfaces #{}]
         (if (empty? queue)
           interfaces
           (let [^Class iface (first queue)
                 implemented (get-interfaces iface)]
             (recur (into (rest queue)
                          (remove interfaces implemented))
                    (conj interfaces iface))))))))

#?(:clj
   (defn inheritance-lookup
     "Builds a dispatcher which looks up a type by looking up the type itself,
  then attempting to look up its ancestor classes, implemented interfaces, and
  finally `java.lang.Object`."
     [dispatch]
     (fn lookup
       [obj]
       (let [t (class obj)]
         (or
          (some dispatch (lineage t))
          (let [candidates (remove (comp nil? first)
                                   (map (juxt dispatch identity)
                                        (find-interfaces t)))
                wrong-number-of-candidates-message "%d candidates found for interfaces on dispatch type %s: %s"]
            (case (count candidates)
              0 nil
              1 (ffirst candidates)
              (throw (ex-info (format wrong-number-of-candidates-message
                                      (count candidates) t (str/join ", " (map second candidates)))))))
          (dispatch Object))))))
(ns lambdaisland.deep-diff2.puget.color
  "Coloring multimethods to format text by adding markup.

  #### Color Options

  `:print-color`

  When true, ouptut colored text from print functions.

  `:color-markup`

  - `:ansi` for color terminal text (default)
  - `:html-inline` for inline-styled html
  - `:html-classes` for html with semantic classes

  `:color-scheme`

  Map of syntax element keywords to color codes.
  ")

;; ## Coloring Multimethods
(defn dispatch
  "Dispatches to coloring multimethods. Element should be a key from
  the color-scheme map."
  [options element text]
  (when (:print-color options)
    (:color-markup options)))

(defmulti document
  "Constructs a pretty print document, which may be colored if
  `:print-color` is true."
  #'dispatch)

(defmulti text
  "Produces text colored according to the active color scheme. This is mostly
  useful to clients which want to produce output which matches data printed by
  Puget, but which is not directly printed by the library. Note that this
  function still obeys the `:print-color` option."
  #'dispatch)

;; ## Default Markup
;; The default transformation when there's no markup specified is to return the
;; text unaltered.
(defmethod document nil
  [options element text]
  text)

(defmethod text nil
  [options element text]
  text)
(ns lambdaisland.deep-diff2.puget.color.html
  "Coloring implementation that wraps text in HTML tags to apply color.

  Supports the following modes for `:color-markup`:

  - `:html-inline` applies inline `style` attributes to the tags.
  - `:html-classes` adds semantic `class` attributes to the tags."
  (:require
   [clojure.string :as str]
   [clojure.walk :refer [postwalk]]
   [lambdaisland.deep-diff2.puget.color :as color]))

(def style-attribute
  "Map from keywords usable in a color-scheme value to vectors
  representing css style attributes"
  {:none       nil
   :bold       [:font-weight "bold"]
   :underline  [:text-decoration "underline"]
   :blink      [:text-decoration "blink"]
   :reverse    nil
   :hidden     [:visibility "hidden"]
   :strike     [:text-decoration "line-through"]
   :black      [:color "black"]
   :red        [:color "red"]
   :green      [:color "green"]
   :yellow     [:color "yellow"]
   :blue       [:color "blue"]
   :magenta    [:color "magenta"]
   :cyan       [:color "cyan"]
   :white      [:color "white"]
   :fg-256     nil
   :fg-reset   nil
   :bg-black   [:background-color "black"]
   :bg-red     [:background-color "red"]
   :bg-green   [:background-color "green"]
   :bg-yellow  [:background-color "yellow"]
   :bg-blue    [:background-color "blue"]
   :bg-magenta [:background-color "magenta"]
   :bg-cyan    [:background-color "cyan"]
   :bg-white   [:background-color "white"]
   :bg-256     nil
   :bg-reset   nil})

(defn style
  "Returns a formatted style attribute for a span given a seq of
  keywords usable in a :color-scheme value"
  [codes]
  (let [attributes (map #(get style-attribute % [:color (name %)]) codes)]
    (str "style=\""
         (str/join ";" (map (fn [[k v]] (str (name k) ":" v)) attributes))
         "\"")))

(defn escape-html-text
  "Escapes special characters into HTML entities."
  [text]
  (str/escape text {\& "&amp;" \< "&lt;" \> "&gt;" \" "&quot;"}))

(defn escape-html-node
  "Applies HTML escaping to the node if it is a string. Returns a print
  document representing the escaped string, or the original node if not."
  [node]
  (if (string? node)
    (let [escaped-text (escape-html-text node)
          spans (str/split escaped-text #"(?=&)")]
      (reduce (fn [acc span]
                (case (first span)
                  nil acc
                  \& (let [semicolon-pos ((fnil inc 0) (str/index-of span \;))
                           escaped (subs span 0 semicolon-pos)
                           span (subs span semicolon-pos)
                           acc (conj acc [:escaped escaped])]
                       (if (seq span)
                         (conj acc span)
                         acc))
                  (conj acc span)))
              [:span]
              spans))
    node))

(defn escape-html-document
  "Escapes special characters into fipp :span/:escaped nodes"
  [document]
  (postwalk escape-html-node document))

(defmethod color/document :html-inline
  [options element document]
  (if-let [codes (-> options :color-scheme (get element) seq)]
    [:span [:pass "<span " (style codes) ">"]
     (escape-html-document document)
     [:pass "</span>"]]
    (escape-html-document document)))

(defmethod color/text :html-inline
  [options element text]
  (if-let [codes (-> options :color-scheme (get element) seq)]
    (str "<span " (style codes) ">" (escape-html-text text) "</span>")
    (escape-html-text text)))

(defmethod color/document :html-classes
  [options element document]
  [:span [:pass "<span class=\"" (name element) "\">"]
   (escape-html-document document)
   [:pass "</span>"]])

(defmethod color/text :html-classes
  [options element text]
  (str "<span class=\"" (name element) "\">" (escape-html-text text) "</span>"))
(ns lambdaisland.deep-diff2.puget.color.ansi
  "Coloring implementation that applies ANSI color codes to text designed to be
  output to a terminal.

  Use with a `:color-markup` of `:ansi`."
  (:require
    [clojure.string :as str]
    [lambdaisland.deep-diff2.puget.color :as color]))

(def sgr-code
  "Map of symbols to numeric SGR (select graphic rendition) codes."
  {:none        0
   :bold        1
   :underline   3
   :blink       5
   :reverse     7
   :hidden      8
   :strike      9
   :black      30
   :red        31
   :green      32
   :yellow     33
   :blue       34
   :magenta    35
   :cyan       36
   :white      37
   :fg-256     38
   :fg-reset   39
   :bg-black   40
   :bg-red     41
   :bg-green   42
   :bg-yellow  43
   :bg-blue    44
   :bg-magenta 45
   :bg-cyan    46
   :bg-white   47
   :bg-256     48
   :bg-reset   49})

(defn esc
  "Returns an ANSI escope string which will apply the given collection of SGR
  codes."
  [codes]
  (let [codes (map sgr-code codes codes)
        codes (str/join \; codes)]
    (str \u001b \[ codes \m)))

(defn escape
  "Returns an ANSI escope string which will enact the given SGR codes."
  [& codes]
  (esc codes))

(defn sgr
  "Wraps the given string with SGR escapes to apply the given codes, then reset
  the graphics."
  [string & codes]
  (str (esc codes) string (escape :none)))

(defn strip
  "Removes color codes from the given string."
  [string]
  (str/replace string #"\u001b\[[0-9;]*[mK]" ""))

(defmethod color/document :ansi
  [options element document]
  (if-let [codes (-> options :color-scheme (get element) seq)]
    [:span [:pass (esc codes)] document [:pass (escape :none)]]
    document))

(defmethod color/text :ansi
  [options element text]
  (if-let [codes (-> options :color-scheme (get element) seq)]
    (str (esc codes) text (escape :none))
    text))
(ns fipp.util
  (:refer-clojure :exclude [boolean? char? regexp?]))

;;TODO: CLJ-1719 and CLJS-1241
(defn boolean? [x]
  (or (true? x) (false? x)))

#?(:cljs (defn char? [x]
           false)
   :clj (def char? clojure.core/char?))

;;TODO: CLJ-1720 and CLJS-1242
#?(:clj (defn regexp? [x]
          (instance? java.util.regex.Pattern x))
   :cljs (def regexp? cljs.core/regexp?))

(defn edn?
  "Is the root of x an edn type?"
  [x]
  (or (nil? x)
      (boolean? x)
      (string? x)
      (char? x)
      (symbol? x)
      (keyword? x)
      (number? x)
      (seq? x)
      (vector? x)
      (record? x)
      (map? x)
      (set? x)
      (tagged-literal? x)
      (var? x)
      (regexp? x)))

(defn value-obj? [x]
  #?(:clj (instance? clojure.lang.IObj x)
     :cljs (and (satisfies? IWithMeta x)
                (not (var? x))))) ;TODO: CLJS-2398

(def instant-supported?
  #?(:clj (and (try
                 (Class/forName "java.sql.Timestamp")
                 true
                 (catch ClassNotFoundException _
                   false))
               (try
                 ;; Strangely, this can fail even if the previous statement succeeded:
                 (require '[clojure.instant])
                 true
                 (catch ExceptionInInitializerError _
                   false)))
     :cljs true))
(ns fipp.ednize
  (:require [fipp.util :refer [edn? instant-supported?]]))

(defprotocol IEdn
  "Perform a shallow conversion to an Edn data structure."
  (-edn [x]))

(defprotocol IOverride
  "Mark object as preferring its custom IEdn behavior.")

(defn override? [x]
  (satisfies? IOverride x))

(defn edn [x]
  (-edn x))

(defn class->edn [^Class c]
  (if (.isArray c)
    (.getName c)
    (symbol (.getName c))))

(defn tagged-object [o rep]
  (let [cls (class->edn (class o))
        id (format "0x%x" (System/identityHashCode o))]
    (tagged-literal 'object [cls id rep])))

(extend-protocol IEdn

  nil
  (-edn [x]
    nil)

  java.lang.Object
  (-edn [x]
    (if (edn? x)
      x
      (tagged-object x (str x))))

  clojure.lang.IDeref
  (-edn [x]
    (let [pending? (and (instance? clojure.lang.IPending x)
                        (not (.isRealized ^clojure.lang.IPending x)))
          [ex val] (when-not pending?
                     (try [false @x]
                          (catch Throwable e
                            [true e])))
          failed? (or ex (and (instance? clojure.lang.Agent x)
                              (agent-error x)))
          status (cond
                   failed? :failed
                   pending? :pending
                   :else :ready)]
      (tagged-object x {:status status :val val})))

  java.lang.Class
  (-edn [x]
    (class->edn x))

  ;TODO StackTraceElement
  ;TODO print-throwable
  ;TODO reader-conditional
  ;TODO Eduction ??
  ;TODO java.util.Calendar

  java.util.UUID
  (-edn [x]
    (tagged-literal 'uuid (str x)))

  clojure.lang.PersistentQueue
  (-edn [x]
    (tagged-literal 'clojure.lang.PersistentQueue (vec x)))

  )

(defn record->tagged [x]
  (tagged-literal (-> x class .getName symbol) (into {} x)))

(when instant-supported?
  (require 'fipp.ednize.instant))
(ns fipp.visit
  "Convert to and visit edn structures."
  (:require [fipp.util :as util]
            [fipp.ednize :refer [override?]]))

;;;TODO Stablize public interface

(defprotocol IVisitor

  (visit-unknown [this x])

  (visit-nil [this])
  (visit-boolean [this x])
  (visit-string [this x])
  (visit-character [this x])
  (visit-symbol [this x])
  (visit-keyword [this x])
  (visit-number [this x])
  (visit-seq [this x])
  (visit-vector [this x])
  (visit-map [this x])
  (visit-set [this x])
  (visit-tagged [this x])

  ;; Not strictly Edn...
  (visit-meta [this meta x])
  (visit-var [this x])
  (visit-pattern [this x])
  (visit-record [this x])
  )

(defn visit*
  "Visits objects, ignoring metadata."
  [visitor x]
  (cond
    (nil? x) (visit-nil visitor)
    (override? x) (visit-unknown visitor x)
    (util/boolean? x) (visit-boolean visitor x)
    (string? x) (visit-string visitor x)
    (util/char? x) (visit-character visitor x)
    (symbol? x) (visit-symbol visitor x)
    (keyword? x) (visit-keyword visitor x)
    (number? x) (visit-number visitor x)
    (seq? x) (visit-seq visitor x)
    (vector? x) (visit-vector visitor x)
    (record? x) (visit-record visitor x)
    (map? x) (visit-map visitor x)
    (set? x) (visit-set visitor x)
    (tagged-literal? x) (visit-tagged visitor x)
    (var? x) (visit-var visitor x)
    (util/regexp? x) (visit-pattern visitor x)
    :else (visit-unknown visitor x)))

(defn value-meta [x]
  (when (util/value-obj? x)
    (meta x)))

(defn visit [visitor x]
  (if-let [m (value-meta x)]
    (visit-meta visitor m x)
    (visit* visitor x)))
(ns fipp.deque
  "Double-sided queue built on rrb vectors."
  (:refer-clojure :exclude [empty concat])
  (:require [clojure.core.rrb-vector :as rrb]))

(def create vector)

(def empty [])

(defn popl [v]
  (subvec v 1))

(def conjr (fnil conj empty))

(defn conjlr [l deque r]
  (rrb/catvec [l] deque [r]))

(def concat rrb/catvec)
(ns fipp.engine
  "See: Oleg Kiselyov, Simon Peyton-Jones, and Amr Sabry
  Lazy v. Yield: Incremental, Linear Pretty-printing"
  (:require [fipp.deque :as deque])
  #?(:clj (:import (java.io Writer))))


;;; Serialize document into a stream

(defmulti serialize-node first)

(defn serialize [doc]
  (cond
    (nil? doc) nil
    (seq? doc) (mapcat serialize doc)
    (string? doc) [{:op :text, :text doc}]
    (keyword? doc) (serialize-node [doc])
    (vector? doc) (serialize-node doc)
    :else (throw (ex-info "Unexpected class for doc node" {:node doc}))))

;; Primitives
;; See doc/primitives.md for details.

(defmethod serialize-node :text [[_ & text]]
  [{:op :text, :text (apply str text)}])

(defmethod serialize-node :pass [[_ & text]]
  [{:op :pass, :text (apply str text)}])

(defmethod serialize-node :escaped [[_ text]]
  (assert (string? text))
  [{:op :escaped, :text text}])

(defmethod serialize-node :span [[_ & children]]
  (serialize children))

(defmethod serialize-node :line [[_ inline terminate]]
  (let [inline (or inline " ")
        terminate (or terminate "")]
    (assert (string? inline))
    (assert (string? terminate))
    [{:op :line, :inline inline, :terminate terminate}]))

(defmethod serialize-node :break [& _]
  [{:op :break}])

(defmethod serialize-node :group [[_ & children]]
  (concat [{:op :begin}] (serialize children) [{:op :end}]))

(defmethod serialize-node :nest [[_ & args]]
  (let [[offset & children] (if (number? (first args))
                              args
                              (cons 2 args))]
    (concat [{:op :nest, :offset offset}]
            (serialize children)
            [{:op :outdent}])))

(defmethod serialize-node :align [[_ & args]]
  (let [[offset & children] (if (number? (first args))
                             args
                             (cons 0 args))]
    (concat [{:op :align, :offset offset}]
            (serialize children)
            [{:op :outdent}])))



(defn annotate-rights
  "A transducer which annotates the right-side of nodes assuming a
  hypothetical single-line formatting of the document. Groups and indentation
  directives are temporarily assumed to be zero-width. These values are used
  by subsequent passes to produce the final layout."
  [rf]
  (let [pos (volatile! 0)]
    (fn
      ([] (rf))
      ([res] (rf res))
      ([res node]
       (let [delta (case (:op node)
                     :text (count (:text node))
                     :line (count (:inline node))
                     :escaped 1
                     0)
             p (vswap! pos + delta)]
         (rf res (assoc node :right p)))))))



(defn update-right [deque f & args]
  (deque/conjr (pop deque) (apply f (peek deque) args)))

(defn annotate-begins
  "Given printing options, returns a transducer which annotate the right-side
  of groups on their :begin nodes.  This includes the pruning algorithm which
  will annotate some :begin nodes as being :too-far to the right without
  calculating their exact sizes."
  [{:keys [width] :as options}]
  (fn [rf]
    (let [pos (volatile! 0)
          bufs (volatile! deque/empty)]
      (fn
        ([] (rf))
        ([res] (rf res))
        ([res {:keys [op right] :as node}]
         (let [buffers @bufs]
           (if (empty? buffers)
             (if (= op :begin)
               ;; Buffer groups
               (let [position* (+ right width)
                     buffer {:position position* :nodes deque/empty}]
                 (vreset! pos position*)
                 (vreset! bufs (deque/create buffer))
                 res)
               ;; Emit unbuffered
               (rf res node))
             (if (= op :end)
               ;; Pop buffer
               (let [buffer (peek buffers)
                     buffers* (pop buffers)
                     begin {:op :begin :right right}
                     nodes (deque/conjlr begin (:nodes buffer) node)]
                 (if (empty? buffers*)
                   (do
                     (vreset! pos 0)
                     (vreset! bufs deque/empty)
                     (reduce rf res nodes))
                   (do
                     (assert (vector? buffers*))
                     (assert (vector? nodes))
                     (vreset! bufs (update-right buffers* update-in [:nodes]
                                                 deque/concat nodes))
                     res)))
               ;; Pruning lookahead
               (loop [buffers* (if (= op :begin)
                                 (deque/conjr buffers
                                              {:position (+ right width)
                                               :nodes deque/empty})
                                 (update-right buffers update-in [:nodes]
                                               deque/conjr node))
                      res res]
                 (if (and (<= right @pos) (<= (count buffers*) width))
                   ;; Not too far
                   (do (vreset! bufs buffers*)
                       res)
                   ;; Too far
                   (let [buffer (first buffers*)
                         buffers** (deque/popl buffers*)
                         begin {:op :begin, :right :too-far}
                         res* (rf res begin)
                         res* (reduce rf res* (:nodes buffer))]
                     (if (empty? buffers**)
                       ;; Root buffered group
                       (do
                         (vreset! pos 0)
                         (vreset! bufs deque/empty)
                         res*)
                       ;; Interior group
                       (do
                         (vreset! pos (:position (first buffers**)))
                         (recur buffers** res*))))))
            ))))))))


(defn format-nodes
  "Given printing options, returns a transducer which produces the fully
  laid-out strings."
  [{:keys [width] :as options}]
  (fn [rf]
    (let [fits (volatile! 0)
          length (volatile! width)
          tab-stops (volatile! '(0)) ; Technically, an unbounded stack...
          column (volatile! 0)]
      (fn
        ([] (rf))
        ([res] (rf res))
        ([res {:keys [op right] :as node}]
         (let [indent (peek @tab-stops)
               format-text (fn [text width]
                             (let [res* (if (zero? @column)
                                          (do (vswap! column + indent)
                                              (rf res (apply str (repeat indent \space))))
                                          res)]
                               (vswap! column + width)
                               (rf res* text)))]
           (case op
             :text
               (let [text (:text node)]
                 (format-text text (count text)))

             :escaped
               (format-text (:text node) 1)

             :pass
               (format-text (:text node) 0)

             :line
               (if (zero? @fits)
                 (do
                   (vreset! length (- (+ right width) indent))
                   (vreset! column 0)
                   (rf res (str (:terminate node) "\n")))
                 (let [inline (:inline node)]
                   (vswap! column + (count inline))
                   (rf res inline)))
             :break
               (do
                 (vreset! length (- (+ right width) indent))
                 (vreset! column 0)
                 (rf res "\n"))
             :nest
               (do (vswap! tab-stops conj (+ indent (:offset node)))
                   res)
             :align
               (do (vswap! tab-stops conj (+ @column (:offset node)))
                   res)
             :outdent
               (do (vswap! tab-stops pop)
                   res)
             :begin
               (do (vreset! fits (cond
                                   (pos? @fits) (inc @fits)
                                   (= right :too-far) 0
                                   (<= right @length) 1
                                   :else 0))
                   res)
             :end
               (do (vreset! fits (max 0 (dec @fits)))
                   res)
             (throw (ex-info "Unexpected node op" {:node node}))))
         )))))


(defn print-fns
  [options]
  #?(:clj (let [{:keys [^Writer writer] :or {writer *out*}} options]
            {:print #(.write writer ^String %)
             :println (fn []
                        (binding [*out* writer]
                          (println)))})
     :cljs (let [{:keys [print-fn] :or {print-fn *print-fn*}} options]
             {:print print-fn
              :println (fn []
                         (binding [*print-fn* print-fn]
                           (println)))})))


(defn pprint-document
  ([document]
   (pprint-document document {}))
  ([document options]
   (let [options (merge {:width 70} options)
         {:keys [print println]} (print-fns options)]
     (->> (serialize document)
          (eduction
            annotate-rights
            (annotate-begins options)
            (format-nodes options))
          (run! print))
     (println))))


(comment

  (defn dbg [x]
    (println "DBG:")
    (clojure.pprint/pprint x)
    (println "----")
    x)

  (serialize "apple")
  (serialize [:text "apple" "ball"])
  (serialize [:span "apple" [:group "ball" :line "cat"]])
  (serialize [:span "apple" [:line ","] "ball"])

  (def doc1 [:group "A" :line [:group "B" :line "C"]])
  (def doc2 [:group "A" :line [:nest 2 "B" :line "C"] :line "D"])
  (def doc3 [:group "A" :line
             [:nest 2 "B-XYZ" [:align -3 :line "C"]] :line "D"])

  (serialize doc1)

  (let [options {:width 3}]
    (->> doc3
         serialize
         (into [] (comp
                    annotate-rights
                    (annotate-begins options)
                    (format-nodes options)
                    ))
         ;(run! print)
         clojure.pprint/pprint
         )
    ;nil
    )

  ;; test of :pass op
  (do
    (pprint-document
      [:group "AB" :line "B" :line "C"]
      {:width 6}) 
    (println "--")
    (pprint-document
      [:group "<AB>" :line "B" :line "C"]
      {:width 6}) 
    (println "--")
    (pprint-document
      [:group [:pass "<"] "AB" [:pass ">"] :line "B" :line "C"]
      {:width 6}))

  (def ex1
    [:group "["
        [:nest 2
            [:line ""] "0,"
            :line "1,"
            :line "2,"
            :line "3"
            [:line ""]]
        "]"])

  (pprint-document ex1 {:width 20})
  (pprint-document ex1 {:width 6})

  (def ex2
    [:span "["
        [:align
            [:group [:line ""]] "0,"
            [:group :line] "1,"
            [:group :line] "2,"
            [:group :line] "3"]
        "]"])

  (pprint-document ex2 {:width 20})
  (pprint-document ex2 {:width 6})

)
(ns arrangement.core
  "This namespace provides a total-ordering comparator for Clojure values.")


(def ^:private type-predicates
  "Ordered sequence of predicates to test to determine the relative ordering of
  various data types."
  [nil?
   false?
   true?
   number?
   char?
   string?
   keyword?
   symbol?
   list?
   vector?
   set?
   map?])


(defn- type-priority
  "Determines a numeric priority for the given value based on its general
  type. See `type-predicates` for the ordering."
  [x]
  (loop [i 0]
    (if (< i (count type-predicates))
      (let [p (nth type-predicates i)]
        (if (p x)
          i
          (recur (inc i))))
      i)))


(defn- directly-comparable?
  "True if the values in a certain priority class are directly comparable."
  [p]
  (<= 3 p 7))


(defn- type-name
  "Get the type of the given object as a string. For Clojure, gets the name of
  the class of the object. For ClojureScript, gets either the `name` attribute
  or the protocol name if the `name` attribute doesn't exist."
  [x]
  #?(:clj (.getName (class x))
     :cljs (let [t (type x)
                 n (.-name t)]
             (if (empty? n)
               (pr-str t)
               n))))


(declare rank)


(defn- compare-seqs
  "Compare sequences using the given comparator. If any element of the
  sequences orders differently, it determines the ordering. Otherwise, if the
  prefix matches, the longer sequence sorts later."
  [xs ys]
  (if (and (seq xs) (seq ys))
    (let [x (first xs)
          y (first ys)
          o (rank x y)]
      (if (zero? o)
        (recur (next xs) (next ys))
        o))
    (- (count xs) (count ys))))


(defn rank
  "Comparator function that provides a total ordering of EDN values. Values of
  different types sort in order of their types, per `type-priority`. `false`
  is before `true`, numbers are ordered by magnitude regardless of type, and
  characters, strings, keywords, and symbols are ordered lexically.

  Sequential collections are sorted by comparing their elements one at a time.
  If the sequences have equal leading elements, the longer one is ordered later.
  Sets and maps are compared by cardinality first, then elements in sorted
  order.

  All other types are sorted by type name. If the type implements `Comparable`,
  the instances of it are compared using `compare`. Otherwise, the values are
  ordered by print representation. This has the default behavior of ordering by
  hash code if the type does not implement a custom print format."
  [a b]
  (if (identical? a b)
    0
    (let [pri-a (type-priority a)
          pri-b (type-priority b)]
      (cond
        (< pri-a pri-b) -1
        (> pri-a pri-b)  1

        (directly-comparable? pri-a)
        (compare a b)

        (set? a)
        (let [size-diff (- (count a) (count b))]
          (if (zero? size-diff)
            (compare-seqs (sort rank a) (sort rank b))
            size-diff))

        (map? a)
        (let [size-diff (- (count a) (count b))]
          (if (zero? size-diff)
            (compare-seqs
              (sort-by key rank (seq a))
              (sort-by key rank (seq b)))
            size-diff))

        (coll? a)
        (compare-seqs a b)

        :else
        (let [class-diff (compare (type-name a) (type-name b))]
          (if (zero? class-diff)
            #?(:clj (if (instance? Comparable a)
                      (compare a b)
                      (compare (str a) (str b)))
               :cljs (compare a b))
            class-diff))))))
(ns lambdaisland.deep-diff2.puget.printer
  "Enhanced printing functions for rendering Clojure values. The following
  options are available to control the printer:

  #### General Rendering

  `:width`

  Number of characters to try to wrap pretty-printed forms at.

  `:print-meta`

  If true, metadata will be printed before values. Defaults to the value of
  `*print-meta*` if unset.

  #### Collection Options

  `:sort-keys`

  Print maps and sets with ordered keys. If true, the pretty printer will sort
  all unordered collections before printing. If a number, counted collections
  will be sorted if they are smaller than the given size. Otherwise
  collections are printed in their natural sort order. Sorted collections are
  always printed in their natural sort order.

  `:map-delimiter`

  The text placed between key-value pairs in a map.

  `:map-coll-separator`

  The text placed between a map key and a collection value. The keyword :line
  will cause line breaks if the whole map does not fit on a single line.

  `:namespace-maps`

  Extract common keyword namespaces from maps using the namespace map literal
  syntax. See `*print-namespace-maps*`.

  `:seq-limit`

  If set to a positive number, then lists will only render at most the first n
  elements. This can help prevent unintentional realization of infinite lazy
  sequences.

  #### Color Options

  `:print-color`

  When true, ouptut colored text from print functions.

  `:color-markup`

  :ansi for ANSI color text (the default)
  :html-inline for inline-styled html
  :html-classes to use the names of the keys in the :color-scheme map
  as class names for spans so styling can be specified via CSS.

  `:color-scheme`

  Map of syntax element keywords to color codes.

  #### Type Handling

  `:print-handlers`

  A lookup function which will return a rendering function for a given class
  type. This will be tried before the built-in type logic. See the
  `lambdaisland.deep-diff2.puget.dispatch` namespace for some helpful constructors. The returned
  function should accept the current printer and the value to be rendered
  returning a format document.

  `:print-fallback`

  Keyword argument specifying how to format unknown values. Puget supports a few
  different options:

  - `:pretty` renders values with the default colored representation.
  - `:print` defers to the standard print method by rendering unknown values
    using `pr-str`.
  - `:error` will throw an exception when types with no defined handler are
    encountered.
  - A function value will be called with the current printer options and the
    unknown value and is expected to return a formatting document representing
    it.
  "
  (:require [arrangement.core :as order]
            [clojure.string :as str]
            [fipp.engine :as fe]
            [fipp.visit :as fv]
            [lambdaisland.deep-diff2.puget.color :as color]
            [lambdaisland.deep-diff2.puget.color.ansi]
            [lambdaisland.deep-diff2.puget.color.html]
            [lambdaisland.deep-diff2.puget.dispatch :as dispatch]
            #?(:cljs [goog.object :as gobj]))
  (:import #?@(:clj [(java.text SimpleDateFormat)
                     (java.util TimeZone)
                     (java.sql Timestamp)]
               :cljs [(goog.i18n DateTimeFormat)])))

(defn get-type-name
  "Get the type of the given object as a string. For Clojure, gets the name of
  the class of the object. For ClojureScript, gets either the `name` attribute
  or the protocol name if the `name` attribute doesn't exist."
  [x]
  #?(:clj (.getName (class x))
     :cljs (let [t (type x)
                 n (.-name t)]
             (if (empty? n)
               (pr-str t)
               n))))

(defn get-identity-hashcode
  "Get the hashcode for a given object o"
  [o]
  #?(:clj (System/identityHashCode o)
     :cljs (hash o)))

(defn to-hex-string
  "Returns a hex representation of input-string"
  [input-string]
  #?(:clj (Integer/toHexString input-string)
     :cljs (.toString input-string 16)))

;; ## Control Vars
(def ^:dynamic *options*
  "Default options to use when constructing new printers."
  {:width 80
   :sort-keys 80
   :map-delimiter ","
   :map-coll-separator " "
   :namespace-maps false
   :print-fallback :pretty
   :print-color false
   :color-markup :ansi
   :color-scheme
   {;; syntax elements
    :delimiter [:bold :red]
    :tag       [:red]

    ;; primitive values
    :nil       [:bold :black]
    :boolean   [:green]
    :number    [:cyan]
    :string    [:bold :magenta]
    :character [:bold :magenta]
    :keyword   [:bold :yellow]
    :symbol    nil

    ;; special types
    :function-symbol [:bold :blue]
    :class-delimiter [:blue]
    :class-name      [:bold :blue]}})

(defn merge-options
  "Merges maps of printer options, taking care to combine the color scheme
  correctly."
  [a b]
  (let [colors (merge (:color-scheme a) (:color-scheme b))]
    (assoc (merge a b) :color-scheme colors)))

(defmacro with-options
  "Executes the given expressions with a set of options merged into the current
  option map."
  [opts & body]
  `(binding [*options* (merge-options *options* ~opts)]
     ~@body))

(defmacro with-color
  "Executes the given expressions with colored output enabled."
  [& body]
  `(with-options {:print-color true}
     ~@body))

(defn color-text
  "Produces text colored according to the active color scheme. This is mostly
  useful to clients which want to produce output which matches data printed by
  Puget, but which is not directly printed by the library. Note that this
  function still obeys the `:print-color` option."
  ([element text]
   (color-text *options* element text))
  ([options element text]
   (color/text options element text)))

;; ## Formatting Methods
(defn- order-collection
  "Takes a sequence of entries and checks the mode to determine whether to sort
  them. Returns an appropriately ordered sequence."
  [mode coll sort-fn]
  (if (and (not (sorted? coll))
           (or (true? mode)
               (and (number? mode)
                    (counted? coll)
                    (>= mode (count coll)))))
    (sort-fn coll)
    (seq coll)))


(defn- common-key-ns
  "Extract a common namespace from the keys in the map. Returns a tuple of the
  ns string and the stripped map, or nil if the keys are not keywords or there
  is no sufficiently common namespace."
  [m]
  (when (every? (every-pred keyword? namespace) (keys m))
    (let [nsf (frequencies (map namespace (keys m)))
          [common n] (apply max-key val nsf)]
      (when (< (/ (count m) 2) n)
        [common
         (into (empty m)
               (map (fn strip-common
                      [[k v :as e]]
                      (if (= common (namespace k))
                        [(keyword (name k)) v]
                        e)))
               m)]))))

(defn format-unknown
  "Renders common syntax doc for an unknown representation of a value."
  ([printer value]
   (format-unknown printer value (str value)))
  ([printer value repr]
   (format-unknown printer value (get-type-name value) repr))
  ([printer value tag repr]
   (let [sys-id (to-hex-string (get-identity-hashcode value))]
     [:span
      (color/document printer :class-delimiter "#<")
      (color/document printer :class-name tag)
      (color/document printer :class-delimiter "@")
      sys-id
      (when (not= repr (str tag "@" sys-id))
        (list " " repr))
      (color/document printer :class-delimiter ">")])))

(defn format-doc*
  "Formats a document without considering metadata."
  [printer value]
  (let [lookup (:print-handlers printer)
        handler (and lookup (lookup value))]
    (if handler
      (handler printer value)
      (fv/visit* printer value))))

(defn format-doc
  "Recursively renders a print document for the given value."
  [printer value]
  (if-let [metadata (meta value)]
    (fv/visit-meta printer metadata value)
    (format-doc* printer value)))

;; ## Type Handlers
(defn pr-handler
  "Print handler which renders the value with `pr-str`."
  [printer value]
  (pr-str value))

(defn unknown-handler
  "Print handler which renders the value using the printer's unknown type logic."
  [printer value]
  (fv/visit-unknown printer value))

(defn tagged-handler
  "Generates a print handler function which renders a tagged-literal with the
  given tag and a value produced by calling the function."
  [tag value-fn]
  (when-not (symbol? tag)
    (throw (ex-info (str "Cannot create tagged handler with non-symbol tag "
                         (pr-str tag))
                    {:tag tag, :value-fn value-fn})))
  (when-not (ifn? value-fn)
    (throw (ex-info (str "Cannot create tagged handler for " tag
                         " with non-function value transform")
                    {:tag tag, :value-fn value-fn})))
  (fn handler
    [printer value]
    (format-doc printer (tagged-literal tag (value-fn value)))))

(def inst-pattern  "yyyy-MM-dd'T'HH:mm:ss.SSS-00:00")

#?(:cljs
   (defn utc-date [date]
     (js/Date.
      (.getUTCFullYear date)
      (.getUTCMonth date)
      (.getUTCDate date)
      (.getUTCHours date)
      (.getUTCMinutes date)
      (.getUTCSeconds date)
      (.getUTCMilliseconds date))))

#?(:clj
   (defn utc-timestamp-format ^SimpleDateFormat []
     (doto (SimpleDateFormat. "yyyy-MM-dd'T'HH:mm:ss")
       (.setTimeZone (TimeZone/getTimeZone "GMT")))))

(def platform-handlers
  "Map of print handlers for Java/JavaScript types. This supports syntax for regular
  expressions, dates, UUIDs, and futures."
  #?(:clj
     (->
      {java.lang.Class
       (fn class-handler
         [printer value]
         (format-unknown printer value "Class" (get-type-name value)))

       java.util.concurrent.Future
       (fn future-handler
         [printer value]
         (let [doc (if (future-done? promise)
                     (format-doc printer @value)
                     (color/document printer :nil "pending"))]
           (format-unknown printer value "Future" doc)))

       java.util.UUID
       (tagged-handler 'uuid str)

       java.util.Date
       (tagged-handler
        'inst
        #(-> (java.text.SimpleDateFormat. inst-pattern)
             (doto (.setTimeZone (java.util.TimeZone/getTimeZone "GMT")))
             (.format ^java.util.Date %)))

       java.sql.Timestamp
       (tagged-handler
        'inst
        (fn [ts]
          (str (.format ^SimpleDateFormat (utc-timestamp-format) ts)
               (format ".%09d-00:00" (.getNanos ^Timestamp ts)))))}
      #?(:bb identity
         :clj (assoc java.util.GregorianCalendar
                     (tagged-handler
                      'inst
                      #(let [formatted (format "%1$tFT%1$tT.%1$tL%1$tz" %)
                             offset-minutes (- (.length formatted) 2)]
                         (str (subs formatted 0 offset-minutes)
                              ":"
                              (subs formatted offset-minutes)))))))

     :cljs
     {inst?
      (tagged-handler
       'inst
       #(.format (DateTimeFormat. inst-pattern) (utc-date %)))

      uuid?
      (tagged-handler 'uuid str)

      object?
      (tagged-handler
       'js
       (fn [x]
         ;; non-recursive conversion to map
         (reduce (fn [m k]
                   (assoc m k (gobj/get x k)))
                 {}
                 (js/Object.keys x))))}))

(def clojure-handlers
  "Map of print handlers for 'primary' Clojure types. These should take
  precedence over the handlers in `clojure-interface-handlers`."
  {#?(:clj clojure.lang.Atom
      :cljs #(implements? IAtom %))
   (fn atom-handler
     [printer value]
     (format-unknown printer value "Atom" (format-doc printer @value)))
   #?(:clj clojure.lang.Delay
      :cljs #(implements? Delay %))
   (fn delay-handler
     [printer value]
     (let [doc (if (realized? value)
                 (format-doc printer @value)
                 (color/document printer :nil "pending"))]
       (format-unknown printer value "Delay" doc)))
   #?(:clj clojure.lang.ISeq
      :cljs seq?)
   (fn iseq-handler
     [printer value]
     (fv/visit-seq printer value))})

(def clojure-interface-handlers
  "Fallback print handlers for other Clojure interfaces."
  {#?(:clj clojure.lang.IPending
      :cljs #(implements? IPending %))
   (fn pending-handler
     [printer value]
     (let [doc (if (realized? value)
                 (format-doc printer @value)
                 (color/document printer :nil "pending"))]
       (format-unknown printer value doc)))
   #?(:clj clojure.lang.Fn
      :cljs fn?)
   (fn fn-handler
     [printer value]
     (let [doc (let [[vname & tail] (-> (get-type-name value)
                                        (str/replace-first "$" "/")
                                        (str/split #"\$"))]
                 (if (seq tail)
                   (str vname "["
                        (->> tail
                             (map #(first (str/split % #"__")))
                             (str/join "/"))
                        "]")
                   vname))]
       (format-unknown printer value "Fn" doc)))})

(def common-handlers
  "Print handler dispatch combining Java and Clojure handlers with inheritance
  lookups. Provides a similar experience as the standard Clojure
  pretty-printer."
  #?(:clj (dispatch/chained-lookup
           (dispatch/inheritance-lookup platform-handlers)
           (dispatch/inheritance-lookup clojure-handlers)
           (dispatch/inheritance-lookup clojure-interface-handlers))
     :cljs (dispatch/chained-lookup
            (dispatch/predicate-lookup platform-handlers)
            (dispatch/predicate-lookup clojure-handlers)
            (dispatch/predicate-lookup clojure-interface-handlers))))


;; ## Canonical Printer Implementation
(defrecord CanonicalPrinter [print-handlers]
  fv/IVisitor

  ;; Primitive Types
  (visit-nil
    [this]
    "nil")

  (visit-boolean
    [this value]
    (str value))

  (visit-number
    [this value]
    (pr-str value))

  (visit-character
    [this value]
    (pr-str value))

  (visit-string
    [this value]
    (pr-str value))

  (visit-keyword
    [this value]
    (str value))

  (visit-symbol
    [this value]
    (str value))

  ;; Collection Types
  (visit-seq
    [this value]
    (if (seq value)
      (let [entries (map (partial format-doc this) value)]
        [:group "(" [:align (interpose " " entries)] ")"])
      "()"))

  (visit-vector
    [this value]
    (if (seq value)
      (let [entries (map (partial format-doc this) value)]
        [:group "[" [:align (interpose " " entries)] "]"])
      "[]"))

  (visit-set
    [this value]
    (if (seq value)
      (let [entries (map (partial format-doc this)
                         (sort order/rank value))]
        [:group "#{" [:align (interpose " " entries)] "}"])
      "#{}"))

  (visit-map
    [this value]
    (if (seq value)
      (let [entries (map #(vector :span (format-doc this (key %))
                                  " "   (format-doc this (val %)))
                         (sort-by first order/rank value))]
        [:group "{" [:align (interpose " " entries)] "}"])
      "{}"))

  ;; Clojure Types
  (visit-meta
    [this metadata value]
    ;; Metadata is not printed for canonical rendering.
    (format-doc* this value))

  (visit-var
    [this value]
    ;; Defer to unknown, cover with handler.
    (fv/visit-unknown this value))

  (visit-pattern
    [this value]
    ;; Defer to unknown, cover with handler.
    (fv/visit-unknown this value))

  (visit-record
    [this value]
    ;; Defer to unknown, cover with handler.
    (fv/visit-unknown this value))

  ;; Special Types
  (visit-tagged
    [this value]
    [:span (str "#" (:tag value)) " " (format-doc this (:form value))])

  (visit-unknown
    [this value]
    (let [not-defined-representation-message (str "No defined representation for "
                                                  (get-type-name value)
                                                  ": "
                                                  (pr-str value))]
      (throw (ex-info not-defined-representation-message
                      {:causes #{:undefined-representation}})))))

(defn canonical-printer
  "Constructs a new canonical printer with the given handler dispatch."
  ([]
   (canonical-printer nil))
  ([handlers]
   (assoc (CanonicalPrinter. handlers)
          :width 0)))

;; Remove automatic constructor function.
#?(:clj (ns-unmap *ns* '->CanonicalPrinter))

;; ## Pretty Printer Implementation
(defrecord PrettyPrinter

    [width
     print-meta
     sort-keys
     map-delimiter
     map-coll-separator
     namespace-maps
     seq-limit
     print-color
     color-markup
     color-scheme
     print-handlers
     print-fallback]

  fv/IVisitor

  ;; Primitive Types
  (visit-nil
    [this]
    (color/document this :nil "nil"))

  (visit-boolean
    [this value]
    (color/document this :boolean (str value)))

  (visit-number
    [this value]
    (color/document this :number (pr-str value)))

  (visit-character
    [this value]
    (color/document this :character (pr-str value)))

  (visit-string
    [this value]
    (color/document this :string (pr-str value)))

  (visit-keyword
    [this value]
    (color/document this :keyword (str value)))

  (visit-symbol
    [this value]
    (color/document this :symbol (str value)))

  ;; Collection Types
  (visit-seq
    [this value]
    (if (seq value)
      (let [[values trimmed?]
            (if (and seq-limit (pos? seq-limit))
              (let [head (take seq-limit value)]
                [head (<= seq-limit (count head))])
              [(seq value) false])
            elements
            (cond-> (if (symbol? (first values))
                      (cons (color/document this :function-symbol (str (first values)))
                            (map (partial format-doc this) (rest values)))
                      (map (partial format-doc this) values))
              trimmed? (concat [(color/document this :nil "...")]))]
        [:group
         (color/document this :delimiter "(")
         [:align (interpose :line elements)]
         (color/document this :delimiter ")")])
      (color/document this :delimiter "()")))

  (visit-vector
    [this value]
    (if (seq value)
      [:group
       (color/document this :delimiter "[")
       [:align (interpose :line (map (partial format-doc this) value))]
       (color/document this :delimiter "]")]
      (color/document this :delimiter "[]")))

  (visit-set
    [this value]
    (if (seq value)
      (let [entries (order-collection sort-keys value (partial sort order/rank))]
        [:group
         (color/document this :delimiter "#{")
         [:align (interpose :line (map (partial format-doc this) entries))]
         (color/document this :delimiter "}")])
      (color/document this :delimiter "#{}")))

  (visit-map
    [this value]
    (if (seq value)
      (let [[common-ns stripped] (when namespace-maps (common-key-ns value))
            kvs (order-collection sort-keys
                                  (or stripped value)
                                  (partial sort-by first order/rank))
            entries (map (fn [[k v]]
                           [:span
                            (format-doc this k)
                            (if (coll? v)
                              map-coll-separator
                              " ")
                            (format-doc this v)])
                         kvs)
            map-doc [:group
                     (color/document this :delimiter "{")
                     [:align (interpose [:span map-delimiter :line] entries)]
                     (color/document this :delimiter "}")]]
        (if common-ns
          [:group (color/document this :tag (str "#:" common-ns)) :line map-doc]
          map-doc))
      (color/document this :delimiter "{}")))

  ;; Clojure Types
  (visit-meta
    [this metadata value]
    (if print-meta
      [:align
       [:span (color/document this :delimiter "^") (format-doc this metadata)]
       :line (format-doc* this value)]
      (format-doc* this value)))

  (visit-var
    [this value]
    [:span
     (color/document this :delimiter "#'")
     (color/document this :symbol (subs (str value) 2))])

  (visit-pattern
    [this value]
    [:span
     (color/document this :delimiter "#")
     (color/document this :string (str \" value \"))])

  (visit-record
    [this value]
    (fv/visit-tagged
     this
     (tagged-literal (symbol (get-type-name value))
                     (into {} value))))

  ;; Special Types
  (visit-tagged
    [this value]
    (let [{:keys [tag form]} value]
      [:group
       (color/document this :tag (str "#" (:tag value)))
       (if (coll? form) :line " ")
       (format-doc this (:form value))]))

  (visit-unknown
    [this value]
    (case print-fallback
      :pretty
      (format-unknown this value)

      :print
      [:span (pr-str value)]

      :error
      (throw (ex-info (str "No defined representation for " (get-type-name value) ": " (pr-str value))
                      {:causes #{:undefined-representation}}))
      (if (ifn? print-fallback)
        (print-fallback this value)
        (throw (ex-info (str "Unsupported value for print-fallback: " (pr-str print-fallback))
                        {:causes #{:unsupported-value}}))))))

(defn pretty-printer
  "Constructs a new printer from the given configuration."
  [opts]
  (->> [{:print-meta *print-meta*
         :print-handlers common-handlers}
        *options*
        opts]
       (reduce merge-options)
       (map->PrettyPrinter)))

;; Remove automatic constructor function.
#?(:clj (ns-unmap *ns* '->PrettyPrinter))

;; ## Printing Functions
(defn render-out
  "Prints a value using the given printer."
  ([printer value]
   (render-out printer value nil))
  ([printer value opts]
   (binding [*print-meta* false]
     (fe/pprint-document
      (format-doc printer value)
      (merge {:width (:width printer)}
             opts)))))

(defn render-str
  "Renders a value to a string using the given printer."
  ^String
  [printer value]
  (str/trim-newline
   (with-out-str
     (render-out printer value))))

(defn pprint
  "Pretty-prints a value to *out*. Options may be passed to override the
  default *options* map."
  ([value]
   (pprint value nil))
  ([value opts]
   (render-out (pretty-printer opts) value opts)))

(defn pprint-str
  "Pretty-print a value to a string."
  ([value]
   (pprint-str value nil))
  ([value opts]
   (render-str (pretty-printer opts) value)))

(defn cprint
  "Like pprint, but turns on colored output."
  ([value]
   (cprint value nil))
  ([value opts]
   (pprint value (assoc opts :print-color true))))

(defn cprint-str
  "Pretty-prints a value to a colored string."
  ([value]
   (cprint-str value nil))
  ([value opts]
   (pprint-str value (assoc opts :print-color true))))
(ns lambdaisland.deep-diff2.printer-impl
  (:require [arrangement.core]
            [fipp.engine :as fipp]
            [lambdaisland.deep-diff2.diff-impl :as diff]
            [lambdaisland.deep-diff2.puget.color :as color]
            [lambdaisland.deep-diff2.puget.dispatch :as dispatch]
            [lambdaisland.deep-diff2.puget.printer :as puget-printer]
            #?(:cljs [goog.string :refer [format]]))
  #?(:clj
     (:import)))

(defn print-deletion [printer expr]
  (let [no-color (assoc printer :print-color false)]
    (color/document printer ::deletion [:span "-" (puget-printer/format-doc no-color (:- expr))])))

(defn print-insertion [printer expr]
  (let [no-color (assoc printer :print-color false)]
    (color/document printer ::insertion [:span "+" (puget-printer/format-doc no-color (:+ expr))])))

(defn print-mismatch [printer expr]
  [:group
   [:span ""] ;; needed here to make this :nest properly in kaocha.report/print-expr '=
   [:align
    (print-deletion printer expr) :line
    (print-insertion printer expr)]])

(defn print-other [printer expr]
  (let [no-color (assoc printer :print-color false)]
    (color/document printer ::other [:span "-" (puget-printer/format-doc no-color expr)])))

(defn- map-handler [this value]
  (let [ks (#'puget-printer/order-collection (:sort-keys this) value (partial sort-by first arrangement.core/rank))
        entries (map (partial puget-printer/format-doc this) ks)]
    [:group
     (color/document this :delimiter "{")
     [:align (interpose [:span (:map-delimiter this) :line] entries)]
     (color/document this :delimiter "}")]))

(defn- map-entry-handler [printer value]
  (let [k (key value)
        v (val value)]
    (let [no-color (assoc printer :print-color false)]
      (cond
        (instance? lambdaisland.deep_diff2.diff_impl.Insertion k)
        [:span
         (print-insertion printer k)
         (if (coll? v) (:map-coll-separator printer) " ")
         (color/document printer ::insertion (puget-printer/format-doc no-color v))]

        (instance? lambdaisland.deep_diff2.diff_impl.Deletion k)
        [:span
         (print-deletion printer k)
         (if (coll? v) (:map-coll-separator printer) " ")
         (color/document printer ::deletion (puget-printer/format-doc no-color v))]

        :else
        [:span
         (puget-printer/format-doc printer k)
         (if (coll? v) (:map-coll-separator printer) " ")
         (puget-printer/format-doc printer v)]))))

(def print-handlers
  (atom #?(:clj
           {'lambdaisland.deep_diff2.diff_impl.Deletion
            print-deletion

            'lambdaisland.deep_diff2.diff_impl.Insertion
            print-insertion

            'lambdaisland.deep_diff2.diff_impl.Mismatch
            print-mismatch

            'clojure.lang.PersistentArrayMap
            map-handler

            'clojure.lang.PersistentHashMap
            map-handler

            'clojure.lang.MapEntry
            map-entry-handler}

           :cljs
           {'lambdaisland.deep-diff2.diff-impl/Deletion
            print-deletion

            'lambdaisland.deep-diff2.diff-impl/Insertion
            print-insertion

            'lambdaisland.deep-diff2.diff-impl/Mismatch
            print-mismatch

            'cljs.core/PersistentArrayMap
            map-handler

            'cljs.core/PersistentHashMap
            map-handler

            'cljs.core/MapEntry
            map-entry-handler})))

(defn type-name
  "Get the type of the given object as a string. For Clojure, gets the name of
  the class of the object. For ClojureScript, gets either the `name` attribute
  or the protocol name if the `name` attribute doesn't exist."
  [x]
  #?(:bb
     (symbol (str (type x)))
     :clj
     (symbol (.getName (class x)))
     :cljs
     (let [t (type x)
           n (.-name t)]
       (if (empty? n)
         (symbol (pr-str t))
         (symbol n)))))

(defn- print-handler-resolver [extra-handlers]
  (fn [obj]
    (and obj (get (merge @print-handlers extra-handlers)
                  (symbol (type-name obj))))))

(defn register-print-handler!
  "Register an extra print handler.

  `type` must be a symbol of the fully qualified class name. `handler` is a
  Puget handler function of two arguments, `printer` and `value`."
  [type handler]
  (swap! print-handlers assoc type handler))

(defn puget-printer
  ([]
   (puget-printer {}))
  ([opts]
   (let [extra-handlers (:extra-handlers opts)]
     (puget-printer/pretty-printer (merge {:width          (or *print-length* 100)
                                           :print-color    true
                                           :color-scheme   {::deletion  [:red]
                                                            ::insertion [:green]
                                                            ::other     [:yellow]
                                                            ;; lambdaisland.deep-diff2.puget uses green and red for
                                                            ;; boolean/tag, but we want to reserve
                                                            ;; those for diffed values.
                                                            :boolean    [:bold :cyan]
                                                            :tag        [:magenta]}
                                           :print-handlers  (dispatch/chained-lookup
                                                             (print-handler-resolver extra-handlers)
                                                             puget-printer/common-handlers)}
                                          (dissoc opts :extra-handlers))))))

(defn format-doc [expr printer]
  (puget-printer/format-doc printer expr))

(defn print-doc [doc printer]
  (fipp.engine/pprint-document doc {:width (:width printer)}))
(ns lambdaisland.deep-diff2
  (:require
   [lambdaisland.deep-diff2.diff-impl :as diff-impl]
   [lambdaisland.deep-diff2.printer-impl :as printer-impl]
   [lambdaisland.deep-diff2.minimize-impl :as minimize]))

(defn diff
  "Compare two values recursively.

  The result is a data structure similar to the ones passed in, but with
  Insertion, Deletion, and Mismatch objects to mark differences.

  When two collections are considered to be in the same type class then their
  contents are compared.

  Vectors, sequences, arrays and Java lists are all considered a single type
  class, as are Clojure and Java maps.

  Insertions/Deletions in maps are marked by wrapping the key, even though the
  change applies to the whole map entry."
  [expected actual]
  (diff-impl/diff expected actual))

(defn printer
  "Construct a Puget printer instance suitable for printing diffs.

  Extra options are passed on to Puget. Extra type handlers can be provides as
  `:extra-handlers` (a map from symbol to function), or by
  using [[lambdaisland.deep-diff.printer/register-print-handler!]]"
  ([]
   (printer {:print-fallback :print}))
  ([opts]
   (printer-impl/puget-printer opts)))

(defn pretty-print
  "Pretty print a diff.

  Pretty print a diffed data structure, as obtained from [[diff]]. Optionally
  takes a Puget printer instance, see [[printer]]."
  ([diff]
   (pretty-print diff (printer)))
  ([diff printer]
   (-> diff
       (printer-impl/format-doc printer)
       (printer-impl/print-doc printer))))

(defn minimize
  "Return a minimal diff, removing any values that haven't changed."
  [diff]
  (minimize/minimize diff))
(ns borkdude.dynaload
  #?(:cljs (:require-macros [borkdude.dynaload :refer [dynaload if-bb]])))

(defmacro if-bb
  [then else]
  (if #?(:clj (System/getProperty "babashka.version")
         :cljs false)
    then
    else))

(if-bb
    #?(:clj
       (defn ->LazyVar [f _]
         (let [cached (volatile! nil)]
           (reify
             clojure.lang.IDeref
             (deref [_this]
               (if-not (nil? @cached)
                 cached
                 (let [x (f)]
                   (when-not (nil? x)
                     (vreset! cached x))
                   x)))
             clojure.lang.IFn
             (invoke [this]
               (@this))
             (invoke [this a]
               (@this a))
             (invoke [this a b]
               (@this a b))
             (invoke [this a b c]
               (@this a b c))
             (invoke [this a b c d]
               (@this a b c d))
             (invoke [this a b c d e]
               (@this a b c d e))
             (invoke [this a b c d e f]
               (@this a b c d e f))
             (invoke [this a b c d e f g]
               (@this a b c d e f g))
             (invoke [this a b c d e f g h]
               (@this a b c d e f g h))
             (invoke [this a b c d e f g h i]
               (@this a b c d e f g h i))
             (invoke [this a b c d e f g h i j]
               (@this a b c d e f g h i j))
             (invoke [this a b c d e f g h i j k]
               (@this a b c d e f g h i j k))
             (invoke [this a b c d e f g h i j k l]
               (@this a b c d e f g h i j k l))
             (invoke [this a b c d e f g h i j k l m]
               (@this a b c d e f g h i j k l m))
             (invoke [this a b c d e f g h i j k l m n]
               (@this a b c d e f g h i j k l m n))
             (invoke [this a b c d e f g h i j k l m n o]
               (@this a b c d e f g h i j k l m n o))
             (invoke [this a b c d e f g h i j k l m n o p]
               (@this a b c d e f g h i j k l m n o p))
             (invoke [this a b c d e f g h i j k l m n o p q]
               (@this a b c d e f g h i j k l m n o p q))
             (invoke [this a b c d e f g h i j k l m n o p q r]
               (@this a b c d e f g h i j k l m n o p q r))
             (invoke [this a b c d e f g h i j k l m n o p q r s]
               (@this a b c d e f g h i j k l m n o p q r s))
             ;; for some reason not working yet in bb
             #_(invoke [this a b c d e f g h i j k l m n o p q r s t]
                 (@this a b c d e f g h i j k l m n o p q r s t))
             #_(invoke [this a b c d e f g h i j k l m n o p q r s t rest]
                 (apply @this a b c d e f g h i j k l m n o p q r s t rest))
             (applyTo [this args]
               (apply @this args)))))
       :cljs nil)
  #?(:org.babashka/nbb nil
     :default
     (deftype LazyVar #?(:clj [f ^:volatile-mutable cached] :cljs [f ^:mutable cached])
       #?(:clj clojure.lang.IDeref :cljs IDeref)
       (#?(:clj deref :cljs -deref) [_this]
         (if-not (nil? cached)
           cached
           (let [x (f)]
             (when-not (nil? x)
               (set! cached x))
             x)))
       #?(:clj clojure.lang.IFn :cljs IFn)
       (#?(:clj invoke :cljs -invoke) [this]
         (@this))
       (#?(:clj invoke :cljs -invoke) [this a]
         (@this a))
       (#?(:clj invoke :cljs -invoke) [this a b]
         (@this a b))
       (#?(:clj invoke :cljs -invoke) [this a b c]
         (@this a b c))
       (#?(:clj invoke :cljs -invoke) [this a b c d]
         (@this a b c d))
       (#?(:clj invoke :cljs -invoke) [this a b c d e]
         (@this a b c d e))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f]
         (@this a b c d e f))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g]
         (@this a b c d e f g))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h]
         (@this a b c d e f g h))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i]
         (@this a b c d e f g h i))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j]
         (@this a b c d e f g h i j))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k]
         (@this a b c d e f g h i j k))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l]
         (@this a b c d e f g h i j k l))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m]
         (@this a b c d e f g h i j k l m))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n]
         (@this a b c d e f g h i j k l m n))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n o]
         (@this a b c d e f g h i j k l m n o))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n o p]
         (@this a b c d e f g h i j k l m n o p))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n o p q]
         (@this a b c d e f g h i j k l m n o p q))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n o p q r]
         (@this a b c d e f g h i j k l m n o p q r))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n o p q r s]
         (@this a b c d e f g h i j k l m n o p q r s))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n o p q r s t]
         (@this a b c d e f g h i j k l m n o p q r s t))
       (#?(:clj invoke :cljs -invoke) [this a b c d e f g h i j k l m n o p q r s t rest]
         (apply @this a b c d e f g h i j k l m n o p q r s t rest))
       #?(:clj
          (applyTo [this args]
                   (apply @this args))))))

(defmacro ? [& {:keys [cljs clj]}]
  (if (contains? &env '&env)
    `(if (:ns ~'&env) ~cljs ~clj)
    (if #?(:clj (:ns &env) :cljs true)
      cljs
      clj)))

#?(:clj
   (def resolve-at-compile-time? (= "true"
                                    (System/getProperty "borkdude.dynaload.aot"))))

#?(:clj (defonce ^:private dynalock (Object.)))

#?(:clj
   (defmacro ^:private locking2
     "Executes exprs in an implicit do, while holding the monitor of x.
  Will release the monitor of x in all circumstances."
     {:added "1.0"}
     [x & body]
     #?(:bb
        `(locking ~x ~body)
        :default
        `(let [lockee# ~x]
           (try
             (let [locklocal# lockee#]
               (monitor-enter locklocal#)
               (try
                 ~@body
                 (finally
                   (monitor-exit locklocal#)))))))))

#?(:clj (def resolve*
          (if resolve-at-compile-time?
            (constantly nil)
            (fn [sym]
              (let [ns (namespace sym)]
                (assert ns)
                (try (locking2 dynalock
                               (require (symbol ns)))
                     (catch Exception _ nil))
                (resolve sym))))))

(defmacro dynaload
  ([s] `(dynaload ~s {}))
  ([[_quote s] opts]
   #?(:org.babashka/nbb
      `(let [d# (delay (or (resolve '~s)
                           (if-let [e# (find ~opts :default)]
                             (val e#)
                             (throw
                              (ex-info
                               (str "Var " '~s " does not exist, "
                                    (namespace '~s) " never required")
                               {})))))]
         (fn
           ([]
            (@d#))
           ([a0]
            (@d# a0))
           ([a0 a1]
            (@d# a0 a1))
           ([a0 a1 a2]
            (@d# a0 a1 a2))
           ([a0 a1 a2 a3]
            (@d# a0 a1 a2 a3))
           ([a0 a1 a2 a3 a4]
            (@d# a0 a1 a2 a3 a4))
           ([a0 a1 a2 a3 a4 & args]
            (apply @d# a0 a1 a2 a3 a4 args))))
      :default
      #_{:clj-kondo/ignore[:redundant-let]}
      (let [#?@(:clj [resolved-at-compile-time (when resolve-at-compile-time?
                                                 (resolve s))])]
        `(->LazyVar
          (fn []
            (? :clj
               (if-let [v# (or #?(:clj ~resolved-at-compile-time)
                               (resolve* '~s))]
                 v#
                 (if-let [e# (find ~opts :default)]
                   (val e#)
                   (throw
                    (ex-info
                     (str "Var " '~s " does not exist, "
                          (namespace '~s) " never required")
                     {}))))
               :cljs
               (if (cljs.core/exists? ~s)
                 ~(vary-meta s assoc :cljs.analyzer/no-resolve true)
                 (if-let [e# (find ~opts :default)]
                   (val e#)
                   (throw
                    (js/Error.
                     (str "Var " '~s " does not exist, "
                          (namespace '~s) " never required")))))))
          nil)))))
(ns malli.sci
  (:require [borkdude.dynaload :as dynaload]))

(defn evaluator [options fail!]
  #?(:bb      (fn []
                (fn [form]
                  (load-string (str "(ns user (:require [malli.core :as m]))\n" form))))
     :default (let [eval-string* (dynaload/dynaload 'sci.core/eval-string* {:default nil})
                    init (dynaload/dynaload 'sci.core/init {:default nil})
                    fork (dynaload/dynaload 'sci.core/fork {:default nil})]
                (fn [] (if (and @eval-string* @init @fork)
                         (let [ctx (init options)]
                           (eval-string* ctx "(alias 'm 'malli.core)")
                           (fn eval [s]
                             (eval-string* (fork ctx) (str s))))
                         fail!)))))
(ns malli.registry
  (:refer-clojure :exclude [type])
  #?(:clj (:import (java.util HashMap Map))))

#?(:cljs (goog-define mode "default")
   :clj  (def mode (as-> (or (System/getProperty "malli.registry/mode") "default") $ (.intern $))))

#?(:cljs (goog-define type "default")
   :clj  (def type (as-> (or (System/getProperty "malli.registry/type") "default") $ (.intern $))))

(defprotocol Registry
  (-schema [this type] "returns the schema from a registry")
  (-schemas [this] "returns all schemas from a registry"))

(defn registry? [x] (#?(:clj instance?, :cljs implements?) malli.registry.Registry x))

(defn fast-registry [m]
  (let [fm #?(:clj (doto (HashMap. 1024 0.25) (.putAll ^Map m)), :cljs m)]
    (reify
      Registry
      (-schema [_ type] (.get fm type))
      (-schemas [_] m))))

(defn simple-registry [m]
  (reify
    Registry
    (-schema [_ type] (m type))
    (-schemas [_] m)))

(defn registry [?registry]
  (cond (nil? ?registry) nil
        (registry? ?registry) ?registry
        (map? ?registry) (simple-registry ?registry)
        (satisfies? Registry ?registry) ?registry))

;;
;; custom
;;

(def ^:private registry* (atom (simple-registry {})))

(defn set-default-registry! [?registry]
  (if-not (identical? mode "strict")
    (reset! registry* (registry ?registry))
    (throw (ex-info "can't set default registry, invalid mode" {:mode mode, :type type}))))

(defn ^:no-doc custom-default-registry []
  (reify
    Registry
    (-schema [_ type] (-schema @registry* type))
    (-schemas [_] (-schemas @registry*))))

(defn composite-registry [& ?registries]
  (let [registries (mapv registry ?registries)]
    (reify
      Registry
      (-schema [_ type] (some #(-schema % type) registries))
      (-schemas [_] (reduce merge (map -schemas (reverse registries)))))))

(defn mutable-registry [db]
  (reify
    Registry
    (-schema [_ type] (-schema (registry @db) type))
    (-schemas [_] (-schemas (registry @db)))))

(def ^:dynamic *registry* {})

(defn dynamic-registry []
  (reify
    Registry
    (-schema [_ type] (-schema (registry *registry*) type))
    (-schemas [_] (-schemas (registry *registry*)))))

(defn lazy-registry [default-registry provider]
  (let [cache* (atom {})
        registry* (atom default-registry)]
    (reset!
     registry*
     (composite-registry
      default-registry
      (reify
        Registry
        (-schema [_ name]
          (or (@cache* name)
              (when-let [schema (provider name @registry*)]
                (swap! cache* assoc name schema)
                schema)))
        (-schemas [_] @cache*))))))

(defn schema
  "finds a schema from a registry"
  [registry type]
  (-schema registry type))

(defn schemas
  "finds all schemas from a registry"
  [registry]
  (-schemas registry))
(ns malli.impl.util
  #?(:clj (:import #?(:bb  (clojure.lang MapEntry)
                      :clj (clojure.lang MapEntry LazilyPersistentVector))
                   (java.util.concurrent TimeoutException TimeUnit FutureTask))))

(def ^:const +max-size+ #?(:clj Long/MAX_VALUE, :cljs (.-MAX_VALUE js/Number)))

(defn -tagged [k v] #?(:clj (MapEntry. k v), :cljs (MapEntry. k v nil)))
(defn -tagged? [v] (instance? MapEntry v))

(defn -invalid? [x] #?(:clj (identical? x :malli.core/invalid), :cljs (keyword-identical? x :malli.core/invalid)))
(defn -map-valid [f v] (if (-invalid? v) v (f v)))
(defn -map-invalid [f v] (if (-invalid? v) (f v) v))
(defn -reduce-kv-valid [f init coll] (reduce-kv (comp #(-map-invalid reduced %) f) init coll))

(defn -last [x] (if (vector? x) (peek x) (last x)))
(defn -some [pred coll] (reduce (fn [ret x] (if (pred x) (reduced true) ret)) nil coll))
(defn -merge [m1 m2] (if m1 (persistent! (reduce-kv assoc! (transient m1) m2)) m2))

(defn -error
  ([path in schema value] {:path path, :in in, :schema schema, :value value})
  ([path in schema value type] {:path path, :in in, :schema schema, :value value, :type type}))

(defn -vmap
  ([os] (-vmap identity os))
  ([f os] #?(:clj  (let [c (count os)]
                     (if-not (zero? c)
                       (let [oa (object-array c), iter (.iterator ^Iterable os)]
                         (loop [n 0] (when (.hasNext iter) (aset oa n (f (.next iter))) (recur (unchecked-inc n))))
                         #?(:bb  (vec oa)
                            :clj (LazilyPersistentVector/createOwning oa))) []))
             :cljs (into [] (map f) os))))

#?(:clj
   (defn ^:no-doc -run [^Runnable f ms]
     (let [task (FutureTask. f), t (Thread. task)]
       (try
         (.start t) (.get task ms TimeUnit/MILLISECONDS)
         (catch TimeoutException _ (.cancel task true) ::timeout)
         (catch Exception e (.cancel task true) (throw e))))))

#?(:clj
   (defmacro -combine-n
     [c n xs]
     (let [syms (repeatedly n gensym)
           g (gensym "preds__")
           bs (interleave syms (map (fn [n] `(nth ~g ~n)) (range n)))
           arg (gensym "arg__")
           body `(~c ~@(map (fn [sym] `(~sym ~arg)) syms))]
       `(let [~g (-vmap ~xs) ~@bs]
          (fn [~arg] ~body)))))

#?(:clj
   (defmacro -pred-composer
     [c n]
     (let [preds (gensym "preds__")
           f (gensym "f__")
           cases (mapcat (fn [i] [i `(-combine-n ~c ~i ~preds)]) (range 2 (inc n)))
           else `(let [p# (~f (take ~n ~preds)) q# (~f (drop ~n ~preds))]
                   (fn [x#] (~c (p# x#) (q# x#))))]
       `(fn ~f [~preds]
          (case (count ~preds)
            0 (constantly true)
            1 (first ~preds)
            ~@cases
            ~else)))))

(def ^{:arglists '([[& preds]])} -every-pred
  #?(:clj  (-pred-composer and 16)
     :cljs (fn [preds] (fn [m] (boolean (reduce #(or (%2 m) (reduced false)) true preds))))))

(def ^{:arglists '([[& preds]])} -some-pred
  #?(:clj  (-pred-composer or 16)
     :cljs (fn [preds] (fn [x] (boolean (some #(% x) preds))))))
(ns malli.impl.regex
  "Regular expressions of sequences implementation namespace.

  The implementation is very similar to Packrat or GLL parser combinators.
  The parsing functions need to be written in CPS to support backtracking
  inside :*, :+ and :repeat. They also need to be trampolined because the
  (manually) CPS-converted code (for :*, :+ and :repeat) has to use tail
  calls instead of loops and Clojure does not have TCO.

  Because backtracking is used we need to memoize (parsing function, seq
  position, register stack) triples to avoid exponential behaviour. Discarding
  the memoization cache after traversing an input seq also requires trampolining.
  Because regular expressions don't use (nontail) recursion by definition, finding
  a memoization entry just means the parser already went 'here' and ultimately
  failed; much simpler than the graph-structured stacks of GLL. And the register
  stack is only there for and used by :repeat.

  NOTE: For the memoization to work correctly, every node in the schema tree
  must get its own validation/explanation/... function instance. So even every
  `(malli.impl.regex/cat)` call must return a new fn instance although it does not
  close over anything.

  https://epsil.github.io/gll/ is a nice explanation of GLL parser combinators
  and has links to papers etc. It also inspired Instaparse, which Engelberg
  had a presentation about at Clojure/West 2014.

  Despite the CPS and memoization, this implementation looks more like normal
  Clojure code than the 'Pike VM' in Seqexp. Hopefully JITs also see it that
  way and compile decent machine code for it. It is also much easier to extend
  for actual parsing (e.g. encode, decode [and parse?]) instead of just
  recognition for `validate`.

  For a more detailed explanation of this namespace see also
  https://www.metosin.fi/blog/malli-regex-schemas/."

  (:refer-clojure :exclude [+ * repeat cat])
  (:require [malli.impl.util :as miu])
  #?(:bb  (:import [java.util ArrayDeque])
     :clj (:import [java.util ArrayDeque]
                   [clojure.lang Util Murmur3]
                   [java.lang.reflect Array])))

;;;; # Driver Protocols

(defprotocol ^:private Driver
  (succeed! [self])
  (succeeded? [self])
  (pop-thunk! [self]))

(defprotocol ^:private IValidationDriver
  (noncaching-park-validator! [driver validator regs pos coll k])
  (park-validator! [driver validator regs pos coll k]))

(defprotocol ^:private IExplanationDriver
  (noncaching-park-explainer! [driver explainer regs pos coll k])
  (park-explainer! [driver explainer regs pos coll k])
  (value-path [self pos])
  (fail! [self pos errors*])
  (latest-errors [self]))

(defprotocol ^:private IParseDriver
  (noncaching-park-transformer! [driver transformer regs coll* pos coll k])
  (park-transformer! [driver transformer regs coll* pos coll k])
  (succeed-with! [self v])
  (success-result [self]))

;;;; # Primitives

;;;; ## Seq Item

(defn item-validator [valid?]
  (fn [_ _ pos coll k]
    (when (and (seq coll) (valid? (first coll)))
      (k (inc pos) (rest coll)))))

(defn item-explainer [path schema schema-explainer]
  (fn [driver _ pos coll k]
    (let [in (value-path driver pos)]
      (if (seq coll)
        (let [errors (schema-explainer (first coll) in [])]
          (if (seq errors)
            (fail! driver pos errors)
            (k (inc pos) (rest coll))))
        (fail! driver pos [(miu/-error path in schema nil :malli.core/end-of-input)])))))

(defn item-parser [parse]
  (fn [_ _ pos coll k]
    (when (seq coll)
      (let [v (parse (first coll))]
        (when-not (= v :malli.core/invalid)
          (k v (inc pos) (rest coll)))))))

(defn item-unparser [unparse] (fn [v] (miu/-map-valid vector (unparse v))))

(defn item-encoder [valid? encode]
  (fn [_ _ coll* pos coll k]
    (when (seq coll)
      (let [v (first coll)]
        (when (valid? v)
          (k (conj coll* (encode v)) (inc pos) (rest coll)))))))

(defn item-decoder [decode valid?]
  (fn [_ _ coll* pos coll k]
    (when (seq coll)
      (let [v (decode (first coll))]
        (when (valid? v)
          (k (conj coll* v) (inc pos) (rest coll)))))))

(defn item-transformer [method validator t]
  (case method
    :encode (item-encoder validator t)
    :decode (item-decoder t validator)))

;;;; ## End of Seq

(defn end-validator [] (fn [_ _ pos coll k] (when (empty? coll) (k pos coll))))

(defn end-explainer [schema path]
  (fn [driver _ pos coll k]
    (if (empty? coll)
      (k pos coll)
      (fail! driver pos (list (miu/-error path (value-path driver pos) schema (first coll) :malli.core/input-remaining))))))

(defn end-parser [] (fn [_ _ pos coll k] (when (empty? coll) (k nil pos coll))))

(defn end-transformer [] (fn [_ _ coll* pos coll k] (when (empty? coll) (k coll* pos coll))))

;;;; ## Unit

(defn pure-parser [v] (fn [_ _ pos coll k] (k v pos coll)))

(defn pure-unparser [_] [])

;;;; # Combinators

;;;; ## Functor

(defn fmap-parser [f p]
  (fn [driver regs pos coll k]
    (p driver regs pos coll (fn [v pos coll] (k (f v) pos coll)))))

;;;; ## Catenation

(defn- entry->regex [?kr] (if (vector? ?kr) (get ?kr 1) ?kr))

(defn cat-validator
  ([] (fn [_ _ pos coll k] (k pos coll)))
  ([?kr & ?krs]
   (reduce (fn [acc ?kr]
             (let [r* (entry->regex ?kr)]
               (fn [driver regs pos coll k]
                 (acc driver regs pos coll (fn [pos coll] (r* driver regs pos coll k))))))
           (entry->regex ?kr) ?krs)))

(defn cat-explainer
  ([] (fn [_ _ pos coll k] (k pos coll)))
  ([?kr & ?krs]
   (reduce (fn [acc ?kr]
             (let [r* (entry->regex ?kr)]
               (fn [driver regs pos coll k]
                 (acc driver regs pos coll (fn [pos coll] (r* driver regs pos coll k))))))
           (entry->regex ?kr) ?krs)))

(defn cat-parser
  ([] (fn [_ _ pos coll k] (k [] pos coll)))
  ([r & rs]
   (let [sp (reduce (fn [acc r]
                      (fn [driver regs coll* pos coll k]
                        (r driver regs pos coll
                           (fn [v pos coll] (acc driver regs (conj coll* v) pos coll k)))))
                    (fn [_ _ coll* pos coll k] (k coll* pos coll))
                    (reverse (cons r rs)))]
     (fn [driver regs pos coll k] (sp driver regs [] pos coll k)))))

(defn catn-parser
  ([] (fn [_ _ pos coll k] (k {} pos coll)))
  ([kr & krs]
   (let [sp (reduce (fn [acc [tag r]]
                      (fn [driver regs m pos coll k]
                        (r driver regs pos coll
                           (fn [v pos coll] (acc driver regs (assoc m tag v) pos coll k)))))
                    (fn [_ _ m pos coll k] (k m pos coll))
                    (reverse (cons kr krs)))]
     (fn [driver regs pos coll k] (sp driver regs {} pos coll k)))))

(defn cat-unparser [& unparsers]
  (let [unparsers (vec unparsers)]
    (fn [tup]
      (if (and (vector? tup) (= (count tup) (count unparsers)))
        (miu/-reduce-kv-valid (fn [coll i unparser] (miu/-map-valid #(into coll %) (unparser (get tup i))))
                              [] unparsers)
        :malli.core/invalid))))

(defn catn-unparser [& unparsers]
  (let [unparsers (apply array-map (mapcat identity unparsers))]
    (fn [m]
      (if (and (map? m) (= (count m) (count unparsers)))
        (miu/-reduce-kv-valid (fn [coll tag unparser]
                                (if-some [kv (find m tag)]
                                  (miu/-map-valid #(into coll %) (unparser (val kv)))
                                  :malli.core/invalid))
                              ;; `m` is in hash order, so have to iterate over `unparsers` to restore seq order:
                              [] unparsers)
        :malli.core/invalid))))

(defn cat-transformer
  ([] (fn [_ _ coll* pos coll k] (k coll* pos coll)))
  ([?kr & ?krs]
   (reduce (fn [acc ?kr]
             (let [r (entry->regex ?kr)]
               (fn [driver regs coll* pos coll k]
                 (acc driver regs coll* pos coll (fn [coll* pos coll] (r driver regs coll* pos coll k))))))
           (entry->regex ?kr) ?krs)))

;;;; ## Alternation

(defn alt-validator [?kr & ?krs]
  (reduce (fn [r ?kr]
            (let [r* (entry->regex ?kr)]
              (fn [driver regs pos coll k]
                (park-validator! driver r* regs pos coll k) ; remember fallback
                (park-validator! driver r regs pos coll k))))
          (entry->regex ?kr) ?krs))

(defn alt-explainer [?kr & ?krs]
  (reduce (fn [r ?kr]
            (let [r* (entry->regex ?kr)]
              (fn [driver regs pos coll k]
                (park-explainer! driver r* regs pos coll k) ; remember fallback
                (park-explainer! driver r regs pos coll k))))
          (entry->regex ?kr) ?krs))

(defn alt-parser [& rs]
  (reduce (fn [r r*]
            (fn [driver regs pos coll k]
              (park-validator! driver r* regs pos coll k) ; remember fallback
              (park-validator! driver r regs pos coll k)))
          rs))

(defn altn-parser [kr & krs]
  (reduce (fn [r [tag r*]]
            (let [r* (fmap-parser (fn [v] (miu/-tagged tag v)) r*)]
              (fn [driver regs pos coll k]
                (park-validator! driver r* regs pos coll k) ; remember fallback
                (park-validator! driver r regs pos coll k))))
          (let [[tag r] kr]
            (fmap-parser (fn [v] (miu/-tagged tag v)) r))
          krs))

(defn alt-unparser [& unparsers]
  (fn [x]
    (reduce (fn [_ unparse] (miu/-map-valid reduced (unparse x)))
            :malli.core/invalid unparsers)))

(defn altn-unparser [& unparsers]
  (let [unparsers (into {} unparsers)]
    (fn [x]
      (if (miu/-tagged? x)
        (if-some [kv (find unparsers (key x))]
          ((val kv) (val x))
          :malli.core/invalid)
        :malli.core/invalid))))

(defn alt-transformer [?kr & ?krs]
  (reduce (fn [r ?kr]
            (let [r* (entry->regex ?kr)]
              (fn [driver regs coll* pos coll k]
                (park-transformer! driver r* regs coll* pos coll k) ; remember fallback
                (park-transformer! driver r regs coll* pos coll k))))
          (entry->regex ?kr) ?krs))

;;;; ## Option

(defn ?-validator [p] (alt-validator p (cat-validator)))
(defn ?-explainer [p] (alt-explainer p (cat-explainer)))
(defn ?-parser [p] (alt-parser p (pure-parser nil)))
(defn ?-unparser [p] (alt-unparser p pure-unparser))
(defn ?-transformer [p] (alt-transformer p (cat-transformer)))

;;;; ## Kleene Star

(defn *-validator [p]
  (let [*p-epsilon (cat-validator)]
    (fn *p [driver regs pos coll k]
      (park-validator! driver *p-epsilon regs pos coll k) ; remember fallback
      (p driver regs pos coll (fn [pos coll] (park-validator! driver *p regs pos coll k)))))) ; TCO

(defn *-explainer [p]
  (let [*p-epsilon (cat-explainer)]
    (fn *p [driver regs pos coll k]
      (park-explainer! driver *p-epsilon regs pos coll k) ; remember fallback
      (p driver regs pos coll (fn [pos coll] (park-explainer! driver *p regs pos coll k)))))) ; TCO

(defn *-parser [p]
  (let [*p-epsilon (fn [_ _ coll* pos coll k] (k coll* pos coll))] ; TCO
    (fn *p
      ([driver regs pos coll k] (*p driver regs [] pos coll k))
      ([driver regs coll* pos coll k]
       (park-transformer! driver *p-epsilon regs coll* pos coll k) ; remember fallback
       (p driver regs pos coll
          (fn [v pos coll] (park-transformer! driver *p regs (conj coll* v) pos coll k))))))) ; TCO

(defn *-unparser [up]
  (fn [v]
    (reduce (fn [acc v]
              (let [result (up v)]
                (if (miu/-invalid? result)
                  (reduced result)
                  (into acc result))))
            [] v)))

(defn *-transformer [p]
  (let [*p-epsilon (cat-transformer)]
    (fn *p [driver regs coll* pos coll k]
      (park-transformer! driver *p-epsilon regs coll* pos coll k) ; remember fallback
      (p driver regs coll* pos coll
         (fn [coll* pos coll] (park-transformer! driver *p regs coll* pos coll k)))))) ; TCO

;;;; ## Non-Kleene Plus

(defn +-validator [p] (cat-validator p (*-validator p)))
(defn +-explainer [p] (cat-explainer p (*-explainer p)))
(defn +-parser [p] (fmap-parser (fn [[v vs]] (into [v] vs)) (cat-parser p (*-parser p))))

(defn +-unparser [up]
  (let [up* (*-unparser up)]
    (fn [x]
      (if (and (vector? x) (<= 1 (count x)))
        (up* x)
        :malli.core/invalid))))

(defn +-transformer [p] (cat-transformer p (*-transformer p)))

;;;; ## Repeat

(defn repeat-validator [min max p]
  (let [rep-epsilon (cat-validator)]
    (letfn [(compulsories [driver regs pos coll k]
              (if (< (peek regs) min)
                (p driver regs pos coll
                   (fn [pos coll]
                     (noncaching-park-validator! driver
                                                 (fn [driver stack pos coll k]
                                                   (compulsories driver (conj (pop stack) (inc (peek stack))) pos coll k))
                                                 regs pos coll k))) ; TCO
                (optionals driver regs pos coll k)))
            (optionals [driver regs pos coll k]
              (if (< (peek regs) max)
                (do
                  (park-validator! driver rep-epsilon regs pos coll k) ; remember fallback
                  (p driver regs pos coll
                     (fn [pos coll]
                       (noncaching-park-validator! driver
                                                   (fn [driver regs pos coll k]
                                                     (optionals driver (conj (pop regs) (inc (peek regs))) pos coll k))
                                                   regs pos coll k)))) ; TCO
                (k pos coll)))]
      (fn [driver regs pos coll k] (compulsories driver (conj regs 0) pos coll k)))))

(defn repeat-explainer [min max p]
  (let [rep-epsilon (cat-explainer)]
    (letfn [(compulsories [driver regs pos coll k]
              (if (< (peek regs) min)
                (p driver regs pos coll
                   (fn [pos coll]
                     (noncaching-park-explainer! driver
                                                 (fn [driver regs pos coll k]
                                                   (compulsories driver (conj (pop regs) (inc (peek regs))) pos coll k))
                                                 regs pos coll k))) ; TCO
                (optionals driver regs pos coll k)))
            (optionals [driver regs pos coll k]
              (if (< (peek regs) max)
                (do
                  (park-explainer! driver rep-epsilon regs pos coll k) ; remember fallback
                  (p driver regs pos coll
                     (fn [pos coll]
                       (noncaching-park-explainer! driver
                                                   (fn [driver regs pos coll k]
                                                     (optionals driver (conj (pop regs) (inc (peek regs))) pos coll k))
                                                   regs pos coll k)))) ; TCO
                (k pos coll)))]
      (fn [driver regs pos coll k] (compulsories driver (conj regs 0) pos coll k)))))

(defn repeat-parser [min max p]
  (let [rep-epsilon (fn [_ _ coll* pos coll k] (k coll* pos coll))]
    (letfn [(compulsories [driver regs coll* pos coll k]
              (if (< (peek regs) min)
                (p driver regs pos coll
                   (fn [v pos coll]
                     (noncaching-park-transformer! driver
                                                   (fn [driver regs coll* pos coll k]
                                                     (compulsories driver (conj (pop regs) (inc (peek regs))) (conj coll* v) pos coll k))
                                                   regs coll* pos coll k))) ; TCO
                (optionals driver regs coll* pos coll k)))
            (optionals [driver regs coll* pos coll k]
              (if (< (peek regs) max)
                (do
                  (park-transformer! driver rep-epsilon regs coll* pos coll k) ; remember fallback
                  (p driver regs pos coll
                     (fn [v pos coll]
                       (noncaching-park-transformer!
                        driver
                        (fn [driver regs coll* pos coll k]
                          (optionals driver (conj (pop regs) (inc (peek regs))) (conj coll* v) pos coll k))
                        regs coll* pos coll k)))) ; TCO
                (k coll* pos coll)))]
      (fn [driver regs pos coll k] (compulsories driver (conj regs 0) [] pos coll k)))))

(defn repeat-unparser [min max up]
  (let [up* (*-unparser up)]
    (fn [v]
      (if (and (vector? v) (<= min (count v) max))
        (up* v)
        :malli.core/invalid))))

(defn repeat-transformer [min max p]
  (let [rep-epsilon (cat-transformer)]
    (letfn [(compulsories [driver regs coll* pos coll k]
              (if (< (peek regs) min)
                (p driver regs coll* pos coll
                   (fn [coll* pos coll]
                     (noncaching-park-transformer! driver
                                                   (fn [driver regs coll* pos coll k]
                                                     (compulsories driver (conj (pop regs) (inc (peek regs))) coll* pos coll k))
                                                   regs coll* pos coll k))) ; TCO
                (optionals driver regs coll* pos coll k)))
            (optionals [driver regs coll* pos coll k]
              (if (< (peek regs) max)
                (do
                  (park-transformer! driver rep-epsilon regs coll* pos coll k) ; remember fallback
                  (p driver regs coll* pos coll
                     (fn [coll* pos coll]
                       (noncaching-park-transformer! driver
                                                     (fn [driver regs coll* pos coll k]
                                                       (optionals driver (conj (pop regs) (inc (peek regs))) coll* pos coll k))
                                                     regs coll* pos coll k)))) ; TCO
                (k coll* pos coll)))]
      (fn [driver regs coll* pos coll k] (compulsories driver (conj regs 0) coll* pos coll k)))))

;;;; # Shared Drivers

(defn- make-stack [] #?(:clj (ArrayDeque.), :cljs #js []))

(defn- empty-stack? [^ArrayDeque stack] #?(:clj (.isEmpty stack), :cljs (zero? (alength stack))))

(defprotocol ^:private ICache
  (ensure-cached! [cache f pos regs]))

(deftype ^:private CacheEntry [^long hash f ^long pos regs])

#?(:clj (set! *unchecked-math* true))

;; Custom hash set so that Cljs Malli users can have decent perf without having to to set up Closure ES6 Set polyfill.
;; Uses quadratic probing with power-of-two sizes and triangular numbers, what a nice trick!
(deftype Cache
  #?(:clj  [^:unsynchronized-mutable ^"[Ljava.lang.Object;" values, ^:unsynchronized-mutable ^long size]
     :cljs [^:mutable values, ^:mutable size])
  ICache
  (ensure-cached! [_ f pos regs]
    (when (> (unchecked-inc size) (bit-shift-right (alength values) 1)) ; potential new load factor > 0.5
      ;; Rehash:
      (let [capacity* (bit-shift-left (alength values) 1)
            ^objects values* #?(:bb   (object-array capacity*)
                                :clj (Array/newInstance Object capacity*)
                                :cljs (object-array capacity*))
            max-index (unchecked-dec capacity*)]

        (let [len (alength values)]
          (loop [i 0]
            (when (< i len)
              (when-some [^CacheEntry v (aget values i)]
                (loop [i* (bit-and (.-hash v) max-index)
                       collisions 0]
                  (if (aget values* i*)
                    (let [collisions (unchecked-inc collisions)]
                      (recur
                       (bit-and (unchecked-add i* collisions) max-index)
                       collisions))
                    (aset values* i* v))))
              (recur (unchecked-inc i)))))

        (set! values values*)))

    (let [capacity (alength values)
          max-index (unchecked-dec capacity)
          #?@(:clj [pos (.longValue ^Long pos)])
          ;; Unfortunately `hash-combine` hashes its second argument on clj and neither argument on cljs:
          h #?(:bb   (-> (hash f) (hash-combine pos) (hash-combine regs))
               :clj (-> (.hashCode ^Object f) (Util/hashCombine (Murmur3/hashLong pos)) (Util/hashCombine (Util/hash regs)))
               :cljs (-> (hash f) (hash-combine (hash pos)) (hash-combine (hash regs))))]
      (loop [i (bit-and h max-index), collisions 0]
        (if-some [^CacheEntry entry (aget values i)]
          (or (and (= (.-hash entry) h)
                   (= (.-f entry) f)
                   (= (.-pos entry) pos)
                   (= (.-regs entry) regs))
              (let [collisions (unchecked-inc collisions)]
                (recur (bit-and (unchecked-add i collisions) max-index) ; i = (i + collisions) % capacity
                       collisions)))
          (do
            (aset values i (CacheEntry. h f pos regs))
            (set! size (unchecked-inc size))
            false))))))

(defn- make-cache [] (Cache. (object-array 2) 0))

#?(:clj (set! *unchecked-math* false))

(deftype ^:private CheckDriver
  #?(:clj  [^:unsynchronized-mutable ^boolean success, ^ArrayDeque stack, cache]
     :cljs [^:mutable success, stack, cache])

  Driver
  (succeed! [_] (set! success (boolean true)))
  (succeeded? [_] success)
  (pop-thunk! [_] (when-not (empty-stack? stack) (.pop stack)))

  IValidationDriver
  (noncaching-park-validator! [self validator regs pos coll k] (.push stack #(validator self regs pos coll k)))
  (park-validator! [self validator regs pos coll k]
    (when-not (ensure-cached! cache validator pos regs)
      (noncaching-park-validator! self validator regs pos coll k))))

(deftype ^:private ParseDriver
  #?(:clj  [^:unsynchronized-mutable ^boolean success, ^ArrayDeque stack, cache
            ^:unsynchronized-mutable result]
     :cljs [^:mutable success, stack, cache, ^:mutable result])

  Driver
  (succeed! [_] (set! success (boolean true)))
  (succeeded? [_] success)
  (pop-thunk! [_] (when-not (empty-stack? stack) (.pop stack)))

  IValidationDriver
  (noncaching-park-validator! [self validator regs pos coll k] (.push stack #(validator self regs pos coll k)))
  (park-validator! [self validator regs pos coll k]
    (when-not (ensure-cached! cache validator pos regs)
      (noncaching-park-validator! self validator regs pos coll k)))

  IParseDriver
  (noncaching-park-transformer! [driver transformer regs coll* pos coll k]
    (.push stack #(transformer driver regs coll* pos coll k)))
  (park-transformer! [driver transformer regs coll* pos coll k]
    (when-not (ensure-cached! cache transformer pos regs)
      (noncaching-park-transformer! driver transformer regs coll* pos coll k)))
  (succeed-with! [self v] (succeed! self) (set! result v))
  (success-result [_] result))

;;;; # Validator

(defn validator [p]
  (let [p (cat-validator p (end-validator))]
    (fn [coll]
      (and (sequential? coll)
           (let [driver (CheckDriver. false (make-stack) (make-cache))]
             (p driver () 0 coll (fn [_ _] (succeed! driver)))
             (or (succeeded? driver)
                 (loop []
                   (if-some [thunk (pop-thunk! driver)]
                     (do
                       (thunk)
                       (or (succeeded? driver) (recur)))
                     false))))))))

;;;; # Explainer

(deftype ^:private ExplanationDriver
  #?(:clj  [^:unsynchronized-mutable ^boolean success, ^ArrayDeque stack, cache
            in, ^:unsynchronized-mutable errors-max-pos, ^:unsynchronized-mutable errors]
     :cljs [^:mutable success, stack, cache, in, ^:mutable errors-max-pos, ^:mutable errors])

  Driver
  (succeed! [_] (set! success (boolean true)))
  (succeeded? [_] success)
  (pop-thunk! [_] (when-not (empty-stack? stack) (.pop stack)))

  IExplanationDriver
  (noncaching-park-explainer! [self validator regs pos coll k] (.push stack #(validator self regs pos coll k)))
  (park-explainer! [self validator regs pos coll k]
    (when-not (ensure-cached! cache validator pos regs)
      (noncaching-park-explainer! self validator regs pos coll k)))
  (value-path [_ pos] (conj in pos))
  (fail! [_ pos errors*]
    (cond
      (> pos errors-max-pos) (do
                               (set! errors-max-pos pos)
                               (set! errors errors*))
      (= pos errors-max-pos) (set! errors (into errors errors*))))
  (latest-errors [_] errors))

(defn explainer [schema path p]
  (let [p (cat-explainer p (end-explainer schema path))]
    (fn [coll in errors]
      (if (sequential? coll)
        (let [pos 0
              driver (ExplanationDriver. false (make-stack) (make-cache) in pos [])]
          (p driver () pos coll (fn [_ _] (succeed! driver)))
          (if (succeeded? driver)
            errors
            (loop []
              (if-some [thunk (pop-thunk! driver)]
                (do
                  (thunk)
                  (if (succeeded? driver) errors (recur)))
                (into errors (latest-errors driver))))))
        (conj errors (miu/-error path in schema coll :malli.core/invalid-type))))))

;;;; # Parser

(defn parser [p]
  (let [p (cat-parser p (end-parser))]
    (fn [coll]
      (if (sequential? coll)
        (let [driver (ParseDriver. false (make-stack) (make-cache) nil)]
          (p driver () 0 coll (fn [v _ _] (succeed-with! driver v)))
          (if (succeeded? driver)
            (first (success-result driver))
            (loop []
              (if-some [thunk (pop-thunk! driver)]
                (do
                  (thunk)
                  (if (succeeded? driver) (first (success-result driver)) (recur)))
                :malli.core/invalid))))
        :malli.core/invalid))))

;;;; # Transformer

(defn transformer [p]
  (let [p (cat-transformer p (end-transformer))]
    (fn [coll]
      (if (sequential? coll)
        (let [driver (ParseDriver. false (make-stack) (make-cache) nil)]
          (p driver () [] 0 coll (fn [coll* _ _] (succeed-with! driver coll*)))
          (if (succeeded? driver)
            (success-result driver)
            (loop []
              (if-some [thunk (pop-thunk! driver)]
                (do
                  (thunk)
                  (if (succeeded? driver) (success-result driver) (recur)))
                coll))))
        coll))))
(ns malli.core
  (:refer-clojure :exclude [eval type -deref deref -lookup -key])
  #?(:cljs (:require-macros malli.core))
  (:require #?(:clj [clojure.walk :as walk])
            [clojure.core :as c]
            [malli.impl.regex :as re]
            [malli.impl.util :as miu]
            [malli.registry :as mr]
            [malli.sci :as ms])
  #?(:clj (:import #?(:bb  (clojure.lang Associative IPersistentCollection MapEntry IPersistentVector PersistentArrayMap)
                      :clj (clojure.lang Associative IPersistentCollection MapEntry IPersistentVector LazilyPersistentVector PersistentArrayMap))
                   (java.util.concurrent.atomic AtomicReference)
                   (java.util.regex Pattern))))

(declare schema schema? into-schema into-schema? type eval default-registry
         -simple-schema -val-schema -ref-schema -schema-schema -registry
         parser unparser ast from-ast)

;;
;; protocols and records
;;

(defprotocol IntoSchema
  (-type [this] "returns type of the schema")
  (-type-properties [this] "returns schema type properties")
  (-properties-schema [this options] "maybe returns :map schema describing schema properties")
  (-children-schema [this options] "maybe returns sequence schema describing schema children")
  (-into-schema [this properties children options] "creates a new schema instance"))

(defprotocol Schema
  (-validator [this] "returns a predicate function that checks if the schema is valid")
  (-explainer [this path] "returns a function of `x in acc -> maybe errors` to explain the errors for invalid values")
  (-parser [this] "return a function of `x -> parsed-x | ::m/invalid` to explain how schema is valid.")
  (-unparser [this] "return the inverse (partial) function wrt. `-parser`; `parsed-x -> x | ::m/invalid`")
  (-transformer [this transformer method options]
    "returns a function to transform the value for the given schema and method.
    Can also return nil instead of `identity` so that more no-op transforms can be elided.")
  (-walk [this walker path options] "walks the schema and it's children, ::m/walk-entry-vals, ::m/walk-refs, ::m/walk-schema-refs options effect how walking is done.")
  (-properties [this] "returns original schema properties")
  (-options [this] "returns original options")
  (-children [this] "returns schema children")
  (-parent [this] "returns the IntoSchema instance")
  (-form [this] "returns original form of the schema"))

(defprotocol AST
  (-to-ast [this options] "schema to ast")
  (-from-ast [this ast options] "ast to schema"))

(defprotocol EntryParser
  (-entry-keyset [this])
  (-entry-children [this])
  (-entry-entries [this])
  (-entry-forms [this]))

(defprotocol EntrySchema
  (-entries [this] "returns sequence of `key -val-schema` entries")
  (-entry-parser [this]))

(defprotocol Cached
  (-cache [this]))

(defprotocol LensSchema
  (-keep [this] "returns truthy if schema contributes to value path")
  (-get [this key default] "returns schema at key")
  (-set [this key value] "returns a copy with key having new value"))

(defprotocol RefSchema
  (-ref [this] "returns the reference name")
  (-deref [this] "returns the referenced schema"))

(defprotocol Walker
  (-accept [this schema path options])
  (-inner [this schema path options])
  (-outer [this schema path children options]))

(defprotocol Transformer
  (-transformer-chain [this] "returns transformer chain as a vector of maps with :name, :encoders, :decoders and :options")
  (-value-transformer [this schema method options] "returns a value transforming interceptor for the given schema and method"))

(defprotocol RegexSchema
  (-regex-op? [this] "is this a regex operator (e.g. :cat, :*...)")
  (-regex-validator [this] "returns the raw internal regex validator implementation")
  (-regex-explainer [this path] "returns the raw internal regex explainer implementation")
  (-regex-unparser [this] "returns the raw internal regex unparser implementation")
  (-regex-parser [this] "returns the raw internal regex parser implementation")
  (-regex-transformer [this transformer method options] "returns the raw internal regex transformer implementation")
  (-regex-min-max [this nested?] "returns size of the sequence as {:min min :max max}. nil max means unbounded. nested? is true when this schema is nested inside an outer regex schema."))

(defn -ref-schema? [x] (#?(:clj instance?, :cljs implements?) malli.core.RefSchema x))
(defn -entry-parser? [x] (#?(:clj instance?, :cljs implements?) malli.core.EntryParser x))
(defn -entry-schema? [x] (#?(:clj instance?, :cljs implements?) malli.core.EntrySchema x))
(defn -cached? [x] (#?(:clj instance?, :cljs implements?) malli.core.Cached x))
(defn -ast? [x] (#?(:clj instance?, :cljs implements?) malli.core.AST x))
(defn -transformer? [x] (#?(:clj instance?, :cljs implements?) malli.core.Transformer x))

(extend-type #?(:clj Object, :cljs default)
  RegexSchema
  (-regex-op? [_] false)

  (-regex-validator [this]
    (if (-ref-schema? this)
      (-regex-validator (-deref this))
      (re/item-validator (-validator this))))

  (-regex-explainer [this path]
    (if (-ref-schema? this)
      (-regex-explainer (-deref this) path)
      (re/item-explainer path this (-explainer this path))))

  (-regex-parser [this]
    (if (-ref-schema? this)
      (-regex-parser (-deref this))
      (re/item-parser (parser this))))

  (-regex-unparser [this]
    (if (-ref-schema? this)
      (-regex-unparser (-deref this))
      (re/item-unparser (unparser this))))

  (-regex-transformer [this transformer method options]
    (if (-ref-schema? this)
      (-regex-transformer (-deref this) transformer method options)
      (re/item-transformer method (-validator this) (or (-transformer this transformer method options) identity))))

  (-regex-min-max [_ _] {:min 1, :max 1}))

#?(:clj (defmethod print-method ::into-schema [v ^java.io.Writer w] (.write w (str "#IntoSchema{:type " (pr-str (-type ^IntoSchema v)) "}"))))
#?(:clj (defmethod print-method ::schema [v ^java.io.Writer w] (.write w (pr-str (-form ^Schema v)))))

;;
;; impl
;;

(defn -deprecated! [x] (println "DEPRECATED:" x))

(defn -exception
  ([type] (-exception type nil))
  ([type data] (ex-info (str type) {:type type, :message type, :data data})))

(defn -fail!
  ([type] (-fail! type nil))
  ([type data] (throw (-exception type data))))

(defn -safe-pred [f] #(try (boolean (f %)) (catch #?(:clj Exception, :cljs js/Error) _ false)))

(defn -keyword->string [x]
  (if (keyword? x)
    (if-let [nn (namespace x)]
      (str nn "/" (name x))
      (name x))
    x))

(defn -guard [pred tf] (when tf (fn [x] (if (pred x) (tf x) x))))

(defn -unlift-keys [m prefix]
  (reduce-kv #(if (= (name prefix) (namespace %2)) (assoc %1 (keyword (name %2)) %3) %1) {} m))

(defn ^:no-doc -check-children? [] true)

(defn -check-children!
  ([type properties children props]
   (-deprecated! "use (m/-check-children! type properties children min max) instead.")
   (-check-children! type properties children (:min props) (:max props)))
  ([type properties children min max]
   (when (-check-children?)
     (when-let [size (and (or (sequential? children) (nil? children)) (count children))]
       (when (or (and min (< size ^long min)) (and max (> size ^long max)))
         (-fail! ::child-error {:type type, :properties properties, :children children, :min min, :max max}))))))

(defn -pointer [id schema options] (-into-schema (-schema-schema {:id id}) nil [schema] options))

(defn -reference? [?schema] (or (string? ?schema) (qualified-keyword? ?schema)))

(defn -lazy [ref options] (-into-schema (-ref-schema {:lazy true}) nil [ref] options))

(defn -boolean-fn [x] (cond (boolean? x) (constantly x) (ifn? x) x :else (constantly false)))

(defn -infer [children]
  (loop [[[s f] & fs] [[:string string?] [:keyword keyword?] [:symbol symbol?] [:int int?] [:double float?]]]
    (if (every? f children) s (when fs (recur fs)))))

(defn -comp
  ([] identity)
  ([f] f)
  ([f g] (fn [x] (f (g x))))
  ([f g h] (fn [x] (f (g (h x)))))
  #?@(:clj  [([f1 f2 f3 f4] (fn [x] (-> x f4 f3 f2 f1)))
             ([f1 f2 f3 f4 f5] (fn [x] (-> x f5 f4 f3 f2 f1)))
             ([f1 f2 f3 f4 f5 f6] (fn [x] (-> x f6 f5 f4 f3 f2 f1)))
             ([f1 f2 f3 f4 f5 f6 f7] (fn [x] (-> x f7 f6 f5 f4 f3 f2 f1)))
             ([f1 f2 f3 f4 f5 f6 f7 f8] (fn [x] (-> x f8 f7 f6 f5 f4 f3 f2 f1)))
             ([f1 f2 f3 f4 f5 f6 f7 f8 & fs] (let [f9 (apply -comp fs)]
                                               (fn [x] (-> x f9 f8 f7 f6 f5 f4 f3 f2 f1))))]
      :cljs [([f1 f2 f3 & fs] (let [f4 (apply -comp fs)]
                                (fn [x] (-> x f4 f3 f2 f1))))]))

(defn -update [x k f] (assoc x k (f (get x k))))

(defn -equals [x y] (or (identical? x y) (= x y)))

(defn -vmap ([os] (miu/-vmap identity os)) ([f os] (miu/-vmap f os)))

(defn -memoize [f]
  (let [value #?(:clj (AtomicReference. nil), :cljs (atom nil))]
    (fn [] #?(:clj (or (.get value) (do (.set value (f)) (.get value))), :cljs (or @value (reset! value (f)))))))

(defn -function-info [schema]
  (when (= (type schema) :=>)
    (let [[input output] (-children schema)
          {:keys [min max]} (-regex-min-max input false)]
      (cond-> {:min min
               :arity (if (= min max) min :varargs)
               :input input
               :output output}
        max (assoc :max max)))))

(defn -group-by-arity! [infos]
  (let [aritys (atom #{})]
    (reduce
     (fn [acc {:keys [min arity] :as info}]
       (let [vararg (= :varargs arity)
             min (if (and vararg (@aritys min)) (inc (apply max (filter int? @aritys))) min)]
         (cond (and vararg (@aritys arity))
               (-fail! ::multiple-varargs {:infos infos})

               (@aritys min)
               (-fail! ::duplicate-arities {:infos infos})

               :else
               (do (swap! aritys conj arity)
                   (assoc acc arity (assoc info :min min)))))) {} infos)))

(defn- -re-min-max [f {min' :min, max' :max} child]
  (let [{min'' :min max'' :max} (-regex-min-max child true)]
    (cond-> {:min (f (or min' 0) min'')} (and max' max'') (assoc :max (f max' max'')))))

(defn- -re-alt-min-max [{min' :min, max' :max} child]
  (let [{min'' :min max'' :max} (-regex-min-max child true)]
    (cond-> {:min (min (or min' miu/+max-size+) min'')} (and max' max'') (assoc :max (max max' max'')))))

;;
;; registry
;;

(defn- -register-var [registry ?v]
  (let [[v pred] (if (vector? ?v) ?v [?v @?v])
        name (-> v meta :name)
        schema (-simple-schema {:type name, :pred pred})]
    (-> registry
        (assoc name schema)
        (assoc @v schema))))

(defn -registry {:arglists '([] [{:keys [registry]}])}
  ([] default-registry)
  ([opts] (or (when opts (mr/registry (opts :registry))) default-registry)))

(defn -property-registry [m options f]
  (let [options (assoc options ::allow-invalid-refs true)]
    (reduce-kv (fn [acc k v] (assoc acc k (f (schema v options)))) {} m)))

(defn -delayed-registry [m f]
  (reduce-kv (fn [acc k v] (assoc acc k (reify IntoSchema (-into-schema [_ _ _ options] (f v options))))) {} m))

(defn- -lookup [?schema options]
  (let [registry (-registry options)]
    (or (mr/-schema registry ?schema)
        (some-> registry (mr/-schema (c/type ?schema)) (-into-schema nil [?schema] options)))))

(defn- -lookup! [?schema f rec options]
  (or (and f (f ?schema) ?schema)
      (if-let [?schema (-lookup ?schema options)]
        (cond-> ?schema rec (recur f rec options))
        (-fail! ::invalid-schema {:schema ?schema}))))

(defn -properties-and-options [properties options f]
  (if-let [r (:registry properties)]
    (let [options (-update options :registry #(mr/composite-registry r (or % (-registry options))))]
      [(assoc properties :registry (-property-registry r options f)) options])
    [properties options]))

;;
;; cache
;;

(defn -create-cache [_options] (atom {}))

(defn -cached [s k f]
  (if (-cached? s)
    (let [c (-cache s)]
      (or (@c k) ((swap! c assoc k (f s)) k)))
    (f s)))

;;
;; forms
;;

(defn -create-form [type properties children options]
  (let [has-children (seq children)
        has-properties (seq properties)
        properties (when has-properties
                     (let [registry (:registry properties)]
                       (cond-> properties registry (assoc :registry (-property-registry registry options -form)))))]
    (cond (and has-properties has-children) (reduce conj [type properties] children)
          has-properties [type properties]
          has-children (reduce conj [type] children)
          :else type)))

(defn -simple-form [parent properties children f options]
  (-create-form (-type parent) properties (-vmap f children) options))

(defn -create-entry-form [parent properties entry-parser options]
  (-create-form (-type parent) properties (-entry-forms entry-parser) options))

;;
;; walkers
;;

(defn -inner-indexed [walker path children options]
  (-vmap (fn [[i c]] (-inner walker c (conj path i) options)) (map-indexed vector children)))

(defn -inner-entries [walker path entries options]
  (-vmap (fn [[k s]] [k (-properties s) (-inner walker s (conj path k) options)]) entries))

(defn -walk-entries [schema walker path options]
  (when (-accept walker schema path options)
    (-outer walker schema path (-inner-entries walker path (-entries schema) options) options)))

(defn -walk-indexed [schema walker path options]
  (when (-accept walker schema path options)
    (-outer walker schema path (-inner-indexed walker path (-children schema) options) options)))

(defn -walk-leaf [schema walker path options]
  (when (-accept walker schema path options)
    (-outer walker schema path (-children schema) options)))

;;
;; lenses
;;

(defn -set-children [schema children]
  (if (-equals children (-children schema))
    schema (-into-schema (-parent schema) (-properties schema) children (-options schema))))

(defn -set-properties [schema properties]
  (if (-equals properties (-properties schema))
    schema (-into-schema (-parent schema) properties (or (and (-entry-schema? schema) (-entry-parser schema)) (-children schema)) (-options schema))))

(defn -update-options [schema f]
  (-into-schema (-parent schema) (-properties schema) (-children schema) (f (-options schema))))

(defn -set-assoc-children [schema key value]
  (-set-children schema (assoc (-children schema) key value)))

(defn -get-entries [schema key default]
  (or (some (if (and (vector? key) (= ::find (nth key 0)))
              (fn [e] (when (= (nth e 0) (nth key 1)) e))
              (fn [e] (when (= (nth e 0) key) (nth e 2))))
            (-children schema)) default))

;;
;; entries
;;

(defn -simple-entry-parser [keyset children forms]
  (let [entries (map (fn [[k p s]] (miu/-tagged k (-val-schema s p))) children)]
    (reify EntryParser
      (-entry-keyset [_] keyset)
      (-entry-children [_] children)
      (-entry-entries [_] entries)
      (-entry-forms [_] forms))))

(defn- -update-parsed [entry-parser ?key value options]
  (let [[override k p] (if (and (vector? ?key) (nth ?key 0)) (cons true ?key) [false ?key])
        keyset (-entry-keyset entry-parser)
        children (-entry-children entry-parser)
        forms (-entry-forms entry-parser)
        s (when value (schema value options))
        i (:order (keyset k))]
    (if (nil? s)
      ;; remove
      (letfn [(cut [v] (into (subvec v 0 i) (subvec v (inc i))))]
        (-simple-entry-parser (dissoc keyset k) (cut children) (cut forms)))
      (let [p (if i (if override p (nth (children i) 1)) p)
            c [k p s]
            f (if (seq p) [k p (-form s)] [k (-form s)])]
        (if i
          ;; update
          (-simple-entry-parser keyset (assoc children i c) (assoc forms i f))
          ;; assoc
          (-simple-entry-parser (assoc keyset k {:order (count keyset)}) (conj children c) (conj forms f)))))))

(defn -set-entries
  ([schema ?key value]
   (if-let [entry-parser (-entry-parser schema)]
     (-set-children schema (-update-parsed entry-parser ?key value (-options schema)))
     (let [found (atom nil)
           [key props override] (if (vector? ?key) [(nth ?key 0) (second ?key) true] [?key])
           children (cond-> (-vmap (fn [[k p :as entry]]
                                     (if (= key k)
                                       (do (reset! found true) [key (if override props p) value])
                                       entry))
                                   (-children schema))
                      (not @found) (conj (if key [key props value] (-fail! ::key-missing)))
                      :always (->> (filter (fn [e] (-> e last some?)))))]
       (-set-children schema children)))))

(defn- -parse-entry [e naked-keys lazy-refs options i ^objects -children ^objects -forms ^objects -keyset]
  (letfn [(-collect [k c f i]
            (let [i (int i)]
              (aset -keyset (* 2 i) k)
              (aset -keyset (inc (* 2 i)) {:order i})
              (aset -children i c)
              (aset -forms i f)
              (unchecked-inc-int i)))
          (-schema [e] (schema (cond-> e (and (-reference? e) lazy-refs) (-lazy options)) options))
          (-parse-ref-entry [e]
            (let [s (-schema e)
                  c [e nil s]]
              (-collect e c e i)))
          (-parse-ref-vector1 [e e0]
            (let [s (-schema e0)
                  c [e0 nil s]]
              (-collect e0 c e i)))
          (-parse-ref-vector2 [e e0 e1]
            (let [s (-schema e0)
                  c [e0 e1 s]]
              (-collect e0 c e i)))
          (-parse-entry-else2 [e0 e1]
            (let [s (-schema e1)
                  f [e0 (-form s)]
                  c [e0 nil s]]
              (-collect e0 c f i)))
          (-parse-entry-else3 [e0 e1 e2]
            (let [s (-schema e2)
                  f' (-form s)
                  f (if e1 [e0 e1 f'] [e0 f'])
                  c [e0 e1 s]]
              (-collect e0 c f i)))]
    (if (vector? e)
      (let [ea (object-array e)
            n (alength ea)
            e0 (aget ea 0)]
        (if (== n 1)
          (if (and (-reference? e0) naked-keys)
            (-parse-ref-vector1 e e0)
            (-fail! ::invalid-children {:children -children}))
          (let [e1 (aget ea 1)]
            (if (== n 2)
              (if (and (-reference? e0) (map? e1))
                (if naked-keys (-parse-ref-vector2 e e0 e1) i)
                (-parse-entry-else2 e0 e1))
              (let [e2 (aget ea 2)]
                (-parse-entry-else3 e0 e1 e2))))))
      (if (and naked-keys (-reference? e))
        (-parse-ref-entry e)
        (-fail! ::invalid-ref {:ref e})))))

(defn -eager-entry-parser [children props options]
  (letfn [(-vec [^objects arr] #?(:bb (vec arr) :clj (LazilyPersistentVector/createOwning arr), :cljs (vec arr)))
          (-map [^objects arr] #?(:bb   (let [m (apply array-map arr)]
                                          (when-not (= (* 2 (count m)) (count arr))
                                            (-fail! ::duplicate-keys)) m)
                                  :clj (PersistentArrayMap/createWithCheck arr)
                                  :cljs (let [m (apply array-map arr)]
                                          (when-not (= (* 2 (count m)) (count arr))
                                            (-fail! ::duplicate-keys)) m)))
          (-arange [^objects arr to]
           #?(:clj (let [-arr (object-array to)] (System/arraycopy arr 0 -arr 0 to) -arr)
              :cljs (.slice arr 0 to)))]
    (let [{:keys [naked-keys lazy-refs]} props
          ca (object-array children)
          n (alength ca)
          -children (object-array n)
          -forms (object-array n)
          -keyset (object-array (* 2 n))]
      (loop [i (int 0), ci (int 0)]
        (if (== ci n)
          (let [f (if (== ci i) -vec #(-vec (-arange % i)))]
            (-simple-entry-parser (-map -keyset) (f -children) (f -forms)))
          (recur (int (-parse-entry (aget ca i) naked-keys lazy-refs options i -children -forms -keyset))
                 (unchecked-inc-int ci)))))))

(defn -lazy-entry-parser [?children props options]
  (let [parser (delay (-eager-entry-parser ?children props options))]
    (reify EntryParser
      (-entry-keyset [_] (-entry-keyset @parser))
      (-entry-children [_] (-entry-children @parser))
      (-entry-entries [_] (-entry-entries @parser))
      (-entry-forms [_] (-entry-forms @parser)))))

(defn -create-entry-parser [?children props options]
  (cond (-entry-parser? ?children) ?children
        (or (:lazy props) (::lazy-entries options)) (-lazy-entry-parser ?children props options)
        :else (-eager-entry-parser ?children props options)))

(defn -default-entry [e] (-equals (nth e 0) ::default))
(defn -default-entry-schema [children] (some (fn [e] (when (-default-entry e) (nth e 2))) children))

;;
;; transformers
;;

(defn -no-op-transformer []
  (reify Transformer
    (-transformer-chain [_])
    (-value-transformer [_ _ _ _])))

(defn -intercepting
  ([interceptor] (-intercepting interceptor nil))
  ([{:keys [enter leave]} f] (some->> [leave f enter] (keep identity) (seq) (apply -comp))))

(defn -into-transformer [x]
  (cond
    (-transformer? x) x
    (fn? x) (-into-transformer (x))
    (nil? x) (-no-op-transformer)
    :else (-fail! ::invalid-transformer {:value x})))

(defn -parent-children-transformer [parent children transformer method options]
  (let [parent-transformer (-value-transformer transformer parent method options)
        child-transformers (into [] (keep #(-transformer % transformer method options)) children)
        child-transformer (when (seq child-transformers) (apply -comp (rseq child-transformers)))]
    (-intercepting parent-transformer child-transformer)))

(defn -map-transformer [ts]
  #?(:bb   (fn [x] (reduce (fn child-transformer [m [k t]]
                             (if-let [entry (find m k)]
                               (assoc m k (t (val entry)))
                               m)) x ts))
     :clj  (apply -comp (map (fn child-transformer [[k t]]
                               (fn [^Associative x]
                                 (if-let [e ^MapEntry (.entryAt x k)]
                                   (.assoc x k (t (.val e))) x))) (rseq ts)))
     :cljs (fn [x] (reduce (fn child-transformer [m [k t]]
                             (if-let [entry (find m k)]
                               (assoc m k (t (val entry)))
                               m)) x ts))))

(defn -tuple-transformer [ts] (fn [x] (reduce-kv -update x ts)))

(defn -collection-transformer [t empty]
  #?(:bb   (fn [x] (into (when x empty) (map t) x))
     :clj  (fn [x] (let [i (.iterator ^Iterable x)]
                     (loop [x ^IPersistentCollection empty]
                       (if (.hasNext i)
                         (recur (.cons x (t (.next i))))
                         x))))
     :cljs (fn [x] (into (when x empty) (map t) x))))

(defn -or-transformer [this transformer child-schemas method options]
  (let [this-transformer (-value-transformer transformer this method options)]
    (if (seq child-schemas)
      (let [transformers (-vmap #(or (-transformer % transformer method options) identity) child-schemas)
            validators (-vmap -validator child-schemas)]
        (-intercepting this-transformer
                       (if (= :decode method)
                         (fn [x]
                           (reduce-kv
                            (fn [acc i transformer]
                              (let [x* (transformer x)]
                                (if ((nth validators i) x*)
                                  (reduced x*)
                                  (if (-equals acc ::nil) x* acc))))
                            ::nil transformers))
                         (fn [x]
                           (reduce-kv
                            (fn [x i validator] (if (validator x) (reduced ((nth transformers i) x)) x))
                            x validators)))))
      (-intercepting this-transformer))))

;;
;; ast
;;

(defn -parse-entry-ast [ast options]
  (let [ast-entry-order (::ast-entry-order options)
        keyset (:keys ast)
        ->child (fn [[k v]] [k (:properties v) (from-ast (:value v) options)])
        children (delay (-vmap ->child (cond->> keyset ast-entry-order (sort-by #(:order (val %)) keyset))))]
    (reify EntryParser
      (-entry-keyset [_] keyset)
      (-entry-children [_] @children)
      (-entry-entries [_] (-vmap (fn [[k p s]] (miu/-tagged k (-val-schema s p))) @children))
      (-entry-forms [_] (->> @children (-vmap (fn [[k p v]] (if p [k p (-form v)] [k (-form v)]))))))))

(defn -from-entry-ast [parent ast options]
  (-into-schema parent (:properties ast) (-parse-entry-ast ast options) options))

(defn -ast [acc properties options]
  (let [registry (when-let [registry (:registry properties)]
                   (into {} (map (fn [[k v]] [k (ast v options)])) registry))
        properties (not-empty (cond-> properties registry (dissoc :registry)))]
    (cond-> acc properties (assoc :properties properties) registry (assoc :registry registry))))

(defn -entry-ast [schema keyset]
  (-ast {:type (type schema)
         :keys (reduce (fn [acc [k p s]] (assoc acc k (cond-> {:order (-> keyset (get k) :order),
                                                               :value (ast s)} p (assoc :properties p))))
                       {} (-children schema))}
        (-properties schema)
        (-options schema)))

(defn -from-child-ast [parent ast options]
  (-into-schema parent (:properties ast) [(from-ast (:child ast) options)] options))

(defn -to-child-ast [schema]
  (-ast {:type (type schema), :child (ast (nth (-children schema) 0))} (-properties schema) (-options schema)))

(defn -from-value-ast [parent ast options]
  (-into-schema parent (:properties ast) (when-let [value (:value ast)] [value]) options))

(defn -to-value-ast [schema]
  (-ast {:type (type schema), :value (nth (-children schema) 0)} (-properties schema) (-options schema)))

(defn -from-type-ast [parent ast options]
  (-into-schema parent (:properties ast) nil options))

(defn -to-type-ast [schema]
  (-ast {:type (type schema)} (-properties schema) (-options schema)))

;;
;; simple schema helpers
;;

(defn -min-max-pred [f]
  (fn [{:keys [min max]}]
    (cond
      (not (or min max)) nil
      (and (and min max) f) (fn [x] (let [size (f x)] (<= min size max)))
      (and min max) (fn [x] (<= min x max))
      (and min f) (fn [x] (<= min (f x)))
      min (fn [x] (<= min x))
      (and max f) (fn [x] (<= (f x) max))
      max (fn [x] (<= x max)))))

(defn -validate-limits [min max] (or ((-min-max-pred count) {:min min :max max}) (constantly true)))

(defn -qualified-keyword-pred [properties]
  (when-let [ns-name (some-> properties :namespace name)]
    (fn [x] (= (namespace x) ns-name))))

;;
;; Schemas
;;

(defn -simple-schema [props]
  (let [{:keys [type type-properties pred property-pred min max from-ast to-ast compile]
         :or {min 0, max 0, from-ast -from-value-ast, to-ast -to-type-ast}} props]
    (if (fn? props)
      (do
        (-deprecated! "-simple-schema doesn't take fn-props, use :compiled property instead")
        (-simple-schema {:compile (fn [c p _] (props c p))}))
      ^{:type ::into-schema}
      (reify
        AST
        (-from-ast [parent ast options] (from-ast parent ast options))
        IntoSchema
        (-type [_] type)
        (-type-properties [_] type-properties)
        (-properties-schema [_ _])
        (-children-schema [_ _])
        (-into-schema [parent properties children options]
          (if compile
            (-into-schema (-simple-schema (merge (dissoc props :compile) (compile properties children options))) properties children options)
            (let [form (delay (-simple-form parent properties children identity options))
                  cache (-create-cache options)]
              (-check-children! type properties children min max)
              ^{:type ::schema}
              (reify
                AST
                (-to-ast [this _] (to-ast this))
                Schema
                (-validator [_]
                  (if-let [pvalidator (when property-pred (property-pred properties))]
                    (fn [x] (and (pred x) (pvalidator x))) pred))
                (-explainer [this path]
                  (let [validator (-validator this)]
                    (fn explain [x in acc]
                      (if-not (validator x) (conj acc (miu/-error path in this x)) acc))))
                (-parser [this]
                  (let [validator (-validator this)]
                    (fn [x] (if (validator x) x ::invalid))))
                (-unparser [this] (-parser this))
                (-transformer [this transformer method options]
                  (-intercepting (-value-transformer transformer this method options)))
                (-walk [this walker path options] (-walk-leaf this walker path options))
                (-properties [_] properties)
                (-options [_] options)
                (-children [_] children)
                (-parent [_] parent)
                (-form [_] @form)
                Cached
                (-cache [_] cache)
                LensSchema
                (-keep [_])
                (-get [_ _ default] default)
                (-set [this key _] (-fail! ::non-associative-schema {:schema this, :key key}))))))))))

(defn -nil-schema [] (-simple-schema {:type :nil, :pred nil?}))
(defn -any-schema [] (-simple-schema {:type :any, :pred any?}))
(defn -some-schema [] (-simple-schema {:type :some, :pred some?}))
(defn -string-schema [] (-simple-schema {:type :string, :pred string?, :property-pred (-min-max-pred count)}))
(defn -int-schema [] (-simple-schema {:type :int, :pred int?, :property-pred (-min-max-pred nil)}))
(defn -double-schema [] (-simple-schema {:type :double, :pred double?, :property-pred (-min-max-pred nil)}))
(defn -boolean-schema [] (-simple-schema {:type :boolean, :pred boolean?}))
(defn -keyword-schema [] (-simple-schema {:type :keyword, :pred keyword?}))
(defn -symbol-schema [] (-simple-schema {:type :symbol, :pred symbol?}))
(defn -qualified-keyword-schema [] (-simple-schema {:type :qualified-keyword, :pred qualified-keyword?, :property-pred -qualified-keyword-pred}))
(defn -qualified-symbol-schema [] (-simple-schema {:type :qualified-symbol, :pred qualified-symbol?}))
(defn -uuid-schema [] (-simple-schema {:type :uuid, :pred uuid?}))

(defn -and-schema []
  ^{:type ::into-schema}
  (reify IntoSchema
    (-type [_] :and)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (-check-children! :and properties children 1 nil)
      (let [children (-vmap #(schema % options) children)
            form (delay (-simple-form parent properties children -form options))
            cache (-create-cache options)
            ->parser (fn [f m] (let [parsers (m (-vmap f children))]
                                 #(reduce (fn [x parser] (miu/-map-invalid reduced (parser x))) % parsers)))]
        ^{:type ::schema}
        (reify
          Schema
          (-validator [_]
            (let [validators (-vmap -validator children)] (miu/-every-pred validators)))
          (-explainer [_ path]
            (let [explainers (-vmap (fn [[i c]] (-explainer c (conj path i))) (map-indexed vector children))]
              (fn explain [x in acc] (reduce (fn [acc' explainer] (explainer x in acc')) acc explainers))))
          (-parser [_] (->parser -parser seq))
          (-unparser [_] (->parser -unparser rseq))
          (-transformer [this transformer method options]
            (-parent-children-transformer this children transformer method options))
          (-walk [this walker path options] (-walk-indexed this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn -or-schema []
  ^{:type ::into-schema}
  (reify IntoSchema
    (-type [_] :or)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (-check-children! :or properties children 1 nil)
      (let [children (-vmap #(schema % options) children)
            form (delay (-simple-form parent properties children -form options))
            cache (-create-cache options)
            ->parser (fn [f] (let [parsers (-vmap f children)]
                               #(reduce (fn [_ parser] (miu/-map-valid reduced (parser %))) ::invalid parsers)))]
        ^{:type ::schema}
        (reify
          Schema
          (-validator [_]
            (let [validators (-vmap -validator children)] (miu/-some-pred validators)))
          (-explainer [_ path]
            (let [explainers (-vmap (fn [[i c]] (-explainer c (conj path i))) (map-indexed vector children))]
              (fn explain [x in acc]
                (reduce
                 (fn [acc' explainer]
                   (let [acc'' (explainer x in acc')]
                     (if (identical? acc' acc'') (reduced acc) acc'')))
                 acc explainers))))
          (-parser [_] (->parser -parser))
          (-unparser [_] (->parser -unparser))
          (-transformer [this transformer method options]
            (-or-transformer this transformer children method options))
          (-walk [this walker path options] (-walk-indexed this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn -orn-schema []
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent ast options] (-from-entry-ast parent ast options))
    IntoSchema
    (-type [_] :orn)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (-check-children! :orn properties children 1 nil)
      (let [entry-parser (-create-entry-parser children {:naked-keys true} options)
            form (delay (-create-entry-form parent properties entry-parser options))
            cache (-create-cache options)]
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [this _] (-entry-ast this (-entry-keyset entry-parser)))
          Schema
          (-validator [this] (miu/-some-pred (-vmap (fn [[_ _ c]] (-validator c)) (-children this))))
          (-explainer [this path]
            (let [explainers (-vmap (fn [[k _ c]] (-explainer c (conj path k))) (-children this))]
              (fn explain [x in acc]
                (reduce
                 (fn [acc' explainer]
                   (let [acc'' (explainer x in acc')]
                     (if (identical? acc' acc'') (reduced acc) acc'')))
                 acc explainers))))
          (-parser [this]
            (let [parsers (-vmap (fn [[k _ c]]
                                   (let [c (-parser c)]
                                     (fn [x] (miu/-map-valid #(reduced (miu/-tagged k %)) (c x)))))
                                 (-children this))]
              (fn [x] (reduce (fn [_ parser] (parser x)) x parsers))))
          (-unparser [this]
            (let [unparsers (into {} (map (fn [[k _ c]] [k (-unparser c)])) (-children this))]
              (fn [x]
                (if (miu/-tagged? x)
                  (if-some [unparse (get unparsers (key x))]
                    (unparse (val x))
                    ::invalid)
                  ::invalid))))
          (-transformer [this transformer method options]
            (-or-transformer this transformer (-vmap #(nth % 2) (-children this)) method options))
          (-walk [this walker path options] (-walk-entries this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] (-entry-children entry-parser))
          (-parent [_] parent)
          (-form [_] @form)
          EntrySchema
          (-entries [_] (-entry-entries entry-parser))
          (-entry-parser [_] entry-parser)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_] true)
          (-get [this key default] (-get-entries this key default))
          (-set [this key value] (-set-entries this key value)))))))

(defn -not-schema []
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent ast options] (-from-child-ast parent ast options))
    IntoSchema
    (-type [_] :not)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (-check-children! :not properties children 1 1)
      (let [[schema :as children] (-vmap #(schema % options) children)
            form (delay (-simple-form parent properties children -form options))
            cache (-create-cache options)]
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [this _] (-to-child-ast this))
          Schema
          (-validator [_] (complement (-validator schema)))
          (-explainer [this path]
            (let [validator (-validator this)]
              (fn explain [x in acc]
                (if-not (validator x) (conj acc (miu/-error (conj path 0) in this x)) acc))))
          (-parser [this]
            (let [validator (-validator this)]
              (fn [x] (if (validator x) x ::invalid))))
          (-unparser [this] (-parser this))
          (-transformer [this transformer method options]
            (-parent-children-transformer this children transformer method options))
          (-walk [this walker path options] (-walk-indexed this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn -val-schema
  ([schema properties]
   (-into-schema (-val-schema) properties (list schema) (-options schema)))
  ([]
   ^{:type ::into-schema}
   (reify
     AST
     (-from-ast [parent ast options] (-from-child-ast parent ast options))
     IntoSchema
     (-type [_] ::val)
     (-type-properties [_])
     (-properties-schema [_ _])
     (-children-schema [_ _])
     (-into-schema [parent properties children options]
      #_(-check-children! ::val properties children 1 1)
       (let [children (-vmap #(schema % options) children)
             form (delay (-simple-form parent properties children -form options))
             schema (first children)
             cache (-create-cache options)]
         ^{:type ::schema}
         (reify
           AST
           (-to-ast [this _] (-to-child-ast this))
           Schema
           (-validator [_] (-validator schema))
           (-explainer [_ path] (-explainer schema path))
           (-parser [_] (-parser schema))
           (-unparser [_] (-unparser schema))
           (-transformer [this transformer method options]
             (-parent-children-transformer this (list schema) transformer method options))
           (-walk [this walker path options]
             (if (::walk-entry-vals options)
               (when (-accept walker this path options)
                 (-outer walker this path (list (-inner walker schema path options)) options))
               (-walk schema walker path options)))
           (-properties [_] properties)
           (-options [_] (-options schema))
           (-children [_] [schema])
           (-parent [_] parent)
           (-form [_] @form)
           Cached
           (-cache [_] cache)
           LensSchema
           (-keep [_])
           (-get [_ key default] (if (= 0 key) schema default))
           (-set [_ key value] (when (= 0 key) (-val-schema value properties)))
           RefSchema
           (-ref [_])
           (-deref [_] schema)))))))

(defn -map-schema
  ([]
   (-map-schema {:naked-keys true}))
  ([opts] ;; :naked-keys, :lazy, :pred
   ^{:type ::into-schema}
   (reify
     AST
     (-from-ast [parent ast options] (-from-entry-ast parent ast options))
     IntoSchema
     (-type [_] :map)
     (-type-properties [_] (:type-properties opts))
     (-properties-schema [_ _])
     (-children-schema [_ _])
     (-into-schema [parent {:keys [closed] :as properties} children options]
       (let [pred? (:pred opts map?)
             entry-parser (-create-entry-parser children opts options)
             form (delay (-create-entry-form parent properties entry-parser options))
             cache (-create-cache options)
             default-schema (delay (some-> entry-parser (-entry-children) (-default-entry-schema) (schema options)))
             explicit-children (delay (cond->> (-entry-children entry-parser) @default-schema (remove -default-entry)))
             ->parser (fn [this f]
                        (let [keyset (-entry-keyset (-entry-parser this))
                              default-parser (some-> @default-schema (f))
                              parsers (cond->> (-vmap
                                                (fn [[key {:keys [optional]} schema]]
                                                  (let [parser (f schema)]
                                                    (fn [m]
                                                      (if-let [e (find m key)]
                                                        (let [v (val e)
                                                              v* (parser v)]
                                                          (cond (miu/-invalid? v*) (reduced v*)
                                                                (identical? v* v) m
                                                                :else (assoc m key v*)))
                                                        (if optional m (reduced ::invalid))))))
                                                @explicit-children)
                                        default-parser
                                        (cons (fn [m]
                                                (let [m' (default-parser
                                                          (reduce (fn [acc k] (dissoc acc k)) m (keys keyset)))]
                                                  (if (miu/-invalid? m')
                                                    (reduced m')
                                                    (merge (select-keys m (keys keyset)) m')))))
                                        closed
                                        (cons (fn [m]
                                                (reduce
                                                 (fn [m k] (if (contains? keyset k) m (reduced (reduced ::invalid))))
                                                 m (keys m)))))]
                          (fn [x] (if (pred? x) (reduce (fn [m parser] (parser m)) x parsers) ::invalid))))]
         ^{:type ::schema}
         (reify
           AST
           (-to-ast [this _] (-entry-ast this (-entry-keyset entry-parser)))
           Schema
           (-validator [this]
             (let [keyset (-entry-keyset (-entry-parser this))
                   default-validator (some-> @default-schema (-validator))
                   validators (cond-> (-vmap
                                       (fn [[key {:keys [optional]} value]]
                                         (let [valid? (-validator value)
                                               default (boolean optional)]
                                           #?(:bb   (fn [m] (if-let [map-entry (find m key)] (valid? (val map-entry)) default))
                                              :clj  (fn [^Associative m] (if-let [map-entry (.entryAt m key)] (valid? (.val map-entry)) default))
                                              :cljs (fn [m] (if-let [map-entry (find m key)] (valid? (val map-entry)) default)))))
                                       @explicit-children)
                                default-validator
                                (conj (fn [m] (default-validator (reduce (fn [acc k] (dissoc acc k)) m (keys keyset)))))
                                (and closed (not default-validator))
                                (conj (fn [m] (reduce (fn [acc k] (if (contains? keyset k) acc (reduced false))) true (keys m)))))
                   validate (miu/-every-pred validators)]
               (fn [m] (and (pred? m) (validate m)))))
           (-explainer [this path]
             (let [keyset (-entry-keyset (-entry-parser this))
                   default-explainer (some-> @default-schema (-explainer (conj path ::default)))
                   explainers (cond-> (-vmap
                                       (fn [[key {:keys [optional]} schema]]
                                         (let [explainer (-explainer schema (conj path key))]
                                           (fn [x in acc]
                                             (if-let [e (find x key)]
                                               (explainer (val e) (conj in key) acc)
                                               (if-not optional
                                                 (conj acc (miu/-error (conj path key) (conj in key) this nil ::missing-key))
                                                 acc)))))
                                       @explicit-children)
                                default-explainer
                                (conj (fn [x in acc]
                                        (default-explainer
                                         (reduce (fn [acc k] (dissoc acc k)) x (keys keyset))
                                         in acc)))
                                (and closed (not default-explainer))
                                (conj (fn [x in acc]
                                        (reduce-kv
                                         (fn [acc k v]
                                           (if (contains? keyset k)
                                             acc
                                             (conj acc (miu/-error (conj path k) (conj in k) this v ::extra-key))))
                                         acc x))))]
               (fn [x in acc]
                 (if-not (pred? x)
                   (conj acc (miu/-error path in this x ::invalid-type))
                   (reduce
                    (fn [acc explainer]
                      (explainer x in acc))
                    acc explainers)))))
           (-parser [this] (->parser this -parser))
           (-unparser [this] (->parser this -unparser))
           (-transformer [this transformer method options]
             (let [keyset (-entry-keyset (-entry-parser this))
                   this-transformer (-value-transformer transformer this method options)
                   ->children (reduce (fn [acc [k s]]
                                        (let [t (-transformer s transformer method options)]
                                          (cond-> acc t (conj [k t]))))
                                      [] (cond->> (-entries this) @default-schema (remove -default-entry)))
                   apply->children (when (seq ->children) (-map-transformer ->children))
                   apply->default (when-let [dt (some-> @default-schema (-transformer transformer method options))]
                                    (fn [x] (merge (dt (reduce (fn [acc k] (dissoc acc k)) x (keys keyset))) (select-keys x (keys keyset)))))
                   apply->children (some->> [apply->default apply->children] (keep identity) (seq) (apply -comp))
                   apply->children (-guard pred? apply->children)]
               (-intercepting this-transformer apply->children)))
           (-walk [this walker path options] (-walk-entries this walker path options))
           (-properties [_] properties)
           (-options [_] options)
           (-children [_] (-entry-children entry-parser))
           (-parent [_] parent)
           (-form [_] @form)
           EntrySchema
           (-entries [_] (-entry-entries entry-parser))
           (-entry-parser [_] entry-parser)
           Cached
           (-cache [_] cache)
           LensSchema
           (-keep [_] true)
           (-get [this key default] (-get-entries this key default))
           (-set [this key value] (-set-entries this key value))))))))

(defn -map-of-schema
  ([]
   (-map-of-schema {}))
  ([opts]
   ^{:type ::into-schema}
   (reify
     AST
     (-from-ast [parent ast options]
       (-into-schema parent (:properties ast) [(from-ast (:key ast) options) (from-ast (:value ast) options)] options))
     IntoSchema
     (-type [_] :map-of)
     (-type-properties [_] (:type-properties opts))
     (-properties-schema [_ _])
     (-children-schema [_ _])
     (-into-schema [parent {:keys [min max] :as properties} children options]
       (-check-children! :map-of properties children 2 2)
       (let [[key-schema value-schema :as children] (-vmap #(schema % options) children)
             form (delay (-simple-form parent properties children -form options))
             cache (-create-cache options)
             validate-limits (-validate-limits min max)
             ->parser (fn [f] (let [key-parser (f key-schema)
                                    value-parser (f value-schema)]
                                (fn [x]
                                  (if (map? x)
                                    (reduce-kv (fn [acc k v]
                                                 (let [k* (key-parser k)
                                                       v* (value-parser v)]
                                                   ;; OPTIMIZE: Restore `identical?` check + NOOP
                                                   (if (or (miu/-invalid? k*) (miu/-invalid? v*))
                                                     (reduced ::invalid)
                                                     (assoc acc k* v*))))
                                               (empty x) x)
                                    ::invalid))))]
         ^{:type ::schema}
         (reify
           AST
           (-to-ast [_ _]
             (-ast {:type :map-of, :key (ast key-schema), :value (ast value-schema)} properties options))
           Schema
           (-validator [_]
             (let [key-valid? (-validator key-schema)
                   value-valid? (-validator value-schema)]
               (fn [m]
                 (and (map? m)
                      (validate-limits m)
                      (reduce-kv
                       (fn [_ key value]
                         (or (and (key-valid? key) (value-valid? value)) (reduced false)))
                       true m)))))
           (-explainer [this path]
             (let [key-explainer (-explainer key-schema (conj path 0))
                   value-explainer (-explainer value-schema (conj path 1))]
               (fn explain [m in acc]
                 (if-not (map? m)
                   (conj acc (miu/-error path in this m ::invalid-type))
                   (if-not (validate-limits m)
                     (conj acc (miu/-error path in this m ::limits))
                     (reduce-kv
                      (fn [acc key value]
                        (let [in (conj in key)]
                          (->> acc
                               (key-explainer key in)
                               (value-explainer value in))))
                      acc m))))))
           (-parser [_] (->parser -parser))
           (-unparser [_] (->parser -unparser))
           (-transformer [this transformer method options]
             (let [this-transformer (-value-transformer transformer this method options)
                   ->key (-transformer key-schema transformer method options)
                   ->child (-transformer value-schema transformer method options)
                   ->key-child (cond
                                 (and ->key ->child) #(assoc %1 (->key %2) (->child %3))
                                 ->key #(assoc %1 (->key %2) %3)
                                 ->child #(assoc %1 %2 (->child %3)))
                   apply->key-child (when ->key-child #(reduce-kv ->key-child (empty %) %))
                   apply->key-child (-guard map? apply->key-child)]
               (-intercepting this-transformer apply->key-child)))
           (-walk [this walker path options] (-walk-indexed this walker path options))
           (-properties [_] properties)
           (-options [_] options)
           (-children [_] children)
           (-parent [_] parent)
           (-form [_] @form)
           Cached
           (-cache [_] cache)
           LensSchema
           (-keep [_])
           (-get [_ key default] (get children key default))
           (-set [this key value] (-set-assoc-children this key value))))))))

(defn -collection-schema [props]
  (if (fn? props)
    (do (-deprecated! "-collection-schema doesn't take fn-props, use :compiled property instead")
        (-collection-schema {:compile (fn [c p _] (props c p))}))
    ^{:type ::into-schema}
    (reify
      AST
      (-from-ast [parent ast options] (-from-child-ast parent ast options))
      IntoSchema
      (-type [_] (:type props))
      (-type-properties [_] (:type-properties props))
      (-properties-schema [_ _])
      (-children-schema [_ _])
      (-into-schema [parent {:keys [min max] :as properties} children options]
        (if-let [compile (:compile props)]
          (-into-schema (-collection-schema (merge (dissoc props :compile) (compile properties children options))) properties children options)
          (let [{:keys [type parse unparse], fpred :pred, fempty :empty, fin :in :or {fin (fn [i _] i)}} props]
            (-check-children! type properties children 1 1)
            (let [[schema :as children] (-vmap #(schema % options) children)
                  form (delay (-simple-form parent properties children -form options))
                  cache (-create-cache options)
                  validate-limits (-validate-limits min max)
                  ->parser (fn [f g] (let [child-parser (f schema)]
                                       (fn [x]
                                         (cond
                                           (not (fpred x)) ::invalid
                                           (not (validate-limits x)) ::invalid
                                           :else (let [x' (reduce
                                                           (fn [acc v]
                                                             (let [v' (child-parser v)]
                                                               (if (miu/-invalid? v') (reduced ::invalid) (conj acc v'))))
                                                           [] x)]
                                                   (cond
                                                     (miu/-invalid? x') x'
                                                     g (g x')
                                                     fempty (into fempty x')
                                                     :else x'))))))]
              ^{:type ::schema}
              (reify
                AST
                (-to-ast [this _] (-to-child-ast this))
                Schema
                (-validator [_]
                  (let [validator (-validator schema)]
                    (fn [x] (and (fpred x)
                                 (validate-limits x)
                                 (reduce (fn [acc v] (if (validator v) acc (reduced false))) true x)))))
                (-explainer [this path]
                  (let [explainer (-explainer schema (conj path 0))]
                    (fn [x in acc]
                      (cond
                        (not (fpred x)) (conj acc (miu/-error path in this x ::invalid-type))
                        (not (validate-limits x)) (conj acc (miu/-error path in this x ::limits))
                        :else (let [size (count x)]
                                (loop [acc acc, i 0, [x & xs] x]
                                  (if (< i size)
                                    (cond-> (or (explainer x (conj in (fin i x)) acc) acc) xs (recur (inc i) xs))
                                    acc)))))))
                (-parser [_] (->parser -parser parse))
                (-unparser [_] (->parser -unparser unparse))
                (-transformer [this transformer method options]
                  (let [collection? #(or (sequential? %) (set? %))
                        this-transformer (-value-transformer transformer this method options)
                        child-transformer (-transformer schema transformer method options)
                        ->child (when child-transformer
                                  (if fempty
                                    (-collection-transformer child-transformer fempty)
                                    #(-vmap child-transformer %)))
                        ->child (-guard collection? ->child)]
                    (-intercepting this-transformer ->child)))
                (-walk [this walker path options]
                  (when (-accept walker this path options)
                    (-outer walker this path [(-inner walker schema (conj path ::in) options)] options)))
                (-properties [_] properties)
                (-options [_] options)
                (-children [_] children)
                (-parent [_] parent)
                (-form [_] @form)
                Cached
                (-cache [_] cache)
                LensSchema
                (-keep [_] true)
                (-get [_ _ _] schema)
                (-set [this _ value] (-set-children this [value]))))))))))

(defn -tuple-schema
  ([]
   (-tuple-schema {}))
  ([opts]
   ^{:type ::into-schema}
   (reify IntoSchema
     (-type [_] :tuple)
     (-type-properties [_] (:type-properties opts))
     (-properties-schema [_ _])
     (-children-schema [_ _])
     (-into-schema [parent properties children options]
       (let [children (-vmap #(schema % options) children)
             form (delay (-simple-form parent properties children -form options))
             size (count children)
             cache (-create-cache options)
             ->parser (fn [f] (let [parsers (into {} (comp (map f) (map-indexed vector)) children)]
                                (fn [x]
                                  (cond
                                    (not (vector? x)) ::invalid
                                    (not= (count x) size) ::invalid
                                    :else (reduce-kv (fn [x i c]
                                                       (let [v (get x i)
                                                             v* (c v)]
                                                         (cond
                                                           (miu/-invalid? v*) (reduced v*)
                                                           (identical? v* v) x
                                                           :else (assoc x i v*))))
                                                     x parsers)))))]
         ^{:type ::schema}
         (reify
           Schema
           (-validator [_]
             (let [validators (into (array-map) (map-indexed vector (mapv -validator children)))]
               (fn [x] (and (vector? x)
                            (= (count x) size)
                            (reduce-kv
                             (fn [acc i validator]
                               (if (validator (nth x i)) acc (reduced false))) true validators)))))
           (-explainer [this path]
             (let [explainers (-vmap (fn [[i s]] (-explainer s (conj path i))) (map-indexed vector children))]
               (fn [x in acc]
                 (cond
                   (not (vector? x)) (conj acc (miu/-error path in this x ::invalid-type))
                   (not= (count x) size) (conj acc (miu/-error path in this x ::tuple-size))
                   :else (loop [acc acc, i 0, [x & xs] x, [e & es] explainers]
                           (cond-> (e x (conj in i) acc) xs (recur (inc i) xs es)))))))
           (-parser [_] (->parser -parser))
           (-unparser [_] (->parser -unparser))
           (-transformer [this transformer method options]
             (let [this-transformer (-value-transformer transformer this method options)
                   ->children (into {} (comp (map-indexed vector)
                                             (keep (fn [[k c]]
                                                     (when-some [t (-transformer c transformer method options)]
                                                       [k t])))) children)
                   apply->children (when (seq ->children) (-tuple-transformer ->children))
                   apply->children (-guard vector? apply->children)]
               (-intercepting this-transformer apply->children)))
           (-walk [this walker path options] (-walk-indexed this walker path options))
           (-properties [_] properties)
           (-options [_] options)
           (-children [_] children)
           (-parent [_] parent)
           (-form [_] @form)
           Cached
           (-cache [_] cache)
           LensSchema
           (-keep [_] true)
           (-get [_ key default] (get children key default))
           (-set [this key value] (-set-assoc-children this key value))))))))

(defn -enum-schema []
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent ast options] (-into-schema parent (:properties ast) (:values ast) options))
    IntoSchema
    (-type [_] :enum)
    (-type-properties [_])
    (-into-schema [parent properties children options]
      (-check-children! :enum properties children 1 nil)
      (let [children (vec children)
            schema (set children)
            form (delay (-simple-form parent properties children identity options))
            cache (-create-cache options)]
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [_ _] (-ast {:type :enum :values children} properties options))
          Schema
          (-validator [_]
            (fn [x] (contains? schema x)))
          (-explainer [this path]
            (let [validator (-validator this)]
              (fn explain [x in acc]
                (if-not (validator x) (conj acc (miu/-error path in this x)) acc))))
          (-parser [_] (fn [x] (if (contains? schema x) x ::invalid)))
          (-unparser [this] (-parser this))
          ;; TODO: should we try to derive the type from values? e.g. [:enum 1 2] ~> int?
          (-transformer [this transformer method options]
            (-intercepting (-value-transformer transformer this method options)))
          (-walk [this walker path options] (-walk-leaf this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn -re-schema [class?]
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent ast options] (-from-value-ast parent ast options))
    IntoSchema
    (-type [_] :re)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties [child :as children] options]
      (-check-children! :re properties children 1 1)
      (let [children (vec children)
            re (re-pattern child)
            form (delay (if class? re (-simple-form parent properties children identity options)))
            cache (-create-cache options)]
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [this _] (-to-value-ast this))
          Schema
          (-validator [_]
            (-safe-pred #(re-find re %)))
          (-explainer [this path]
            (fn explain [x in acc]
              (try
                (if-not (re-find re x)
                  (conj acc (miu/-error path in this x))
                  acc)
                (catch #?(:clj Exception, :cljs js/Error) e
                  (conj acc (miu/-error path in this x (:type (ex-data e))))))))
          (-transformer [this transformer method options]
            (-intercepting (-value-transformer transformer this method options)))
          (-parser [this]
            (let [valid? (-validator this)]
              (fn [x] (if (valid? x) x ::invalid))))
          (-unparser [this] (-parser this))
          (-walk [this walker path options] (-walk-leaf this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn -fn-schema []
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent ast options] (-from-value-ast parent ast options))
    IntoSchema
    (-type [_] :fn)
    (-type-properties [_])
    (-into-schema [parent properties children options]
      (-check-children! :fn properties children 1 1)
      (let [children (vec children)
            f (eval (first children) options)
            form (delay (-simple-form parent properties children identity options))
            cache (-create-cache options)]
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [this _] (-to-value-ast this))
          Schema
          (-validator [_] (-safe-pred f))
          (-explainer [this path]
            (fn explain [x in acc]
              (try
                (if-not (f x)
                  (conj acc (miu/-error path in this x))
                  acc)
                (catch #?(:clj Exception, :cljs js/Error) e
                  (conj acc (miu/-error path in this x (:type (ex-data e))))))))
          (-parser [this]
            (let [validator (-validator this)]
              (fn [x] (if (validator x) x ::invalid))))
          (-unparser [this] (-parser this))
          (-transformer [this transformer method options]
            (-intercepting (-value-transformer transformer this method options)))
          (-walk [this walker path options] (-walk-leaf this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn -maybe-schema []
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent ast options] (-from-child-ast parent ast options))
    IntoSchema
    (-type [_] :maybe)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (-check-children! :maybe properties children 1 1)
      (let [[schema :as children] (-vmap #(schema % options) children)
            form (delay (-simple-form parent properties children -form options))
            cache (-create-cache options)
            ->parser (fn [f] (let [parser (f schema)] (fn [x] (if (nil? x) x (parser x)))))]
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [this _] (-to-child-ast this))
          Schema
          (-validator [_]
            (let [validator (-validator schema)]
              (fn [x] (or (nil? x) (validator x)))))
          (-explainer [_ path]
            (let [explainer (-explainer schema (conj path 0))]
              (fn explain [x in acc]
                (if (nil? x) acc (explainer x in acc)))))
          (-parser [_] (->parser -parser))
          (-unparser [_] (->parser -unparser))
          (-transformer [this transformer method options]
            (-parent-children-transformer this children transformer method options))
          (-walk [this walker path options] (-walk-indexed this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (if (= 0 key) schema default))
          (-set [this key value] (if (= 0 key)
                                   (-set-children this [value])
                                   (-fail! ::index-out-of-bounds {:schema this, :key key}))))))))

(defn -multi-schema
  ([]
   (-multi-schema {:naked-keys true}))
  ([opts]
   ^{:type ::into-schema}
   (reify
     AST
     (-from-ast [parent ast options] (-from-entry-ast parent ast options))
     IntoSchema
     (-type [_] (or (:type opts) :multi))
     (-type-properties [_] (:type-properties opts))
     (-properties-schema [_ _])
     (-children-schema [_ _])
     (-into-schema [parent properties children options]
       (let [opts' (merge opts (select-keys properties [:lazy-refs]))
             entry-parser (-create-entry-parser children opts' options)
             form (delay (-create-entry-form parent properties entry-parser options))
             cache (-create-cache options)
             dispatch (eval (:dispatch properties) options)
             dispatch-map (delay (into {} (-entry-entries entry-parser)))
             finder (fn [{:keys [::default] :as m}] (fn [x] (m x default)))]
         (when-not dispatch
           (-fail! ::missing-property {:key :dispatch}))
         ^{:type ::schema}
         (reify
           AST
           (-to-ast [this _] (-entry-ast this (-entry-keyset entry-parser)))
           Schema
           (-validator [_]
             (let [find (finder (reduce-kv (fn [acc k s] (assoc acc k (-validator s))) {} @dispatch-map))]
               (fn [x] (if-let [validator (find (dispatch x))] (validator x) false))))
           (-explainer [this path]
             (let [find (finder (reduce (fn [acc [k s]] (assoc acc k (-explainer s (conj path k)))) {} (-entries this)))]
               (fn [x in acc]
                 (if-let [explainer (find (dispatch x))]
                   (explainer x in acc)
                   (let [->path (if (and (map? x) (keyword? dispatch)) #(conj % dispatch) identity)]
                     (conj acc (miu/-error (->path path) (->path in) this x ::invalid-dispatch-value)))))))
           (-parser [_]
             (let [parse (fn [k s] (let [p (-parser s)] (fn [x] (miu/-map-valid #(miu/-tagged k %) (p x)))))
                   find (finder (reduce-kv (fn [acc k s] (assoc acc k (parse k s))) {} @dispatch-map))]
               (fn [x] (if-some [parser (find (dispatch x))] (parser x) ::invalid))))
           (-unparser [_]
             (let [unparsers (reduce-kv (fn [acc k s] (assoc acc k (-unparser s))) {} @dispatch-map)]
               (fn [x] (if (miu/-tagged? x) (if-some [f (unparsers (key x))] (f (val x)) ::invalid) ::invalid))))
           (-transformer [this transformer method options]
            ;; FIXME: Probably should not use `dispatch`
            ;; Can't use `dispatch` as `x` might not be valid before it has been unparsed:
             (let [this-transformer (-value-transformer transformer this method options)
                   ->children (reduce-kv (fn [acc k s] (let [t (-transformer s transformer method options)]
                                                         (cond-> acc t (assoc k t)))) {} @dispatch-map)
                   find (finder ->children)
                   child-transformer (when (seq ->children) (fn [x] (if-some [t (find (dispatch x))] (t x) x)))]
               (-intercepting this-transformer child-transformer)))
           (-walk [this walker path options] (-walk-entries this walker path options))
           (-properties [_] properties)
           (-options [_] options)
           (-children [_] (-entry-children entry-parser))
           (-parent [_] parent)
           (-form [_] @form)
           EntrySchema
           (-entries [_] (-entry-entries entry-parser))
           (-entry-parser [_] entry-parser)
           Cached
           (-cache [_] cache)
           LensSchema
           (-keep [_])
           (-get [this key default] (-get-entries this key default))
           (-set [this key value] (-set-entries this key value))))))))

(defn -ref-schema
  ([]
   (-ref-schema nil))
  ([{:keys [lazy type-properties]}]
   ^{:type ::into-schema}
   (reify
     AST
     (-from-ast [parent ast options] (-from-value-ast parent ast options))
     IntoSchema
     (-type [_] :ref)
     (-type-properties [_] type-properties)
     (-into-schema [parent properties [ref :as children] {::keys [allow-invalid-refs] :as options}]
       (-check-children! :ref properties children 1 1)
       (when-not (-reference? ref)
         (-fail! ::invalid-ref {:ref ref}))
       (let [-ref (or (and lazy (-memoize (fn [] (schema (mr/-schema (-registry options) ref) options))))
                      (when-let [s (mr/-schema (-registry options) ref)] (-memoize (fn [] (schema s options))))
                      (when-not allow-invalid-refs
                        (-fail! ::invalid-ref {:type :ref, :ref ref})))
             children (vec children)
             form (delay (-simple-form parent properties children identity options))
             cache (-create-cache options)
             ->parser (fn [f] (let [parser (-memoize (fn [] (f (-ref))))]
                                (fn [x] ((parser) x))))]
         ^{:type ::schema}
         (reify
           AST
           (-to-ast [this _] (-to-value-ast this))
           Schema
           (-validator [_]
             (let [validator (-memoize (fn [] (-validator (-ref))))]
               (fn [x] ((validator) x))))
           (-explainer [_ path]
             (let [explainer (-memoize (fn [] (-explainer (-ref) (conj path 0))))]
               (fn [x in acc] ((explainer) x in acc))))
           (-parser [_] (->parser -parser))
           (-unparser [_] (->parser -unparser))
           (-transformer [this transformer method options]
             (let [this-transformer (-value-transformer transformer this method options)
                   deref-transformer (-memoize (fn [] (-transformer (-ref) transformer method options)))]
               (-intercepting this-transformer (fn [x] (if-some [t (deref-transformer)] (t x) x)))))
           (-walk [this walker path options]
             (let [accept (fn [] (-inner walker (-ref) (into path [0 0])
                                         (-update options ::walked-refs #(conj (or % #{}) ref))))]
               (when (-accept walker this path options)
                 (if (or (not ((-boolean-fn (::walk-refs options false)) ref))
                         (contains? (::walked-refs options) ref))
                   (-outer walker this path [ref] options)
                   (-outer walker this path [(accept)] options)))))
           (-properties [_] properties)
           (-options [_] options)
           (-children [_] children)
           (-parent [_] parent)
           (-form [_] @form)
           Cached
           (-cache [_] cache)
           LensSchema
           (-get [_ key default] (if (= key 0) (-pointer ref (-ref) options) default))
           (-keep [_])
           (-set [this key value] (if (= key 0) (-set-children this [value])
                                                (-fail! ::index-out-of-bounds {:schema this, :key key})))
           RefSchema
           (-ref [_] ref)
           (-deref [_] (-ref))
           RegexSchema
           (-regex-op? [_] false)
           (-regex-validator [this] (-fail! ::potentially-recursive-seqex this))
           (-regex-explainer [this _] (-fail! ::potentially-recursive-seqex this))
           (-regex-parser [this] (-fail! ::potentially-recursive-seqex this))
           (-regex-unparser [this] (-fail! ::potentially-recursive-seqex this))
           (-regex-transformer [this _ _ _] (-fail! ::potentially-recursive-seqex this))
           (-regex-min-max [this _] (-fail! ::potentially-recursive-seqex this))))))))

(defn -schema-schema [{:keys [id raw]}]
  ^{:type ::into-schema}
  (let [internal (or id raw)
        type (if internal ::schema :schema)]
    ^{:type ::into-schema}
    (reify
      AST
      (-from-ast [parent ast options] ((if internal -from-value-ast -from-child-ast) parent ast options))
      IntoSchema
      (-type [_] type)
      (-type-properties [_])
      (-properties-schema [_ _])
      (-children-schema [_ _])
      (-into-schema [parent properties children options]
        (-check-children! type properties children 1 1)
        (let [children (-vmap #(schema % options) children)
              child (nth children 0)
              form (delay (or (and (empty? properties) (or id (and raw (-form child))))
                              (-simple-form parent properties children -form options)))
              cache (-create-cache options)]
          ^{:type ::schema}
          (reify
            AST
            (-to-ast [this _]
              (cond
                id (-ast {:type type, :value id} (-properties this) (-options this))
                raw (-to-value-ast this)
                :else (-to-child-ast this)))
            Schema
            (-validator [_] (-validator child))
            (-explainer [_ path] (-explainer child (conj path 0)))
            (-parser [_] (-parser child))
            (-unparser [_] (-unparser child))
            (-transformer [this transformer method options]
              (-parent-children-transformer this children transformer method options))
            (-walk [this walker path options]
              (when (-accept walker this path options)
                (if (or (not id) ((-boolean-fn (::walk-schema-refs options false)) id))
                  (-outer walker this path (-inner-indexed walker path children options) options)
                  (-outer walker this path children options))))
            (-properties [_] properties)
            (-options [_] options)
            (-children [_] children)
            (-parent [_] parent)
            (-form [_] @form)
            Cached
            (-cache [_] cache)
            LensSchema
            (-keep [_])
            (-get [_ key default] (if (= key 0) child default))
            (-set [this key value] (if (= key 0) (-set-children this [value])
                                                 (-fail! ::index-out-of-bounds {:schema this, :key key})))
            RefSchema
            (-ref [_] id)
            (-deref [_] child)
            RegexSchema
            (-regex-op? [_]
              (if internal
                (-regex-op? child)
                false))
            (-regex-validator [_]
              (if internal
                (-regex-validator child)
                (re/item-validator (-validator child))))
            (-regex-explainer [_ path]
              (if internal
                (-regex-explainer child path)
                (re/item-explainer path child (-explainer child path))))
            (-regex-parser [_]
              (if internal
                (-regex-parser child)
                (re/item-parser (parser child))))
            (-regex-unparser [_]
              (if internal
                (-regex-unparser child)
                (re/item-unparser (unparser child))))
            (-regex-transformer [_ transformer method options]
              (if internal
                (-regex-transformer child transformer method options)
                (re/item-transformer method (-validator child)
                                     (or (-transformer child transformer method options) identity))))
            (-regex-min-max [_ nested?]
              (if (and nested? (not internal))
                {:min 1 :max 1}
                (-regex-min-max child nested?)))))))))

(defn -=>-schema []
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent {:keys [input output properties]} options]
      (-into-schema parent properties [(from-ast input options) (from-ast output options)] options))
    IntoSchema
    (-type [_] :=>)
    (-type-properties [_])
    (-into-schema [parent properties children {::keys [function-checker] :as options}]
      (-check-children! :=> properties children 2 2)
      (let [[input output :as children] (-vmap #(schema % options) children)
            form (delay (-simple-form parent properties children -form options))
            cache (-create-cache options)
            ->checker (if function-checker #(function-checker % options) (constantly nil))]
        (when-not (#{:cat :catn} (type input))
          (-fail! ::invalid-input-schema {:input input}))
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [_ _]
            (cond-> {:type :=>, :input (ast input), :output (ast output)}
              properties (assoc :properties properties)))
          Schema
          (-validator [this]
            (if-let [checker (->checker this)]
              (let [validator (fn [x] (nil? (checker x)))]
                (fn [x] (and (ifn? x) (validator x)))) ifn?))
          (-explainer [this path]
            (if-let [checker (->checker this)]
              (fn explain [x in acc]
                (if (not (fn? x))
                  (conj acc (miu/-error path in this x))
                  (if-let [res (checker x)]
                    (conj acc (assoc (miu/-error path in this x) :check res))
                    acc)))
              (let [validator (-validator this)]
                (fn explain [x in acc]
                  (if-not (validator x) (conj acc (miu/-error path in this x)) acc)))))
          (-parser [this]
            (let [validator (-validator this)]
              (fn [x] (if (validator x) x ::invalid))))
          (-unparser [this] (-parser this))
          (-transformer [_ _ _ _])
          (-walk [this walker path options] (-walk-indexed this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn -function-schema [_]
  ^{:type ::into-schema}
  (reify IntoSchema
    (-type [_] :function)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children {::keys [function-checker] :as options}]
      (-check-children! :function properties children 1 nil)
      (let [children (-vmap #(schema % options) children)
            form (delay (-simple-form parent properties children -form options))
            cache (-create-cache options)
            ->checker (if function-checker #(function-checker % options) (constantly nil))]
        (when-not (every? #(= :=> (type %)) children)
          (-fail! ::non-function-childs {:children children}))
        (-group-by-arity! (-vmap -function-info children))
        ^{:type ::schema}
        (reify
          Schema
          (-validator [this]
            (if-let [checker (->checker this)]
              (let [validator (fn [x] (nil? (checker x)))]
                (fn [x] (and (ifn? x) (validator x)))) ifn?))
          (-explainer [this path]
            (if-let [checker (->checker this)]
              (fn explain [x in acc]
                (if (not (fn? x))
                  (conj acc (miu/-error path in this x))
                  (if-let [res (checker x)]
                    (conj acc (assoc (miu/-error path in this x) :check res))
                    acc)))
              (let [validator (-validator this)]
                (fn explain [x in acc]
                  (if-not (validator x) (conj acc (miu/-error path in this x)) acc)))))
          (-parser [this]
            (let [validator (-validator this)]
              (fn [x] (if (validator x) x ::invalid))))
          (-unparser [this] (-parser this))
          (-transformer [_ _ _ _])
          (-walk [this walker path options] (-walk-indexed this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_])
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value)))))))

(defn- regex-validator [schema] (re/validator (-regex-validator schema)))

(defn- regex-explainer [schema path] (re/explainer schema path (-regex-explainer schema path)))

(defn- regex-parser [schema] (re/parser (-regex-parser schema)))

(defn- regex-transformer [schema transformer method options]
  (let [this-transformer (-value-transformer transformer schema method options)
        ->children (re/transformer (-regex-transformer schema transformer method options))]
    (-intercepting this-transformer ->children)))

(defn -sequence-schema
  [{:keys [type re-validator re-explainer re-parser re-unparser re-transformer re-min-max] {:keys [min max]} :child-bounds}]
  ^{:type ::into-schema}
  (reify IntoSchema
    (-type [_] type)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (-check-children! type properties children min max)
      (let [children (-vmap #(schema % options) children)
            form (delay (-simple-form parent properties children -form options))
            cache (-create-cache options)]
        ^{:type ::schema}
        (reify
          Schema
          (-validator [this] (regex-validator this))
          (-explainer [this path] (regex-explainer this path))
          (-parser [this] (regex-parser this))
          (-unparser [this] (-regex-unparser this))
          (-transformer [this transformer method options] (regex-transformer this transformer method options))
          (-walk [this walker path options] (-walk-indexed this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_] true)
          (-get [_ key default] (get children key default))
          (-set [this key value] (-set-assoc-children this key value))
          RegexSchema
          (-regex-op? [_] true)
          (-regex-validator [_] (re-validator properties (-vmap -regex-validator children)))
          (-regex-explainer [_ path]
            (re-explainer properties (map-indexed (fn [i child] (-regex-explainer child (conj path i))) children)))
          (-regex-parser [_] (re-parser properties (-vmap -regex-parser children)))
          (-regex-unparser [_] (re-unparser properties (-vmap -regex-unparser children)))
          (-regex-transformer [_ transformer method options]
            (re-transformer properties (-vmap #(-regex-transformer % transformer method options) children)))
          (-regex-min-max [_ _] (re-min-max properties children)))))))

(defn -sequence-entry-schema
  [{:keys [type re-validator re-explainer re-parser re-unparser re-transformer re-min-max] {:keys [min max]} :child-bounds :as opts}]
  ^{:type ::into-schema}
  (reify
    AST
    (-from-ast [parent ast options] (-from-entry-ast parent ast options))
    IntoSchema
    (-type [_] type)
    (-type-properties [_])
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (-check-children! type properties children min max)
      (let [entry-parser (-create-entry-parser children opts options)
            form (delay (-create-entry-form parent properties entry-parser options))
            cache (-create-cache options)]
        ^{:type ::schema}
        (reify
          AST
          (-to-ast [this _] (-entry-ast this (-entry-keyset entry-parser)))
          Schema
          (-validator [this] (regex-validator this))
          (-explainer [this path] (regex-explainer this path))
          (-parser [this] (regex-parser this))
          (-unparser [this] (-regex-unparser this))
          (-transformer [this transformer method options] (regex-transformer this transformer method options))
          (-walk [this walker path options] (-walk-entries this walker path options))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] (-entry-children entry-parser))
          (-parent [_] parent)
          (-form [_] @form)
          Cached
          (-cache [_] cache)
          LensSchema
          (-keep [_] true)
          (-get [this key default] (-get-entries this key default))
          (-set [this key value] (-set-entries this key value))
          EntrySchema
          (-entries [_] (-entry-entries entry-parser))
          (-entry-parser [_] entry-parser)
          RegexSchema
          (-regex-op? [_] true)
          (-regex-validator [this] (re-validator properties (-vmap (fn [[k _ s]] [k (-regex-validator s)]) (-children this))))
          (-regex-explainer [this path]
            (re-explainer properties (-vmap (fn [[k _ s]] [k (-regex-explainer s (conj path k))]) (-children this))))
          (-regex-parser [this] (re-parser properties (-vmap (fn [[k _ s]] [k (-regex-parser s)]) (-children this))))
          (-regex-unparser [this] (re-unparser properties (-vmap (fn [[k _ s]] [k (-regex-unparser s)]) (-children this))))
          (-regex-transformer [this transformer method options]
            (re-transformer properties (-vmap (fn [[k _ s]] [k (-regex-transformer s transformer method options)]) (-children this))))
          (-regex-min-max [this _] (re-min-max properties (-children this))))))))

;;
;; public api
;;

;;
;; into-schema
;;

(defn into-schema?
  "Checks if x is a IntoSchema instance"
  [x] (#?(:clj instance?, :cljs implements?) malli.core.IntoSchema x))

(defn into-schema
  "Creates a Schema instance out of type, optional properties map and children"
  ([type properties children]
   (into-schema type properties children nil))
  ([type properties children options]
   (let [properties (when properties (when (pos? (count properties)) properties))
         r (when properties (properties :registry))
         options (if r (-update options :registry #(mr/composite-registry r (or % (-registry options)))) options)
         properties (if r (assoc properties :registry (-property-registry r options identity)) properties)]
     (-into-schema (-lookup! type into-schema? false options) properties children options))))

(defn type
  "Returns the Schema type."
  ([?schema]
   (type ?schema nil))
  ([?schema options]
   (-type (-parent (schema ?schema options)))))

(defn type-properties
  "Returns the Schema type properties"
  ([?schema]
   (type-properties ?schema nil))
  ([?schema options]
   (-type-properties (-parent (schema ?schema options)))))

(defn properties-schema
  "Returns properties schema for Schema or IntoSchema."
  ([?schema]
   (properties-schema ?schema nil))
  ([?schema options]
   (if (into-schema? ?schema)
     (some-> ?schema (-properties-schema options) schema)
     (some-> (schema ?schema options) -parent (-properties-schema options)))))

(defn children-schema
  "Returns children schema for Schema or IntoSchema."
  ([?schema]
   (children-schema ?schema nil))
  ([?schema options]
   (if (into-schema? ?schema)
     (some-> ?schema (-children-schema options) schema)
     (some-> (schema ?schema options) -parent (-children-schema options)))))

;;
;; schema
;;

(defn schema?
  "Checks if x is a Schema instance"
  [x] (#?(:clj instance?, :cljs implements?) malli.core.Schema x))

(defn schema
  "Creates a Schema object from any of the following:

   - Schema instance (just returns it)
   - IntoSchema instance
   - Schema vector syntax, e.g. [:string {:min 1}]
   - Qualified Keyword or String, using a registry lookup"
  ([?schema]
   (schema ?schema nil))
  ([?schema options]
   (cond
     (schema? ?schema) ?schema
     (into-schema? ?schema) (-into-schema ?schema nil nil options)
     (vector? ?schema) (let [v #?(:clj ^IPersistentVector ?schema, :cljs ?schema)
                             t (-lookup! #?(:clj (.nth v 0), :cljs (nth v 0)) into-schema? true options)
                             n #?(:bb (count v) :clj (.count v), :cljs (count v))
                             ?p (when (> n 1) #?(:clj (.nth v 1), :cljs (nth v 1)))]
                         (if (or (nil? ?p) (map? ?p))
                           (into-schema t ?p (when (< 2 n) (subvec ?schema 2 n)) options)
                           (into-schema t nil (when (< 1 n) (subvec ?schema 1 n)) options)))
     :else (if-let [?schema' (and (-reference? ?schema) (-lookup ?schema options))]
             (-pointer ?schema (schema ?schema' options) options)
             (-> ?schema (-lookup! nil false options) (recur options))))))

(defn form
  "Returns the Schema form"
  ([?schema]
   (form ?schema nil))
  ([?schema options]
   (-form (schema ?schema options))))

(defn properties
  "Returns the Schema properties"
  ([?schema]
   (properties ?schema nil))
  ([?schema options]
   (-properties (schema ?schema options))))

(defn options
  "Returns options used in creating the Schema"
  ([?schema]
   (options ?schema nil))
  ([?schema options]
   (-options (schema ?schema options))))

(defn children
  "Returns the Schema children with all Child Schemas resolved. For
  `MapEntry` Schemas, returns a always tuple3 of `key ?properties child`"
  ([?schema]
   (children ?schema nil))
  ([?schema options]
   (let [schema (schema ?schema options)]
     (-children schema))))

(defn parent
  "Returns the IntoSchema instance that created the Schema"
  ([?schema]
   (parent ?schema nil))
  ([?schema options]
   (-parent (schema ?schema options))))

(defn walk
  "Postwalks recursively over the Schema and it's children.
   The walker callback is a arity4 function with the following
   arguments: schema, path, (walked) children and options."
  ([?schema f]
   (walk ?schema f nil))
  ([?schema f options]
   (-walk
    (schema ?schema options)
    (reify Walker
      (-accept [_ s _ _] s)
      (-inner [this s p options] (-walk s this p options))
      (-outer [_ s p c options] (f s p c options)))
    [] options)))

(defn validator
  "Returns an pure validation function of type `x -> boolean` for a given Schema.
   Caches the result for [[Cached]] Schemas with key `:validator`."
  ([?schema]
   (validator ?schema nil))
  ([?schema options]
   (-cached (schema ?schema options) :validator -validator)))

(defn validate
  "Returns true if value is valid according to given schema. Creates the `validator`
   for every call. When performance matters, (re-)use `validator` instead."
  ([?schema value]
   (validate ?schema value nil))
  ([?schema value options]
   ((validator ?schema options) value)))

(defn explainer
  "Returns an pure explainer function of type `x -> explanation` for a given Schema.
   Caches the result for [[Cached]] Schemas with key `:explainer`."
  ([?schema]
   (explainer ?schema nil))
  ([?schema options]
   (let [schema' (schema ?schema options)
         explainer' (-cached schema' :explainer #(-explainer % []))]
     (fn explainer
       ([value]
        (explainer value [] []))
       ([value in acc]
        (when-let [errors (seq (explainer' value in acc))]
          {:schema schema'
           :value value
           :errors errors}))))))

(defn explain
  "Explains a value against a given schema. Creates the `explainer` for every call.
   When performance matters, (re-)use `explainer` instead."
  ([?schema value]
   (explain ?schema value nil))
  ([?schema value options]
   ((explainer ?schema options) value [] [])))

(defn parser
  "Returns an pure parser function of type `x -> either parsed-x ::invalid` for a given Schema.
   Caches the result for [[Cached]] Schemas with key `:parser`."
  ([?schema]
   (parser ?schema nil))
  ([?schema options]
   (-cached (schema ?schema options) :parser -parser)))

(defn parse
  "parses a value against a given schema. Creates the `parser` for every call.
   When performance matters, (re-)use `parser` instead."
  ([?schema value]
   (parse ?schema value nil))
  ([?schema value options]
   ((parser ?schema options) value)))

(defn unparser
  "Returns an pure unparser function of type `parsed-x -> either x ::invalid` for a given Schema.
   Caches the result for [[Cached]] Schemas with key `:unparser`."
  ([?schema]
   (unparser ?schema nil))
  ([?schema options]
   (-cached (schema ?schema options) :unparser -unparser)))

(defn unparse
  "Unparses a value against a given schema. Creates the `unparser` for every call.
   When performance matters, (re-)use `unparser` instead."
  ([?schema value]
   (unparse ?schema value nil))
  ([?schema value options]
   ((unparser ?schema options) value)))

(defn decoder
  "Creates a value decoding function given a transformer and a schema."
  ([?schema t]
   (decoder ?schema nil t))
  ([?schema options t]
   (or (-transformer (schema ?schema options) (-into-transformer t) :decode options)
       identity)))

(defn decode
  "Transforms a value with a given decoding transformer against a schema."
  ([?schema value t]
   (decode ?schema value nil t))
  ([?schema value options t]
   (if-let [transform (decoder ?schema options t)]
     (transform value)
     value)))

(defn encoder
  "Creates a value encoding transformer given a transformer and a schema."
  ([?schema t]
   (encoder ?schema nil t))
  ([?schema options t]
   (or (-transformer (schema ?schema options) (-into-transformer t) :encode options)
       identity)))

(defn encode
  "Transforms a value with a given encoding transformer against a schema."
  ([?schema value t]
   (encode ?schema value nil t))
  ([?schema value options t]
   (if-let [transform (encoder ?schema options t)]
     (transform value)
     value)))

(defn coercer
  "Creates a function to decode and validate a value, throws on validation error."
  ([?schema] (coercer ?schema nil nil))
  ([?schema transformer] (coercer ?schema transformer nil))
  ([?schema transformer options] (coercer ?schema transformer nil nil options))
  ([?schema transformer respond raise] (coercer ?schema transformer respond raise nil))
  ([?schema transformer respond raise options]
   (let [s (schema ?schema options)
         valid? (validator s)
         decode (decoder s transformer)
         explain (explainer s)
         respond (or respond identity)
         raise (or raise #(-fail! ::invalid-input %))]
     (fn -coercer [x] (let [value (decode x)]
                        (if (valid? value)
                          (respond value)
                          (raise {:value value, :schema s, :explain (explain value)})))))))

(defn coerce
  "Decode and validate a value, throws on validation error."
  ([?schema value] (coerce ?schema value nil nil))
  ([?schema value transformer] (coerce ?schema value transformer nil))
  ([?schema value transformer options] (coerce ?schema value transformer nil nil options))
  ([?schema value transformer respond raise] (coerce ?schema value transformer respond raise nil))
  ([?schema value transformer respond raise options] ((coercer ?schema transformer respond raise options) value)))

(defn entries
  "Returns `EntrySchema` children as a sequence of `clojure.lang/MapEntry`s
   where the values child schemas wrapped in `:malli.core/val` Schemas,
   with the entry properties as properties.

   Using `entries` enable usage of entry properties in walking and value
   transformation.

      (def schema
        [:map
         [:x int?]
         [:y {:optional true} int?]])

      (m/children schema)
      ; [[:x nil int?]
      ;  [:y {:optional true} int?]]

      (m/entries schema)
      ; [[:x [:malli.core/val int?]]
      ;  [:y [:malli.core/val {:optional true} int?]]]

      (map key (m/entries schema))
      ; (:x :y)"
  ([?schema]
   (entries ?schema nil))
  ([?schema options]
   (when-let [schema (schema ?schema options)]
     (when (-entry-schema? schema) (-entries schema)))))

(defn explicit-keys
  "Returns a vector of explicit (not ::m/default) keys from EntrySchema"
  ([?schema] (explicit-keys ?schema nil))
  ([?schema options]
   (let [schema (schema ?schema options)]
     (when (-entry-schema? schema)
       (reduce
        (fn [acc [k :as e]] (cond-> acc (not (-default-entry e)) (conj k)))
        [] (-entries schema))))))

(defn default-schema
  "Returns the default (::m/default) schema from EntrySchema"
  ([?schema] (default-schema ?schema nil))
  ([?schema options]
   (let [schema (schema ?schema options)]
     (when (-entry-schema? schema)
       (-default-entry-schema (-children schema))))))

(defn deref
  "Derefs top-level `RefSchema`s or returns original Schema."
  ([?schema]
   (deref ?schema nil))
  ([?schema options]
   (let [schema (schema ?schema options)]
     (cond-> schema (-ref-schema? schema) (-deref)))))

(defn deref-all
  "Derefs top-level `RefSchema`s recursively or returns original Schema."
  ([?schema]
   (deref-all ?schema nil))
  ([?schema options]
   (let [schema (deref ?schema options)]
     (cond-> schema (-ref-schema? schema) (recur options)))))

(defn from-ast
  "Creates a Schema from AST"
  ([?ast] (from-ast ?ast nil))
  ([?ast options]
   (cond
     (schema? ?ast) ?ast
     (map? ?ast) (if-let [s (-lookup (:type ?ast) options)]
                   (let [r (when-let [r (:registry ?ast)] (-delayed-registry r from-ast))
                         options (cond-> options r (-update :registry #(mr/composite-registry r (or % (-registry options)))))
                         ast (cond-> ?ast r (-update :properties #(assoc % :registry (-property-registry r options identity))))]
                     (cond (and (into-schema? s) (-ast? s)) (-from-ast s ast options)
                           (into-schema? s) (-into-schema s (:properties ast) (-vmap #(from-ast % options) (:children ast)) options)
                           :else s))
                   (-fail! ::invalid-ast {:ast ?ast}))
     :else (-fail! ::invalid-ast {:ast ?ast}))))

(defn ast
  "Returns the Schema AST"
  ([?schema] (ast ?schema nil))
  ([?schema options]
   (let [s (schema ?schema options)]
     (if (-ast? s)
       (-to-ast s options)
       (let [c (-children s)]
         (-ast (cond-> {:type (type s)}
                 c (assoc :children (-vmap #(ast % options) c)))
               (-properties s)
               (-options s)))))))
;;
;; eval
;;

(defn -default-sci-options []
  {:preset :termination-safe
   :aliases {'str 'clojure.string}
   :namespaces {'malli.core {'properties properties
                             'type type
                             'children children
                             'entries entries}}})

(let [-fail! #(-fail! ::sci-not-available {:code %})
      -eval? #(or (symbol? %) (string? %) (sequential? %))
      -evaluator (memoize ms/evaluator)]
  (defn eval
    ([?code] (eval ?code nil))
    ([?code options]
     (cond (vector? ?code) ?code
           (-eval? ?code) (if (::disable-sci options)
                            (-fail! ?code)
                            (((-evaluator (or (::sci-options options) (-default-sci-options)) -fail!)) ?code))
           :else ?code))))

;;
;; schema walker
;;

(defn schema-walker [f]
  (fn [schema _ children _]
    (f (-set-children schema children))))

;;
;; registry
;;

(defn predicate-schemas []
  (let [-safe-empty? (fn [x] (and (seqable? x) (empty? x)))]
    (->> [#'any? #'some? #'number? #'integer? #'int? #'pos-int? #'neg-int? #'nat-int? #'pos? #'neg? #'float? #'double?
          #'boolean? #'string? #'ident? #'simple-ident? #'qualified-ident? #'keyword? #'simple-keyword?
          #'qualified-keyword? #'symbol? #'simple-symbol? #'qualified-symbol? #'uuid? #'uri? #'inst? #'seqable?
          #'indexed? #'map? #'vector? #'list? #'seq? #'char? #'set? #'nil? #'false? #'true?
          #'zero? #'coll? [#'empty? -safe-empty?] #'associative? #'sequential? #'ifn? #'fn?
          #?@(:clj [#'rational? #'ratio? #'bytes? #'decimal?])]
         (reduce -register-var {}))))

(defn class-schemas []
  {#?(:clj  Pattern,
      ;; closure will complain if you reference the global RegExp object.
      :cljs (c/type #"")) (-re-schema true)})

(defn comparator-schemas []
  (->> {:> >, :>= >=, :< <, :<= <=, := =, :not= not=}
       (-vmap (fn [[k v]] [k (-simple-schema {:type k :from-ast -from-value-ast :to-ast -to-value-ast :min 1 :max 1
                                              :compile (fn [_ [child] _] {:pred (-safe-pred #(v % child))})})]))
       (into {}) (reduce-kv assoc nil)))

(defn type-schemas []
  {:any (-any-schema)
   :some (-some-schema)
   :nil (-nil-schema)
   :string (-string-schema)
   :int (-int-schema)
   :double (-double-schema)
   :boolean (-boolean-schema)
   :keyword (-keyword-schema)
   :symbol (-symbol-schema)
   :qualified-keyword (-qualified-keyword-schema)
   :qualified-symbol (-qualified-symbol-schema)
   :uuid (-uuid-schema)})

(defn sequence-schemas []
  {:+ (-sequence-schema {:type :+, :child-bounds {:min 1, :max 1}
                         :re-validator (fn [_ [child]] (re/+-validator child))
                         :re-explainer (fn [_ [child]] (re/+-explainer child))
                         :re-parser (fn [_ [child]] (re/+-parser child))
                         :re-unparser (fn [_ [child]] (re/+-unparser child))
                         :re-transformer (fn [_ [child]] (re/+-transformer child))
                         :re-min-max (fn [_ [child]] {:min (:min (-regex-min-max child true))})})
   :* (-sequence-schema {:type :*, :child-bounds {:min 1, :max 1}
                         :re-validator (fn [_ [child]] (re/*-validator child))
                         :re-explainer (fn [_ [child]] (re/*-explainer child))
                         :re-parser (fn [_ [child]] (re/*-parser child))
                         :re-unparser (fn [_ [child]] (re/*-unparser child))
                         :re-transformer (fn [_ [child]] (re/*-transformer child))
                         :re-min-max (fn [_ _] {:min 0})})
   :? (-sequence-schema {:type :?, :child-bounds {:min 1, :max 1}
                         :re-validator (fn [_ [child]] (re/?-validator child))
                         :re-explainer (fn [_ [child]] (re/?-explainer child))
                         :re-parser (fn [_ [child]] (re/?-parser child))
                         :re-unparser (fn [_ [child]] (re/?-unparser child))
                         :re-transformer (fn [_ [child]] (re/?-transformer child))
                         :re-min-max (fn [_ [child]] {:min 0, :max (:max (-regex-min-max child true))})})
   :repeat (-sequence-schema {:type :repeat, :child-bounds {:min 1, :max 1}
                              :re-validator (fn [{:keys [min max] :or {min 0, max ##Inf}} [child]] (re/repeat-validator min max child))
                              :re-explainer (fn [{:keys [min max] :or {min 0, max ##Inf}} [child]] (re/repeat-explainer min max child))
                              :re-parser (fn [{:keys [min max] :or {min 0, max ##Inf}} [child]] (re/repeat-parser min max child))
                              :re-unparser (fn [{:keys [min max] :or {min 0, max ##Inf}} [child]] (re/repeat-unparser min max child))
                              :re-transformer (fn [{:keys [min max] :or {min 0, max ##Inf}} [child]] (re/repeat-transformer min max child))
                              :re-min-max (fn [props [child]] (-re-min-max * props child))})
   :cat (-sequence-schema {:type :cat, :child-bounds {}
                           :re-validator (fn [_ children] (apply re/cat-validator children))
                           :re-explainer (fn [_ children] (apply re/cat-explainer children))
                           :re-parser (fn [_ children] (apply re/cat-parser children))
                           :re-unparser (fn [_ children] (apply re/cat-unparser children))
                           :re-transformer (fn [_ children] (apply re/cat-transformer children))
                           :re-min-max (fn [_ children] (reduce (partial -re-min-max +) {:min 0, :max 0} children))})
   :alt (-sequence-schema {:type :alt, :child-bounds {:min 1}
                           :re-validator (fn [_ children] (apply re/alt-validator children))
                           :re-explainer (fn [_ children] (apply re/alt-explainer children))
                           :re-parser (fn [_ children] (apply re/alt-parser children))
                           :re-unparser (fn [_ children] (apply re/alt-unparser children))
                           :re-transformer (fn [_ children] (apply re/alt-transformer children))
                           :re-min-max (fn [_ children] (reduce -re-alt-min-max {:max 0} children))})
   :catn (-sequence-entry-schema {:type :catn, :child-bounds {}
                                  :re-validator (fn [_ children] (apply re/cat-validator children))
                                  :re-explainer (fn [_ children] (apply re/cat-explainer children))
                                  :re-parser (fn [_ children] (apply re/catn-parser children))
                                  :re-unparser (fn [_ children] (apply re/catn-unparser children))
                                  :re-transformer (fn [_ children] (apply re/cat-transformer children))
                                  :re-min-max (fn [_ children] (reduce (partial -re-min-max +) {:min 0, :max 0} (-vmap last children)))})
   :altn (-sequence-entry-schema {:type :altn, :child-bounds {:min 1}
                                  :re-validator (fn [_ children] (apply re/alt-validator children))
                                  :re-explainer (fn [_ children] (apply re/alt-explainer children))
                                  :re-parser (fn [_ children] (apply re/altn-parser children))
                                  :re-unparser (fn [_ children] (apply re/altn-unparser children))
                                  :re-transformer (fn [_ children] (apply re/alt-transformer children))
                                  :re-min-max (fn [_ children] (reduce -re-alt-min-max {:max 0} (-vmap last children)))})})

(defn base-schemas []
  {:and (-and-schema)
   :or (-or-schema)
   :orn (-orn-schema)
   :not (-not-schema)
   :map (-map-schema)
   :map-of (-map-of-schema)
   :vector (-collection-schema {:type :vector, :pred vector?, :empty []})
   :sequential (-collection-schema {:type :sequential, :pred sequential?})
   :set (-collection-schema {:type :set, :pred set?, :empty #{}, :in (fn [_ x] x)})
   :enum (-enum-schema)
   :maybe (-maybe-schema)
   :tuple (-tuple-schema)
   :multi (-multi-schema)
   :re (-re-schema false)
   :fn (-fn-schema)
   :ref (-ref-schema)
   :=> (-=>-schema)
   :function (-function-schema nil)
   :schema (-schema-schema nil)
   ::schema (-schema-schema {:raw true})})

(defn default-schemas []
  (merge (predicate-schemas) (class-schemas) (comparator-schemas) (type-schemas) (sequence-schemas) (base-schemas)))

(def default-registry
  (let [strict (identical? mr/mode "strict")
        registry (mr/fast-registry (if (identical? mr/type "custom") {} (default-schemas)))]
    (when-not strict (mr/set-default-registry! registry))
    (mr/registry (if strict registry (mr/custom-default-registry)))))

;;
;; function schemas
;;

(defonce ^:private -function-schemas* (atom {}))
(defn function-schemas ([] (function-schemas :clj)) ([key] (@-function-schemas* key)))

(defn -deregister-function-schemas! [key] (swap! -function-schemas* assoc key {}))

(defn -deregister-metadata-function-schemas!
  [key]
  (swap! -function-schemas* update key
         (fn [fn-schemas-map]
           (reduce-kv (fn [acc ns-sym fn-map]
                        (assoc acc ns-sym
                               (reduce-kv
                                (fn [acc2 fn-sym fn-map]
                                  ;; rm metadata schemas
                                  (if (:metadata-schema? fn-map)
                                    acc2
                                    (assoc acc2 fn-sym fn-map)))
                                {}
                                fn-map)))
                      {}
                      fn-schemas-map))))

(defn function-schema
  ([?schema] (function-schema ?schema nil))
  ([?schema options]
   (let [s (schema ?schema options), t (type s)]
     (if (#{:=> :function} t) s (-fail! ::invalid-=>schema {:type t, :schema s})))))

;; for cljs we cannot invoke `function-schema` at macroexpansion-time
;; - `?schema` could contain cljs vars that will only resolve at runtime.
(defn -register-function-schema!
  ([ns name ?schema data] (-register-function-schema! ns name ?schema data :clj function-schema))
  ([ns name ?schema data key f]
   (try
     (swap! -function-schemas* assoc-in [key ns name] (merge data {:schema (f ?schema), :ns ns, :name name}))
     (catch #?(:clj Throwable :cljs :default) ex
       (throw (ex-info
               (str "Schema error when insrumenting function: " ns "/" name " - " (ex-message ex))
               (ex-data ex)))))))

#?(:clj
   (defmacro => [given-sym value]
     (let [cljs-resolve (when (:ns &env) (ns-resolve 'cljs.analyzer.api 'resolve))
           cljs-resolve-symbols (fn [env d]
                                  (walk/postwalk (fn [x] (cond->> x (symbol? x) (or (:name (cljs-resolve env x)))))
                                                 d))
           name-str (name given-sym)
           ns-str (str (or (not-empty (namespace given-sym)) *ns*))
           name' `'~(symbol name-str)
           ns' `'~(symbol ns-str)
           sym `'~(symbol ns-str name-str)
           value' (cond->> value (:ns &env) (cljs-resolve-symbols &env))]
       ;; in cljs we need to register the schema in clojure (the cljs compiler)
       ;; so it is visible in the (function-schemas :cljs) map at macroexpansion time.
       (if (:ns &env)
         (do
           (-register-function-schema! (symbol ns-str) (symbol name-str) value' (meta given-sym) :cljs identity)
           `(do (-register-function-schema! ~ns' ~name' ~value' ~(meta given-sym) :cljs identity) ~sym))
         `(do (-register-function-schema! ~ns' ~name' ~value' ~(meta given-sym)) ~sym)))))

(defn -instrument
  "Takes an instrumentation properties map and a function and returns a wrapped function,
   which will validate function arguments and return values based on the function schema
   definition. The following properties are used:

   | key       | description |
   | ----------|-------------|
   | `:schema` | function schema
   | `:scope`  | optional set of scope definitions, defaults to `#{:input :output}`
   | `:report` | optional side-effecting function of `key data -> any` to report problems, defaults to `m/-fail!`
   | `:gen`    | optional function of `schema -> schema -> value` to be invoked on the args to get the return value"
  ([props]
   (-instrument props nil nil))
  ([props f]
   (-instrument props f nil))
  ([{:keys [scope report gen] :or {scope #{:input :output}, report -fail!} :as props} f options]
   (let [schema (-> props :schema (schema options))]
     (case (type schema)
       :=> (let [{:keys [min max input output]} (-function-info schema)
                 [validate-input validate-output] (-vmap validator [input output])
                 [wrap-input wrap-output] (-vmap (partial contains? scope) [:input :output])
                 f (or (if gen (gen schema) f) (-fail! ::missing-function {:props props}))]
             (fn [& args]
               (let [args (vec args), arity (count args)]
                 (when wrap-input
                   (when-not (<= min arity (or max miu/+max-size+))
                     (report ::invalid-arity {:arity arity, :arities #{{:min min :max max}}, :args args, :input input, :schema schema}))
                   (when-not (validate-input args)
                     (report ::invalid-input {:input input, :args args, :schema schema})))
                 (let [value (apply f args)]
                   (when wrap-output
                     (when-not (validate-output value)
                       (report ::invalid-output {:output output, :value value, :args args, :schema schema})))
                   value))))
       :function (let [arity->info (->> (children schema)
                                        (map (fn [s] (assoc (-function-info s) :f (-instrument (assoc props :schema s) f options))))
                                        (-group-by-arity!))
                       arities (-> arity->info keys set)
                       varargs-info (arity->info :varargs)]
                   (if (= 1 (count arities))
                     (-> arity->info first val :f)
                     (fn [& args]
                       (let [arity (count args)
                             {:keys [input] :as info} (arity->info arity)
                             report-arity #(report ::invalid-arity {:arity arity, :arities arities, :args args, :input input, :schema schema})]
                         (cond
                           info (apply (:f info) args)
                           varargs-info (if (< arity (:min varargs-info)) (report-arity) (apply (:f varargs-info) args))
                           :else (report-arity))))))))))
(ns malli.util
  (:refer-clojure :exclude [merge select-keys find get get-in dissoc assoc update assoc-in update-in keys])
  (:require [clojure.core :as c]
            [malli.core :as m]))

(declare path->in)

(defn ^:no-doc equals
  ([?schema1 ?schema2]
   (equals ?schema1 ?schema2 nil))
  ([?schema1 ?schema2 options]
   (= (m/form ?schema1 options) (m/form ?schema2 options))))

(defn -simplify-map-entry [[k ?p s]]
  (cond
    (not s) [k ?p]
    (and ?p (false? (:optional ?p)) (= 1 (count ?p))) [k s]
    (not (seq ?p)) [k s]
    (false? (:optional ?p)) [k (c/dissoc ?p :optional) s]
    :else [k ?p s]))

(defn -required-map-entry? [[_ ?p]]
  (not (and (map? ?p) (true? (:optional ?p)))))

(defn- -entry [[k ?p1 s1 :as e1] [_ ?p2 s2 :as e2] merge-required merge options]
  (let [required (merge-required (-required-map-entry? e1) (-required-map-entry? e2))
        p (c/merge ?p1 ?p2)]
    (-simplify-map-entry [k (c/assoc p :optional (not required)) (merge s1 s2 options)])))

(defn- -ok-to-close-or-open? [schema options]
  (and (= :map (m/type schema options)) (-> schema m/properties :closed false? not)))

;;
;; public api
;;

(defn find-first
  "Prewalks the Schema recursively with a 3-arity fn [schema path options], returns with
  and as soon as the function returns non-null value."
  ([?schema f]
   (find-first ?schema f nil))
  ([?schema f options]
   (let [result (atom nil)]
     (m/-walk
      (m/schema ?schema options)
      (reify m/Walker
        (-accept [_ s path options] (not (or @result (reset! result (f s path options)))))
        (-inner [this s path options] (when-not @result (m/-walk s this path options)))
        (-outer [_ _ _ _ _]))
      [] options)
     @result)))

(defn merge
  "Merges two schemas into one with the following rules:

  * if either schemas is `nil`, the other one is used, regardless of value
  * with two :map schemas, both keys and values are merged
  * for :and schemas, the first child is used in merge, rest kept as-is
  * with two :map entries, `:merge-entries` fn is used (default last one wins)
  * with any other schemas, `:merge-default` fn is used (default last one wins)

  | key               | description
  | ------------------|-------------
  | `:merge-default`  | `schema1 schema2 options -> schema` fn to merge unknown entries
  | `:merge-required` | `boolean boolean -> boolean` fn to resolve how required keys are merged"
  ([?schema1 ?schema2]
   (merge ?schema1 ?schema2 nil))
  ([?schema1 ?schema2 options]
   (let [s1 (when ?schema1 (m/deref-all (m/schema ?schema1 options)))
         s2 (when ?schema2 (m/deref-all (m/schema ?schema2 options)))
         t1 (when s1 (m/type s1))
         t2 (when s2 (m/type s2))
         {:keys [merge-default merge-required]
          :or {merge-default (fn [_ s2 _] s2)
               merge-required (fn [_ r2] r2)}} options
         bear (fn [p1 p2] (if (and p1 p2) (c/merge p1 p2) (or p1 p2)))
         tear (fn [t s] (if (= :map t) [nil s] (concat [(m/properties s)] (m/children s))))
         join (fn [[p1 c1 & cs1] [p2 c2 & cs2]]
                (m/into-schema :and (bear p1 p2) (concat [(merge c1 c2 options)] cs1 cs2) options))]
     (cond
       (nil? s1) s2
       (nil? s2) s1
       (not (and (-> t1 #{:map :and}) (-> t2 #{:map :and}))) (merge-default s1 s2 options)
       (not (and (-> t1 (= :map)) (-> t2 (= :map)))) (join (tear t1 s1) (tear t2 s2))
       :else (let [p (bear (m/-properties s1) (m/-properties s2))
                   ks (atom #{})
                   children (reduce (fn [form [k2 :as e2]]
                                      (if (@ks k2)
                                        (reduce (fn [acc' [k1 :as e1]]
                                                  (conj acc' (if (= k1 k2)
                                                               (-entry e1 e2 merge-required merge options)
                                                               e1))) [] form)
                                        (do (swap! ks conj k2) (conj form e2))))
                                    [] (into (m/-children s1) (m/-children s2)))]
               (m/into-schema :map p children options))))))

(defn union
  "Union of two schemas. See [[merge]] for more details."
  ([?schema1 ?schema2]
   (union ?schema1 ?schema2 nil))
  ([?schema1 ?schema2 options]
   (let [merge-default (fn [s1 s2 options] (if (equals s1 s2) s1 (m/schema [:or s1 s2] options)))
         merge-required (fn [r1 r2] (and r1 r2))]
     (merge ?schema1 ?schema2 (-> options
                                  (c/update :merge-default (fnil identity merge-default))
                                  (c/update :merge-required (fnil identity merge-required)))))))

(defn update-properties
  "Returns a Schema instance with updated properties."
  [?schema f & args]
  (let [schema (m/schema ?schema)]
    (m/-set-properties schema (not-empty (apply f (m/-properties schema) args)))))

(defn closed-schema
  "Maps are implicitly open by default. They can be explicitly closed or
  open by specifying the `{:closed (true|false)}` property.

  This function converts implicitly open maps to explicitly closed
  maps, recursively. Explicitly open maps are left untouched.

  See [[open-schema]]"
  ([?schema]
   (closed-schema ?schema nil))
  ([?schema options]
   (m/walk
    ?schema
    (m/schema-walker
     (fn [schema]
       (if (-ok-to-close-or-open? schema options)
         (update-properties schema c/assoc :closed true)
         schema)))
    options)))

(defn open-schema
  "Maps are implicitly open by default. They can be explicitly closed or
  open by specifying the `{:closed (true|false)}` property.

  This function converts explicitly closed maps to implicitly open
  maps, recursively. Explicitly open maps are left untouched.

  See [[closed-schema]]"
  ([?schema]
   (open-schema ?schema nil))
  ([?schema options]
   (m/walk
    ?schema
    (m/schema-walker
     (fn [schema]
       (if (-ok-to-close-or-open? schema options)
         (update-properties schema c/dissoc :closed)
         schema)))
    options)))

(defn subschemas
  "Returns all subschemas for unique paths as a vector of maps with :schema, :path and :in keys.
   Walks over :schema references and top-level :refs. See [[malli.core/-walk]] for all options."
  ([?schema]
   (subschemas ?schema nil))
  ([?schema options]
   (let [schema (m/schema ?schema options)
         options (let [ref (and (= :ref (m/type schema)) (m/-ref schema))]
                   (-> options
                       (clojure.core/update ::m/walk-schema-refs (fnil identity true))
                       (clojure.core/update ::m/walk-refs (fn [f] #(or (= ref %) ((m/-boolean-fn f) %))))))
         state (atom [])]
     (find-first schema (fn [s p _] (swap! state conj {:path p, :in (path->in schema p), :schema s}) nil) options)
     @state)))

(defn distinct-by
  "Returns a sequence of distinct (f x) values)"
  [f coll]
  (let [seen (atom #{})]
    (filter (fn [x] (let [v (f x)] (when-not (@seen v) (swap! seen conj v)))) coll)))

(defn path->in
  "Returns a value path for a given Schema and schema path"
  [schema path]
  (loop [i 0, s schema, acc []]
    (or (and (>= i (count path)) acc)
        (recur (inc i) (m/-get s (path i) nil) (cond-> acc (m/-keep s) (conj (path i)))))))

(defn in->paths
  "Returns a vector of schema paths for a given Schema and value path"
  [schema in]
  (let [state (atom [])
        in-equals (fn [[x & xs] [y & ys]] (cond (and x (= x y)) (recur xs ys), (= x y) true, (= ::m/in x) (recur xs ys)))
        parent-exists (fn [v1 v2] (let [i (min (count v1) (count v2))] (= (subvec v1 0 i) (subvec v2 0 i))))]
    (find-first
     schema
     (fn [_ path _]
       (when (and (in-equals (path->in schema path) in) (not (some #(parent-exists path %) @state)))
         (swap! state conj path) nil)))
    @state))

(defn data-explainer
  "Like `m/explainer` but output is pure clojure data. Schema objects have been replaced with their m/form.
   Useful when you need to serialise errrors."
  ([?schema]
   (data-explainer ?schema nil))
  ([?schema options]
   (let [explainer' (m/explainer ?schema options)]
     (fn data-explainer
       ([value]
        (data-explainer value [] []))
       ([value in acc]
        (some-> (explainer' value in acc)
                (c/update :schema m/form)
                (c/update :errors (partial mapv #(c/update % :schema m/form)))))))))

(defn explain-data
  "Explains a value against a given schema. Like `m/explain` but output is pure clojure data.
  Schema objects have been replaced with their `m/form`. Useful when you need to serialise errrors.

  Creates the `mu/data-explainer` for every call. When performance matters, (re-)use `mu/data-explainer` instead."
  ([?schema value]
   (explain-data ?schema value nil))
  ([?schema value options]
   ((data-explainer ?schema options) value [] [])))

;;
;; EntrySchemas
;;

(defn transform-entries
  "Transforms entries with f."
  ([?schema f]
   (transform-entries ?schema f nil))
  ([?schema f options]
   (let [schema (m/deref-all (m/schema ?schema options))]
     (m/into-schema (m/-parent schema) (m/-properties schema) (f (m/-children schema)) (or (m/options schema) options)))))

(defn optional-keys
  "Makes map keys optional."
  ([?schema]
   (optional-keys ?schema nil nil))
  ([?schema ?keys]
   (let [[keys options] (if (map? ?keys) [nil ?keys] [?keys nil])]
     (optional-keys ?schema keys options)))
  ([?schema keys options]
   (let [accept (if keys (set keys) (constantly true))
         mapper (fn [[k :as e]] (if (accept k) (c/update e 1 c/assoc :optional true) e))]
     (transform-entries ?schema #(map mapper %) options))))

(defn required-keys
  "Makes map keys required."
  ([?schema]
   (required-keys ?schema nil nil))
  ([?schema ?keys]
   (let [[keys options] (if (map? ?keys) [nil ?keys] [?keys nil])]
     (required-keys ?schema keys options)))
  ([?schema keys options]
   (let [accept (if keys (set keys) (constantly true))
         required (fn [p] (let [p' (c/dissoc p :optional)] (when (seq p') p')))
         mapper (fn [[k :as e]] (if (accept k) (c/update e 1 required) e))]
     (transform-entries ?schema #(map mapper %) options))))

(defn select-keys
  "Like [[clojure.core/select-keys]], but for EntrySchemas."
  ([?schema keys]
   (select-keys ?schema keys nil))
  ([?schema keys options]
   (let [key-set (set keys)]
     (transform-entries ?schema #(filter (fn [[k]] (key-set k)) %) options))))

(defn rename-keys
  "Like [[clojure.set/rename-keys]], but for EntrySchemas. Collisions are resolved in favor of the renamed key, like `assoc`-ing."
  ([?schema kmap]
   (rename-keys ?schema kmap nil))
  ([?schema kmap options]
   (transform-entries
    ?schema
    (fn [entries]
      (let [source-keys (set (c/keys kmap))
            target-keys (set (vals kmap))
            remove-conflicts (fn [[k]] (or (source-keys k) (not (target-keys k))))
            alter-keys (fn [[k m v]] [(c/get kmap k k) m v])]
        (->> entries (filter remove-conflicts) (map alter-keys))))
    options)))

(defn dissoc
  "Like [[clojure.core/dissoc]], but for EntrySchemas."
  ([?schema key]
   (dissoc ?schema key nil))
  ([?schema key options]
   (transform-entries ?schema #(remove (fn [[k]] (= key k)) %) options)))

(defn find
  "Like [[clojure.core/find]], but for EntrySchemas."
  ([?schema k]
   (find ?schema k nil))
  ([?schema k options]
   (let [schema (m/schema (or ?schema :map) options)]
     (when schema (m/-get schema [::m/find k] nil)))))

(defn keys
  "Like [[clojure.core/keys]], but for EntrySchemas."
  [?schema]
  (when-let [ents (m/entries ?schema)]
    (for [[k _] ents]
      k)))

;;
;; LensSchemas
;;

(defn get
  "Like [[clojure.core/get]], but for LensSchemas."
  ([?schema k]
   (get ?schema k nil nil))
  ([?schema k default]
   (get ?schema k default nil))
  ([?schema k default options]
   (let [schema (m/schema (or ?schema :map) options)]
     (when schema (m/-get schema k default)))))

(defn assoc
  "Like [[clojure.core/assoc]], but for LensSchemas."
  ([?schema key value]
   (assoc ?schema key value nil))
  ([?schema key value options]
   (m/-set (m/schema ?schema options) key value)))

(defn update
  "Like [[clojure.core/update]], but for LensSchema instances."
  [schema key f & args]
  (m/-set (m/schema schema) key (apply f (get schema key) args)))

(defn get-in
  "Like [[clojure.core/get-in]], but for LensSchemas."
  ([?schema ks]
   (get-in ?schema ks nil nil))
  ([?schema ks default]
   (get-in ?schema ks default nil))
  ([?schema [k & ks] default options]
   (let [schema (m/schema (or ?schema :map) options)]
     (if-not k
       schema
       (let [sentinel #?(:clj (Object.), :cljs (js-obj))
             schema (get schema k sentinel)]
         (cond
           (identical? schema sentinel) default
           ks (get-in schema ks default)
           :else schema))))))

(defn assoc-in
  "Like [[clojure.core/assoc-in]], but for LensSchemas."
  ([?schema ks value]
   (assoc-in ?schema ks value nil))
  ([?schema [k & ks] value options]
   (let [schema (m/schema ?schema options)]
     (assoc schema k (if ks (assoc-in (get schema k (m/schema :map (m/options schema))) ks value) value)))))

(defn update-in
  "Like [[clojure.core/update-in]], but for LensSchemas."
  [schema ks f & args]
  (letfn [(up [s [k & ks] f args]
            (assoc s k (if ks (up (get s k (m/schema :map (m/options schema))) ks f args)
                              (apply f (get s k) args))))]
    (up schema ks f args)))

;;
;; Schemas
;;

(defn -reducing [f]
  (fn [_ [first & rest :as children] options]
    (let [children (mapv #(m/schema % options) children)]
      [children (mapv m/form children) (reduce #(f %1 %2 options) first rest)])))

(defn -applying [f]
  (fn [_ children options]
    [(clojure.core/update children 0 #(m/schema % options))
     (clojure.core/update children 0 #(m/form % options))
     (apply f (conj children options))]))

(defn -util-schema [{:keys [type min max childs type-properties fn]}]
  ^{:type ::m/into-schema}
  (reify m/IntoSchema
    (-type [_] type)
    (-type-properties [_] type-properties)
    (-properties-schema [_ _])
    (-children-schema [_ _])
    (-into-schema [parent properties children options]
      (m/-check-children! type properties children min max)
      (let [[children forms schema] (fn properties (vec children) options)
            form (delay (m/-create-form type properties forms options))
            cache (m/-create-cache options)]
        ^{:type ::m/schema}
        (reify
          m/Schema
          (-validator [_] (m/-validator schema))
          (-explainer [_ path] (m/-explainer schema path))
          (-parser [_] (m/-parser schema))
          (-unparser [_] (m/-unparser schema))
          (-transformer [this transformer method options]
            (m/-parent-children-transformer this [schema] transformer method options))
          (-walk [this walker path options]
            (let [children (if childs (subvec children 0 childs) children)]
              (when (m/-accept walker this path options)
                (m/-outer walker this path (m/-inner-indexed walker path children options) options))))
          (-properties [_] properties)
          (-options [_] options)
          (-children [_] children)
          (-parent [_] parent)
          (-form [_] @form)
          m/Cached
          (-cache [_] cache)
          m/LensSchema
          (-keep [_])
          (-get [_ key default] (clojure.core/get children key default))
          (-set [_ key value] (m/into-schema type properties (clojure.core/assoc children key value)))
          m/RefSchema
          (-ref [_])
          (-deref [_] schema))))))

(defn -merge [] (-util-schema {:type :merge, :fn (-reducing merge)}))
(defn -union [] (-util-schema {:type :union, :fn (-reducing union)}))
(defn -select-keys [] (-util-schema {:type :select-keys, :childs 1, :min 2, :max 2, :fn (-applying select-keys)}))

(defn schemas [] {:merge (-merge)
                  :union (-union)
                  :select-keys (-select-keys)})
(ns malli.error
  (:require [clojure.string :as str]
            [malli.core :as m]
            [malli.util :as mu]))

(defn -pred-min-max-error-fn [{:keys [pred message]}]
  (fn [{:keys [schema value]} _]
    (let [{:keys [min max]} (m/properties schema)]
      (cond
        (not (pred value)) message
        (and min (= min max)) (str "should be " min)
        (and min max) (str "should be between " min " and " max)
        min (str "should be at least " min)
        max (str "should be at most " max)))))

(def default-errors
  {::unknown {:error/message {:en "unknown error"}}
   ::m/missing-key {:error/message {:en "missing required key"}}
   ::m/limits {:error/fn {:en (fn [{:keys [schema _value]} _]
                                (let [{:keys [min max]} (m/properties schema)]
                                  (cond
                                    (and min (= min max)) (str "should have " min " elements")
                                    (and min max) (str "should have between " min " and " max " elements")
                                    min (str "should have at least " min " elements")
                                    max (str "should have at most " max " elements"))))}}
   ::m/tuple-size {:error/fn {:en (fn [{:keys [schema value]} _]
                                    (let [size (count (m/children schema))]
                                      (str "invalid tuple size " (count value) ", expected " size)))}}
   ::m/invalid-type {:error/message {:en "invalid type"}}
   ::m/extra-key {:error/message {:en "disallowed key"}}
   :malli.core/invalid-dispatch-value {:error/message {:en "invalid dispatch value"}}
   ::misspelled-key {:error/fn {:en (fn [{::keys [likely-misspelling-of]} _]
                                      (str "should be spelled " (str/join " or " (map last likely-misspelling-of))))}}
   ::misspelled-value {:error/fn {:en (fn [{::keys [likely-misspelling-of]} _]
                                        (str "did you mean " (str/join " or " (map last likely-misspelling-of))))}}
   ::m/input-remaining {:error/message {:en "input remaining"}}
   ::m/end-of-input {:error/message {:en "end of input"}}
   'any? {:error/message {:en "should be any"}}
   'some? {:error/message {:en "should be some"}}
   'number? {:error/message {:en "should be a number"}}
   'integer? {:error/message {:en "should be an integer"}}
   'int? {:error/message {:en "should be an int"}}
   'pos-int? {:error/message {:en "should be a positive int"}}
   'neg-int? {:error/message {:en "should be a negative int"}}
   'nat-int? {:error/message {:en "should be a non-negative int"}}
   'pos? {:error/message {:en "should be positive"}}
   'neg? {:error/message {:en "should be negative"}}
   'float? {:error/message {:en "should be a float"}}
   'double? {:error/message {:en "should be a double"}}
   'boolean? {:error/message {:en "should be a boolean"}}
   'string? {:error/message {:en "should be a string"}}
   'ident? {:error/message {:en "should be an ident"}}
   'simple-ident? {:error/message {:en "should be a simple ident"}}
   'qualified-ident? {:error/message {:en "should be a qualified ident"}}
   'keyword? {:error/message {:en "should be a keyword"}}
   'simple-keyword? {:error/message {:en "should be a simple keyword"}}
   'qualified-keyword? {:error/message {:en "should be a qualified keyword"}}
   'symbol? {:error/message {:en "should be a symbol"}}
   'simple-symbol? {:error/message {:en "should be a simple symbol"}}
   'qualified-symbol? {:error/message {:en "should be a qualified symbol"}}
   'uuid? {:error/message {:en "should be a uuid"}}
   'uri? {:error/message {:en "should be a uri"}}
   #?@(:clj ['decimal? {:error/message {:en "should be a decimal"}}])
   'inst? {:error/message {:en "should be an inst"}}
   'seqable? {:error/message {:en "should be a seqable"}}
   'indexed? {:error/message {:en "should be an indexed"}}
   'map? {:error/message {:en "should be a map"}}
   'vector? {:error/message {:en "should be a vector"}}
   'list? {:error/message {:en "should be a list"}}
   'seq? {:error/message {:en "should be a seq"}}
   'char? {:error/message {:en "should be a char"}}
   'set? {:error/message {:en "should be a set"}}
   'nil? {:error/message {:en "should be nil"}}
   'false? {:error/message {:en "should be false"}}
   'true? {:error/message {:en "should be true"}}
   'zero? {:error/message {:en "should be zero"}}
   #?@(:clj ['rational? {:error/message {:en "should be a rational"}}])
   'coll? {:error/message {:en "should be a coll"}}
   'empty? {:error/message {:en "should be empty"}}
   'associative? {:error/message {:en "should be an associative"}}
   'sequential? {:error/message {:en "should be a sequential"}}
   #?@(:clj ['ratio? {:error/message {:en "should be a ratio"}}])
   #?@(:clj ['bytes? {:error/message {:en "should be bytes"}}])
   :re {:error/message {:en "should match regex"}}
   :=> {:error/message {:en "invalid function"}}
   'ifn? {:error/message {:en "should be an ifn"}}
   'fn? {:error/message {:en "should be an fn"}}
   :enum {:error/fn {:en (fn [{:keys [schema]} _]
                           (str "should be "
                                (if (= 1 (count (m/children schema)))
                                  (first (m/children schema))
                                  (str "either " (->> (m/children schema) butlast (str/join ", "))
                                       " or " (last (m/children schema))))))}}
   :any {:error/message {:en "should be any"}}
   :nil {:error/message {:en "should be nil"}}
   :string {:error/fn {:en (fn [{:keys [schema value]} _]
                             (let [{:keys [min max]} (m/properties schema)]
                               (cond
                                 (not (string? value)) "should be a string"
                                 (and min (= min max)) (str "should be " min " characters")
                                 (and min max) (str "should be between " min " and " max " characters")
                                 min (str "should be at least " min " characters")
                                 max (str "should be at most " max " characters"))))}}
   :int {:error/fn {:en (-pred-min-max-error-fn {:pred int?, :message "should be an integer"})}}
   :double {:error/fn {:en (-pred-min-max-error-fn {:pred double?, :message "should be a double"})}}
   :boolean {:error/message {:en "should be a boolean"}}
   :keyword {:error/message {:en "should be a keyword"}}
   :symbol {:error/message {:en "should be a symbol"}}
   :qualified-keyword {:error/message {:en "should be a qualified keyword"}}
   :qualified-symbol {:error/message {:en "should be a qualified symbol"}}
   :uuid {:error/message {:en "should be a uuid"}}
   :> {:error/fn {:en (fn [{:keys [schema value]} _]
                        (if (number? value)
                          (str "should be larger than " (first (m/children schema)))
                          "should be a number"))}}
   :>= {:error/fn {:en (fn [{:keys [schema value]} _]
                         (if (number? value)
                           (str "should be at least " (first (m/children schema)))
                           "should be a number"))}}
   :< {:error/fn {:en (fn [{:keys [schema value]} _]
                        (if (number? value)
                          (str "should be smaller than " (first (m/children schema)))
                          "should be a number"))}}
   :<= {:error/fn {:en (fn [{:keys [schema value]} _]
                         (if (number? value)
                           (str "should be at most " (first (m/children schema)))
                           "should be a number"))}}
   := {:error/fn {:en (fn [{:keys [schema]} _]
                        (str "should be " (first (m/children schema))))}}
   :not= {:error/fn {:en (fn [{:keys [schema]} _]
                           (str "should not be " (first (m/children schema))))}}})

(defn- -maybe-localized [x locale]
  (if (map? x) (get x locale) x))

(defn- -message [error props locale options]
  (let [options (or options (m/options (:schema error)))]
    (when props (or (when-let [fn (-maybe-localized (:error/fn props) locale)] ((m/eval fn options) error options))
                    (-maybe-localized (:error/message props) locale)))))

(defn -error [e] ^::error [e])
(defn -error? [x] (-> x meta ::error))

(defn -get [x k] (cond (or (set? x) (associative? x)) (get x k) (sequential? x) (get (vec x) k)))
(defn -concat [x y] (cond->> (concat x y) (and (some? x) (not (seq? x))) (into (empty x))))
(defn -fill [x i fill] (-concat x (repeat (- i (count x)) fill)))

(defn -push [x k v fill]
  (let [x' (cond-> x (and (int? k) (sequential? x) (> k (count x))) (-fill k fill))]
    (cond (or (nil? x') (associative? x')) (assoc x' k v)
          (set? x') (conj x' v)
          :else (apply list (assoc (vec x') k v)))))

(defn -push-in [a v [p & ps] e]
  (let [v' (-get v p)
        a' (or a (cond (sequential? v) [], (record? v) {}, :else (empty v)))]
    (cond
      ;; error present, let's not go deeper
      (and p (-error? a')) a
      ;; we can go deeper
      p (-push a' p (-push-in (-get a' p) v' ps e) nil)
      ;; it's a map!
      (map? a) (-push-in a' v [:malli/error] e)
      ;; accumulate
      (-error? a') (conj a' e)
      ;; lose it
      (vector? (not-empty a')) a'
      ;; first blood
      :else (-error e))))

(defn- -path [{:keys [schema]}
              {:keys [locale default-locale]
               :or {default-locale :en}}]
  (let [properties (m/properties schema)]
    (or (-maybe-localized (:error/path properties) locale)
        (-maybe-localized (:error/path properties) default-locale))))

;;
;; error values
;;

(defn -replace-in [a v [p & ps] e fill]
  (let [a' (or a (if (record? v) {} (empty v)))]
    (if p (-push (cond-> a' (set? a') (disj p)) p (-replace-in (-get a' p) (-get v p) ps e fill) fill) e)))

(defn -error-value [{:keys [errors value]} options]
  (let [mask (::mask-valid-values options)
        accept (::accept-error options #(-> % :type (not= ::m/missing-key)))
        wrap (::wrap-error options :value)
        acc (when (::keep-valid-values options) value)]
    (reduce (fn [acc error] (cond-> acc (accept error) (-replace-in value (:in error) (wrap error) mask))) acc errors)))

(defn -masked [mask x y]
  (cond (map? x) (reduce-kv (fn [acc k v] (let [e (find y k)] (assoc acc k (if e (-masked mask v (val e)) mask)))) y x)
        (set? x) (cond-> y (not= (count x) (count y)) (conj mask))
        (sequential? x) (-fill y (count x) mask)
        :else y))

;;
;; spell checking (kudos to https://github.com/bhauman/spell-spec)
;;

(defn- -length->threshold [len]
  (condp #(<= %2 %1) len, 4 0, 5 1, 6 2, 11 3, 20 4 (int (* 0.2 len))))

(defn- -next-row [previous current other-seq]
  (reduce
   (fn [row [diagonal above other]]
     (let [update-val (if (= other current) diagonal (inc (min diagonal above (peek row))))]
       (conj row update-val)))
   [(inc (first previous))]
   (map vector previous (next previous) other-seq)))

(defn- -levenshtein [sequence1 sequence2]
  (peek (reduce (fn [previous current] (-next-row previous current sequence2))
                (map #(identity %2) (cons nil sequence2) (range))
                sequence1)))

(defn- -similar-key [ky ky2]
  (let [min-len (apply min (map (m/-comp count #(if (str/starts-with? % ":") (subs % 1) %) str) [ky ky2]))
        dist (-levenshtein (str ky) (str ky2))]
    (when (<= dist (-length->threshold min-len)) dist)))

(defn- -likely-misspelled [keys known-keys key]
  (when-not (known-keys key)
    (->> known-keys (filter #(-similar-key % key)) (remove keys) (not-empty))))

(defn- -most-similar-to [keys key known-keys]
  (->> (-likely-misspelled keys known-keys key)
       (map (juxt #(-levenshtein (str %) (str key)) identity))
       (filter first)
       (sort-by first)
       (map second)
       (not-empty)))

;;
;; public api
;;

(defn error-path
  ([error]
   (error-path error nil))
  ([error options]
   (into (:in error) (-path error options))))

(defn error-message
  ([error]
   (error-message error nil))
  ([{:keys [schema type] :as error}
    {:keys [errors unknown locale default-locale]
     :or {errors default-errors
          unknown true
          default-locale :en} :as options}]
   (or (-message error (m/properties schema) locale options)
       (-message error (m/type-properties schema) locale options)
       (-message error (errors type) locale options)
       (-message error (errors (m/type schema)) locale options)
       (-message error (m/properties schema) default-locale options)
       (-message error (m/type-properties schema) default-locale options)
       (-message error (errors type) default-locale options)
       (-message error (errors (m/type schema)) default-locale options)
       (and unknown (-message error (errors ::unknown) locale options))
       (and unknown (-message error (errors ::unknown) default-locale options)))))

(defn -resolve-direct-error [_ error options]
  [(error-path error options) (error-message error options)])

(defn ^:no-doc -resolve-root-error [{:keys [schema]} {:keys [path in] :as error} options]
  (let [options (assoc options :unknown false)]
    (loop [path path, l nil, mp path, p (m/properties (:schema error)), m (error-message error options)]
      (let [[path' m' p'] (or (let [schema (mu/get-in schema path)]
                                (when-let [m' (error-message {:schema schema} options)] [path m' (m/properties schema)]))
                              (let [res (and l (mu/find (mu/get-in schema path) l))]
                                (when (vector? res)
                                  (let [[_ props schema] res
                                        schema (mu/update-properties schema merge props)
                                        message (error-message {:schema schema} options)]
                                    (when message [(conj path l) message (m/properties schema)]))))
                              (when m [mp m p]))]
        (if (seq path)
          (recur (pop path) (last path) path' p' m')
          (when m [(if (seq in) (mu/path->in schema path') (error-path error options)) m' p']))))))

(defn with-error-message
  ([error]
   (with-error-message error nil))
  ([error options]
   (assoc error :message (error-message error options))))

(defn with-error-messages
  ([explanation]
   (with-error-messages explanation nil))
  ([explanation {f :wrap :or {f identity} :as options}]
   (when explanation
     (update explanation :errors (fn [errors] (doall (map #(f (with-error-message % options)) errors)))))))

(defn with-spell-checking
  ([explanation]
   (with-spell-checking explanation nil))
  ([explanation {:keys [keep-likely-misspelled-of]}]
   (when explanation
     (let [!likely-misspelling-of (atom #{})
           handle-invalid-value (fn [schema _ value]
                                  (let [dispatch (:dispatch (m/properties schema))]
                                    (when (keyword? dispatch)
                                      (let [value (dispatch value)]
                                        [::misspelled-value value #{value}]))))
           types {::m/extra-key (fn [_ path value] [::misspelled-key (last path) (-> value keys set (or #{}))])
                  ::m/invalid-dispatch-value handle-invalid-value}]
       (update
        explanation
        :errors
        (fn [errors]
          (as-> errors $
            (mapv (fn [{:keys [schema path type] :as error}]
                    (if-let [get-keys (types type)]
                      (let [known-keys (->> schema (m/entries) (map first) (set))
                            value (get-in (:value explanation) (butlast path))
                            [error-type key keys] (get-keys schema path value)
                            similar (-most-similar-to keys key known-keys)
                            likely-misspelling-of (mapv #(conj (vec (butlast path)) %) (vec similar))]
                        (swap! !likely-misspelling-of into likely-misspelling-of)
                        (cond-> error similar (assoc :type error-type
                                                     ::likely-misspelling-of likely-misspelling-of)))
                      error)) $)
            (if-not keep-likely-misspelled-of
              (remove (fn [{:keys [path type]}]
                        (and (@!likely-misspelling-of path)
                             (= type ::m/missing-key))) $)
              $))))))))

(defn humanize
  "Humanized a explanation. Accepts the following options:

  - `:wrap`, a function of `error -> message`, defaulting to `:message`
  - `:resolve`, a function of `explanation error options -> path message`"
  ([explanation]
   (humanize explanation nil))
  ([{:keys [value errors] :as explanation} {:keys [wrap resolve]
                                            :or {wrap :message
                                                 resolve -resolve-direct-error}
                                            :as options}]
   (when errors
     (reduce
      (fn [acc error]
        (let [[path message] (resolve explanation error options)]
          (-push-in acc value path (wrap (assoc error :message message)))))
      nil errors))))

(defn error-value
  "Returns the parts of value that are in error. Accepts the following options:

  - `::mask-valid-values`, value to mask valid values with
  - `::keep-valid-values`, keep valid values (overrides mask)
  - `::accept-error`, function to accept errors
  - `::wrap-error`, function to wrap the error map (default: `:value`)"
  ([explanation]
   (error-value explanation nil))
  ([explanation {mask ::mask-valid-values :as options}]
   (cond->> (-error-value explanation options)
     mask (-masked mask (:value explanation)))))
(ns com.grzm.awyeah.json
  (:require [cheshire.core :as json]))

(defn write-str [x]
  (json/generate-string x))

(defn read-str [s]
  (json/parse-string s keyword))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.util
  "Impl, don't call directly."
  (:require
   [clojure.core.async :as a]
   [clojure.data.xml :as xml]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [com.grzm.awyeah.json :as json])
  (:import
   (java.io ByteArrayInputStream ByteArrayOutputStream)
   (java.io InputStream)
   (java.net URLEncoder)
   (java.nio ByteBuffer)
   (java.security MessageDigest)
   (java.time ZonedDateTime ZoneId)
   (java.time.format DateTimeFormatter)
   (java.util Base64)
   (java.util Date)
   (java.util UUID)
   (javax.crypto Mac)
   (javax.crypto.spec SecretKeySpec)))

(set! *warn-on-reflection* true)

(defn date-format
  "Return a thread-safe GMT date format that can be used with `format-date` and `parse-date`."
  [^String fmt]
  (.withZone (DateTimeFormatter/ofPattern fmt) (ZoneId/of "GMT")))

(defn format-date
  ([formatter]
   (format-date formatter (Date.)))
  ([formatter ^Date inst]
   (.format (ZonedDateTime/ofInstant (.toInstant inst) (ZoneId/of "UTC"))
            ^DateTimeFormatter formatter)))

(defn format-timestamp
  "Format a timestamp in milliseconds."
  [inst]
  (str (long (/ (.getTime ^Date inst) 1000))))

(defn parse-date
  [formatter s]
  (Date/from (.toInstant (ZonedDateTime/parse s formatter))))

(def x-amz-date-format
  (date-format "yyyyMMdd'T'HHmmss'Z'"))

(def x-amz-date-only-format
  (date-format "yyyyMMdd"))

(def iso8601-date-format
  (date-format "yyyy-MM-dd'T'HH:mm:ssXXX"))

(def iso8601-msecs-date-format
  (date-format "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"))

(def iso8601-usecs-date-format
  (date-format "yyyy-MM-dd'T'HH:mm:ss.SSSSSS'Z'"))

(def rfc822-date-format
  (date-format "EEE, dd MMM yyyy HH:mm:ss z"))

(let [hex-chars (char-array [\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \a \b \c \d \e \f])]
  (defn hex-encode
    [^bytes bytes]
    (let [bl (alength bytes)
          ca (char-array (* 2 bl))]
      (loop [i (int 0)
             c (int 0)]
        (if (< i bl)
          (let [b (long (bit-and (long (aget bytes i)) 255))]
            (aset ca c ^char (aget hex-chars (unsigned-bit-shift-right b 4)))
            (aset ca (unchecked-inc-int c) (aget hex-chars (bit-and b 15)))
            (recur (unchecked-inc-int i) (unchecked-add-int c 2)))
          (String. ca))))))

(defprotocol ByteSource
  (slurp-bytes [_] "Returns copy unless owner always treats arrays as values. Does not consume owner."))

(extend-protocol ByteSource
  ByteBuffer
  (slurp-bytes
    [buff]
    (let [buff (.duplicate buff)
          n (.remaining buff)
          bytes (byte-array n)]
      (.get buff bytes)
      bytes)))

(defn bbuff->byte-array
  "Returns a byte array with the content that is between the ByteBuffer current position and limit."
  [^ByteBuffer buff]
  (if (and (.hasArray buff)
           (= (.remaining buff) (alength (.array buff))))
    (.array buff)
    (slurp-bytes buff)))

(defn sha-256
  "Returns the sha-256 digest (bytes) of data, which can be a
  byte-array, an input-stream, or nil, in which case returns the
  sha-256 of the empty string."
  [data]
  (cond (string? data)
        (sha-256 (.getBytes ^String data "UTF-8"))
        (instance? ByteBuffer data)
        (sha-256 (bbuff->byte-array ^ByteBuffer data))
        :else
        (let [digest (MessageDigest/getInstance "SHA-256")]
          (when data
            (.update digest ^bytes data))
          (.digest digest))))

(defn hmac-sha-256
  [key ^String data]
  (let [mac (Mac/getInstance "HmacSHA256")]
    (.init mac (SecretKeySpec. key "HmacSHA256"))
    (.doFinal mac (.getBytes data "UTF-8"))))

(defn input-stream->byte-array ^bytes [is]
  (let [os (ByteArrayOutputStream.)]
    (io/copy is os)
    (.toByteArray os)))

(defn bbuf->bytes
  [^ByteBuffer bbuf]
  (when bbuf
    (let [bytes (byte-array (.remaining bbuf))]
      (.get (.duplicate bbuf) bytes)
      bytes)))

(defn bbuf->str
  "Creates a string from java.nio.ByteBuffer object.
   The encoding is fixed to UTF-8."
  [^ByteBuffer bbuf]
  (when-let [bytes (bbuf->bytes bbuf)]
    (String. ^bytes bytes "UTF-8")))

(defn bbuf->input-stream
  [^ByteBuffer bbuf]
  (when bbuf
    (io/input-stream (bbuf->bytes bbuf))))

(defprotocol BBuffable
  (->bbuf [data]))

(extend-protocol BBuffable
  (Class/forName "[B")
  (->bbuf [bs] (ByteBuffer/wrap bs))

  String
  (->bbuf [s] (->bbuf (.getBytes s "UTF-8")))

  InputStream
  (->bbuf [is] (->bbuf (input-stream->byte-array is)))

  ByteBuffer
  (->bbuf [bb] bb)

  nil
  (->bbuf [_]))

(defn xml-read
  "Parse the UTF-8 XML string."
  [s]
  (xml/parse (ByteArrayInputStream. (.getBytes ^String s "UTF-8"))
             :namespace-aware false
             :skip-whitespace true))

(defn xml->map [element]
  (cond
    (nil? element) nil

    (string? element) element

    (sequential? element)
    (if (> (count element) 1)
      (into {} (map xml->map) element)
      (xml->map (first element)))

    (map? element)
    (cond
      (empty? element) {}
      (:attrs element) {(:tag element) (xml->map (:content element))
                        (keyword (str (name (:tag element)) "Attrs")) (:attrs element)}
      :else {(:tag element) (xml->map (:content element))})

    :else nil))

(defn xml-write
  [e]
  (if (instance? String e)
    (print e)
    (do
      (print (str "<" (name (:tag e))))
      (when (:attrs e)
        (doseq [attr (:attrs e)]
          (print (str " " (name (key attr)) "=\"" (val attr) "\""))))
      (if-not (empty? (:content e))
        (do
          (print ">")
          (doseq [c (:content e)]
            (xml-write c))
          (print (str "</" (name (:tag e)) ">")))
        (print " />")))))

(defn url-encode
  "Percent encode the string to put in a URL."
  [^String s]
  (-> s
      (URLEncoder/encode "UTF-8")
      ;; https://github.com/aws/aws-sdk-java/blob/fd409de/aws-java-sdk-core/src/main/java/com/amazonaws/util/SdkHttpUtils.java#L77-L91
      (.replace "+" "%20")
      (.replace "*" "%2A")))

(defn query-string
  "Create a query string from a list of parameters. Values must all be
  strings."
  [params]
  (when-not (empty? params)
    (str/join "&" (map (fn [[k v]]
                         (str (url-encode (name k))
                              "="
                              (url-encode v)))
                       params))))

(defprotocol Base64Encodable
  (base64-encode [data]))

(extend-protocol Base64Encodable
  (Class/forName "[B")
  (base64-encode [ba] (.encodeToString (Base64/getEncoder) ba))

  ByteBuffer
  (base64-encode [bb] (base64-encode (bbuff->byte-array bb)))

  java.lang.String
  (base64-encode [s] (base64-encode (.getBytes s))))

(defn base64-decode
  "base64 decode a base64-encoded string to an input stream"
  [s]
  (io/input-stream (.decode (Base64/getDecoder) ^String s)))

(defn encode-jsonvalue [data]
  (base64-encode (.getBytes ^String (json/write-str data))))

(defn parse-jsonvalue [data]
  (-> data
      base64-decode
      io/reader
      slurp
      (json/read-str)))

(defn md5
  "returns an MD5 hash of the content of bb as a byte array"
  ^bytes [^ByteBuffer bb]
  (let [ba (bbuff->byte-array bb)
        hasher (MessageDigest/getInstance "MD5")]
    (.update hasher ^bytes ba)
    (.digest hasher)))

(defn uuid-string
  "returns a string representation of a randomly generated UUID"
  []
  (str (UUID/randomUUID)))

(defn with-defaults
  "Given a shape and data of that shape, add defaults for the
  following required keys if they are missing or bound to nil

      :idempotencyToken"
  [shape data]
  (reduce (fn [m [member-name member-spec]]
            (cond
              (not (nil? (get data member-name)))
              m

              (:idempotencyToken member-spec)
              (assoc m member-name (uuid-string))

              :else
              m))
          (or data {})
          (:members shape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; used to fetch creds and region

(defn fetch-async
  "Internal use. Do not call directly."
  [fetch provider item]
  (a/thread
    (try
      ;; lock on the provider to avoid redundant concurrent requests
      ;; before the provider has a chance to cache the results of the
      ;; first fetch.
      (or (locking provider
            (fetch provider))
          {:cognitect.anomalies/category :cognitect.anomalies/fault
           :cognitect.anomalies/message (format "Unable to fetch %s. See log for more details." item)})
      (catch Throwable t
        {:cognitect.anomalies/category :cognitect.anomalies/fault
         ::throwable t
         :cognitect.anomalies/message (format "Unable to fetch %s." item)}))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Wrappers - here to support testing with-redefs since
;;;;            we can't redef static methods

(defn getenv
  ([] (System/getenv))
  ([k] (System/getenv k)))

(defn getProperty [k]
  (System/getProperty k))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.service
  "Impl, don't call directly."
  (:require
   [clojure.edn :as edn]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.walk :as walk]))

(set! *warn-on-reflection* true)

(def base-ns "cognitect.aws")

(def base-resource-path "cognitect/aws")

(defn descriptor-resource-path [service-name]
  (str base-resource-path "/" service-name "/service.edn"))

(defn descriptor-resource [service-name]
  (io/resource (descriptor-resource-path service-name)))

(defn read-service-description
  "Return service description readerable source (anything supported by
  clojure.java.io/reader)."
  [readerable]
  (edn/read-string (slurp readerable)))

(defn service-description [service-name]
  (if-let [resource (descriptor-resource service-name)]
    (read-service-description resource)
    (throw (ex-info (str "Cannot find resource " (descriptor-resource-path service-name) ".") {}))))

(defn endpoint-prefix
  [service]
  (get-in service [:metadata :endpointPrefix]))

(defn signing-name
  [service]
  (get-in service [:metadata :signingName]))

(defn service-name [service]
  (-> service :metadata :uid
      (str/replace #"-\d{4}-\d{2}-\d{2}" "")
      (str/replace #"\s" "-")
      (str/replace #"\." "-")))

(defn ns-prefix
  "Returns the namespace prefix to use when looking up resources."
  [service]
  (format "%s.%s" base-ns (service-name service)))

(defn spec-ns
  "The namespace for specs for service."
  [service]
  (symbol (format "%s.specs" (ns-prefix service))))

(defn load-specs [service]
  (require (spec-ns service)))

(defonce svc-docs (atom {}))

(defn with-ref-meta [m op doc]
  (let [ref-atom (atom nil)
        refs (:refs doc)
        updated-doc (walk/postwalk
                      (fn [n]
                        (if (contains? refs n)
                          (with-meta n
                            {'clojure.core.protocols/datafy #(-> ref-atom deref %)})
                          n))
                      doc)]
    (reset! ref-atom (:refs updated-doc))
    (assoc m op (into {:name (name op)} updated-doc))))

(defn docs
  "Returns the docs for this service"
  [service]
  (let [k (service-name service)]
    (if-let [doc (get @svc-docs k)]
      doc
      (-> (swap! svc-docs
                 assoc
                 k
                 (reduce-kv with-ref-meta
                            {}
                            (clojure.edn/read-string
                              (slurp
                                (io/resource (format "%s/%s/docs.edn" base-resource-path (service-name service)))))))
          (get k)))))

(defn request-spec-key
  "Returns the key to look up in the spec registry for the spec for
  the request body of op."
  [service op]
  (load-specs service)
  (when-let [shape-key (some->> service :operations op :input :shape)]
    (keyword (ns-prefix service) shape-key)))

(defn response-spec-key
  "Returns the key to look up in the spec registry for the spec for
  the response body of op."
  [service op]
  (load-specs service)
  (when-let [shape-key (some->> service :operations op :output :shape)]
    (keyword (ns-prefix service) shape-key)))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.signers
  "Impl, don't call directly."
  (:require
   [clojure.string :as str]
   [com.grzm.awyeah.service :as service]
   [com.grzm.awyeah.util :as util])
  (:import
   (java.net URI)
   (java.net URLDecoder)))

(set! *warn-on-reflection* true)

(defmulti sign-http-request
  "Sign the HTTP request."
  (fn [service _endpoint _credentials _http-request]
    (get-in service [:metadata :signatureVersion])))

(defn uri-encode
  "Escape (%XX) special characters in the string `s`.

  Letters, digits, and the characters `_-~.` are never encoded.

  The optional `extra-chars` specifies extra characters to not encode."
  ([^String s]
   (when s
     (uri-encode s "")))
  ([^String s extra-chars]
   (when s
     (let [safe-chars (->> extra-chars
                           (into #{\_ \- \~ \.})
                           (into #{} (map int)))
           builder (StringBuilder.)]
       (doseq [b (.getBytes s "UTF-8")]
         (.append builder
                  (if (or (Character/isLetterOrDigit (int b))
                          (contains? safe-chars b))
                    (char b)
                    (format "%%%02X" b))))
       (.toString builder)))))

(defn credential-scope
  [{:keys [region service]} request]
  (str/join "/" [(->> (get-in request [:headers "x-amz-date"])
                      (util/parse-date util/x-amz-date-format)
                      (util/format-date util/x-amz-date-only-format))
                 region
                 service
                 "aws4_request"]))

(defn- canonical-method
  [{:keys [request-method]}]
  (-> request-method name str/upper-case))

(defn- canonical-uri
  [{:keys [uri]} {:keys [double-encode? normalize-uri?]}]
  (let [[path _query] (str/split uri #"\?")
        ^String encoded-path (-> path
                                 (cond-> double-encode? (uri-encode "/"))
                                 (str/replace #"^//+" "/") ; (URI.) throws Exception on '//' at beginning of string.
                                 (str/replace #"\s" "%20"); (URI.) throws Exception on space.
                                 (URI.)
                                 (cond-> normalize-uri? (.normalize))
                                 (.getPath)
                                 (uri-encode "/"))]
    (cond
      (.isEmpty encoded-path)
      "/"

      ;; https://github.com/aws/aws-sdk-java/blob/fd409de/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AbstractAWSSigner.java#L392-L397
      ;; Normalization can leave a trailing slash at the end of the resource path,
      ;; even if the input path doesn't end with one. Example input: /foo/bar/.
      ;; Remove the trailing slash if the input path doesn't end with one.
      (and (not= encoded-path "/")
           (str/ends-with? encoded-path "/")
           (not (str/ends-with? path "/")))
      (.substring encoded-path 0 (dec (.length encoded-path)))

      :else encoded-path)))

(defn- canonical-query-string
  [{:keys [uri query-string]}]
  (let [qs (or query-string (second (str/split uri #"\?")))]
    (when-not (str/blank? qs)
      (->> (str/split qs #"&")
           (map #(str/split % #"=" 2))
           ;; TODO (dchelimsky 2019-01-30) decoding first because sometimes
           ;; it's already been encoding. Look into avoiding that!
           (map (fn [kv] (map #(uri-encode (URLDecoder/decode %)) kv)))
           (sort (fn [[k1 v1] [k2 v2]]
                   (if (= k1 k2)
                     (compare v1 v2)
                     (compare k1 k2))))
           (map (fn [[k v]] (str k "=" v)))
           (str/join "&")))))

(defn- canonical-headers
  [{:keys [headers]}]
  (reduce-kv (fn [m k v]
               (assoc m (str/lower-case k) (-> v str/trim (str/replace #"\s+" " "))))
             (sorted-map)
             headers))

(defn- canonical-headers-string
  [request]
  (->> (canonical-headers request)
       (map (fn [[k v]] (str k ":" v "\n")))
       (str/join "")))

(defn signed-headers
  [request]
  (->> (canonical-headers request)
       keys
       (str/join ";")))

(defn hashed-body
  [request]
  (util/hex-encode (util/sha-256 (:body request))))

(defn canonical-request
  [{:keys [headers] :as request} opts]
  (str/join "\n" [(canonical-method request)
                  (canonical-uri request opts)
                  (canonical-query-string request)
                  (canonical-headers-string request)
                  (signed-headers request)
                  (or (get headers "x-amz-content-sha256")
                      (hashed-body request))]))

(defn string-to-sign
  [request auth-info opts]
  (let [bytes (.getBytes ^String (canonical-request request opts))]
    (str/join "\n" ["AWS4-HMAC-SHA256"
                    (get-in request [:headers "x-amz-date"])
                    (credential-scope auth-info request)
                    (util/hex-encode (util/sha-256 bytes))])))

(defn signing-key
  [request {:keys [secret-access-key region service]}]
  (-> (.getBytes (str "AWS4" secret-access-key) "UTF-8")
      (util/hmac-sha-256 (->> (get-in request [:headers "x-amz-date"])
                              (util/parse-date util/x-amz-date-format)
                              (util/format-date util/x-amz-date-only-format)))
      (util/hmac-sha-256 region)
      (util/hmac-sha-256 service)
      (util/hmac-sha-256 "aws4_request")))

(defn signature
  [auth-info request opts]
  (util/hex-encode
    (util/hmac-sha-256 (signing-key request auth-info)
                       (string-to-sign request auth-info opts))))

(defn v4-sign-http-request
  [service endpoint credentials http-request & {:keys [content-sha256-header? double-url-encode? normalize-uri-paths?]}]
  (let [{:keys [:aws/access-key-id :aws/secret-access-key :aws/session-token]} credentials
        auth-info {:access-key-id access-key-id
                   :secret-access-key secret-access-key
                   :service (or (service/signing-name service)
                                (service/endpoint-prefix service))
                   :region (or (get-in endpoint [:credentialScope :region])
                               (:region endpoint))}
        req (cond-> http-request
              session-token (assoc-in [:headers "x-amz-security-token"] session-token)
              content-sha256-header? (assoc-in [:headers "x-amz-content-sha256"] (hashed-body http-request)))]
    (assoc-in req
              [:headers "authorization"]
              (format "AWS4-HMAC-SHA256 Credential=%s/%s, SignedHeaders=%s, Signature=%s"
                      (:access-key-id auth-info)
                      (credential-scope auth-info req)
                      (signed-headers req)
                      (signature auth-info req {:double-encode? double-url-encode?
                                                :normalize-uri? normalize-uri-paths?})))))

;; https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
;;
;; Each path segment must be URI-encoded twice (except for Amazon S3 which only gets URI-encoded once).
;;
;; Normalize URI paths according to RFC 3986.
;; In exception to this, you do not normalize URI paths for requests to Amazon S3
(defmethod sign-http-request "v4"
  [service endpoint credentials http-request]
  (v4-sign-http-request service endpoint credentials http-request
                        :double-url-encode? true
                        :normalize-uri-paths? true))

(defmethod sign-http-request "s3"
  [service endpoint credentials http-request]
  (v4-sign-http-request service endpoint credentials http-request
                        :content-sha256-header? true))

(defmethod sign-http-request "s3v4"
  [service endpoint credentials http-request]
  (v4-sign-http-request service endpoint credentials http-request
                        :content-sha256-header? true))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns com.grzm.awyeah.retry
  (:require
   [clojure.core.async :as a]))

(set! *warn-on-reflection* true)

(defn ^:skip-wiki with-retry
  "For internal use. Do not call directly.

  Calls req-fn, a *non-blocking* function that wraps some operation
  and returns a channel. When the response to req-fn is retriable?
  and backoff returns an int, waits backoff ms and retries, otherwise
  puts response on resp-chan."
  [req-fn resp-chan retriable? backoff]
  (a/go-loop [retries 0]
    (let [resp (a/<! (req-fn))]
      (if (retriable? resp)
        (if-let [bo (backoff retries)]
          (do
            (a/<! (a/timeout bo))
            (recur (inc retries)))
          (a/>! resp-chan resp))
        (a/>! resp-chan resp))))
  resp-chan)

(defn capped-exponential-backoff
  "Returns a function of the num-retries (so far), which returns the
  lesser of max-backoff and an exponentially increasing multiple of
  base, or nil when (>= num-retries max-retries).
  See with-retry to see how it is used.

  Alpha. Subject to change."
  [base max-backoff max-retries]
  (fn [num-retries]
    (when (< num-retries max-retries)
      (min max-backoff
           (* base (bit-shift-left 1 num-retries))))))

(def default-backoff
  "Returns (capped-exponential-backoff 100 20000 3).

  Alpha. Subject to change."
  (capped-exponential-backoff 100 20000 3))

(def default-retriable?
  "A fn of an http-response map which returns a truthy value
  if (:cognitect.anomalies/category http-response) is any of:
    - :cognitect.anomalies/busy
    - :cognitect.anomalies/interrupted
    - :cognitect.anomalies/unavailable

  Alpha. Subject to change."
  (comp #{:cognitect.anomalies/busy
          :cognitect.anomalies/interrupted
          :cognitect.anomalies/unavailable}
        :cognitect.anomalies/category))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.http
  "Impl, don't call directly."
  (:require
   [clojure.core.async :as a]
   [clojure.edn :as edn]
   [clojure.java.io :as io]))

(set! *warn-on-reflection* true)

(defprotocol HttpClient
  (-submit [_ request channel]
    "Submit an http request, channel will be filled with response. Returns ch.

     Request map:

     :scheme                 :http or :https
     :server-name            string
     :server-port            integer
     :uri                    string
     :query-string           string, optional
     :request-method         :get/:post/:put/:head/:delete
     :headers                map from downcased string to string
     :body                   ByteBuffer, optional
     :timeout-msec           opt, total request send/receive timeout
     :meta                   opt, data to be added to the response map

     content-type must be specified in the headers map
     content-length is derived from the ByteBuffer passed to body

     Response map:

     :status            integer HTTP status code
     :body              ByteBuffer, optional
     :headers           map from downcased string to string
     :meta              opt, data from the request

     On error, response map is per cognitect.anomalies.

     Alpha. This will absolutely change.")
  (-stop [_] "Stops the client, releasing resources"))

(defn submit
  ([client request]
   (-submit client request (a/chan 1)))
  ([client request channel]
   (-submit client request channel)))

(defn stop
  "Stops the client, releasing resources.

  Alpha. Subject to change."
  [client]
  (-stop client))

(defn client?
  [c]
  (satisfies? HttpClient c))

(defn read-config
  [url]
  (-> url slurp edn/read-string))

;; TODO consider providing config arguments to http constructor
(defn- configured-client
  "If a single com_grzm_awyeah_http.edn is found on the classpath,
  returns the symbol bound to :constructor-var.

  Throws if 0 or > 1 com_grzm_awyeah_http.edn files are found.
  "
  []
  (try
    (-> (io/resource "com_grzm_awyeah_http.edn") read-config :constructor-var)
    (catch Throwable _
      (throw (RuntimeException. "Could not find com_grzm_awyeah_http.edn on classpath.")))))

(defn resolve-http-client
  [http-client-or-sym]
  (let [c (or (when (symbol? http-client-or-sym)
                (let [ctor (requiring-resolve http-client-or-sym)]
                  (ctor)))
              http-client-or-sym
              (let [ctor (requiring-resolve (configured-client))]
                (ctor)))]
    (when-not (client? c)
      (throw (ex-info "not an http client" {:provided http-client-or-sym
                                            :resolved c})))
    c))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.ec2-metadata-utils
  "Impl, don't call directly"
  (:require
   [clojure.core.async :as a]
   [clojure.string :as str]
   [com.grzm.awyeah.http :as http]
   [com.grzm.awyeah.json :as json]
   [com.grzm.awyeah.retry :as retry]
   [com.grzm.awyeah.util :as u])
  (:import
   (java.net URI)))

(set! *warn-on-reflection* true)

(def ^:const ec2-metadata-service-override-system-property "com.amazonaws.sdk.ec2MetadataServiceEndpointOverride")
(def ^:const dynamic-data-root "/latest/dynamic/")
(def ^:const security-credentials-path "/latest/meta-data/iam/security-credentials/")
(def ^:const instance-identity-document "instance-identity/document")

;; ECS
(def ^:const container-credentials-relative-uri-env-var "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI")
(def ^:const container-credentials-full-uri-env-var "AWS_CONTAINER_CREDENTIALS_FULL_URI")
(def ^:const container-authorization-token-env-var "AWS_CONTAINER_AUTHORIZATION_TOKEN")

(def ^:const ec2-metadata-host "http://169.254.169.254")
(def ^:const ecs-metadata-host "http://169.254.170.2")

(defn in-container? []
  (or (u/getenv container-credentials-relative-uri-env-var)
      (u/getenv container-credentials-full-uri-env-var)))

(defn build-path [& components]
  (str/replace (str/join \/ components) #"\/\/+" (constantly "/")))

(defn- build-uri
  [host path]
  (str host "/" (cond-> path (str/starts-with? path "/") (subs 1))))

(defn get-host-address
  "Gets the EC2 (or ECS) metadata host address"
  []
  (or (u/getProperty ec2-metadata-service-override-system-property)
      (when (in-container?) ecs-metadata-host)
      ec2-metadata-host))

(defn- request-map
  [^URI uri]
  (let [auth-token (u/getenv container-authorization-token-env-var)]
    {:scheme (.getScheme uri)
     :server-name (.getHost uri)
     :server-port (or (when (pos? (.getPort uri)) (.getPort uri))
                      (when (#{"https"} (.getScheme uri)) 443)
                      80)
     :uri (.getPath uri)
     :request-method :get
     :headers (cond-> {:accept "*/*"}
                auth-token
                (assoc "Authorization" auth-token))}))

(defn get-data [uri http-client]
  (let [response (a/<!! (retry/with-retry
                          #(http/submit http-client (request-map (URI. uri)))
                          (a/promise-chan)
                          retry/default-retriable?
                          retry/default-backoff))]
    ;; TODO: handle unhappy paths -JS
    (when (= 200 (:status response))
      (u/bbuf->str (:body response)))))

(defn get-data-at-path [path http-client]
  (get-data (build-uri (get-host-address) path) http-client))

(defn get-listing [uri http-client]
  (some-> (get-data uri http-client) str/split-lines))

(defn get-listing-at-path [path http-client]
  (get-listing (build-uri (get-host-address) path) http-client))

(defn get-ec2-instance-data [http-client]
  (some-> (build-path dynamic-data-root instance-identity-document)
          (get-data-at-path http-client)
          (json/read-str)))

(defn get-ec2-instance-region
  [http-client]
  (:region (get-ec2-instance-data http-client)))

(defn container-credentials [http-client]
  (let [endpoint (or (when-let [path (u/getenv container-credentials-relative-uri-env-var)]
                       (str (get-host-address) path))
                     (u/getenv container-credentials-full-uri-env-var))]
    (some-> endpoint (get-data http-client) (json/read-str))))

(defn instance-credentials [http-client]
  (when (not (in-container?))
    (when-let [cred-name (first (get-listing-at-path security-credentials-path http-client))]
      (some-> (get-data-at-path (str security-credentials-path cred-name) http-client)
              (json/read-str)))))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.config
  (:require
   [clojure.string :as str]))

(set! *warn-on-reflection* true)

;;; predicates

(defn comment? [s]
  (str/starts-with? s "#"))

(defn start-profile? [s]
  (str/starts-with? s "["))

(defn start-nested? [s]
  (re-find #"^[\w-_\.]+\s*=$" s))

(defn add-profile-kv? [s]
  (re-find #"^[\w-_\.]+\s*=.*\w+" s))

(defn add-nested-kv? [s]
  (re-find #"^\s+[\w-_\.]+\s*=.*\w+" s))

;;; helpers

(defn split-lines [s]
  (into []
        (comp (map str/trimr)
              (remove str/blank?)
              (remove comment?))
        (str/split-lines s)))

(defn split-kv [s]
  (->> (str/split s #"=" 2)
       (map str/trim)))

;;; actions

(defn set-profile-path [m line]
  (assoc m :path [:profiles (second (re-find #"\[(?:profile)?\s*(.+)\]" line))]))

(defn ensure-profile-path [m]
  (update m :path (comp vec (partial take 2))))

(defn set-nested-path [m line]
  (update m :path #(conj (vec (take 2 %))
                         (-> line (str/replace #"=" "") (str/trim)))))

(defn add-profile-kv [m line]
  (let [[k v] (split-kv line)]
    (update-in m (take 2 (:path m)) assoc k v)))

(defn add-nested-kv [m line]
  (let [[k v] (split-kv line)]
    (update-in m (:path m) assoc k v)))

;;; main

(defn parse
  "Return the profiles in the configuration file."
  [file]
  (->> file
       slurp
       split-lines
       (reduce (fn [m ^String line]
                 (cond (start-profile? line)
                       (set-profile-path m line)

                       (start-nested? line)
                       (set-nested-path m line)

                       (add-profile-kv? line)
                       (-> m
                           (add-profile-kv line)
                           (ensure-profile-path))

                       (add-nested-kv? line)
                       (add-nested-kv m line)

                       :else
                       (throw (ex-info "Invalid format in config" {:file file}))))
               {:profiles {}})
       :profiles))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns com.grzm.awyeah.region
  "Region providers. Primarily for internal use, and subject to change."
  (:require
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.tools.logging :as log]
   [com.grzm.awyeah.config :as config]
   [com.grzm.awyeah.ec2-metadata-utils :as ec2]
   [com.grzm.awyeah.util :as u])
  (:import
   (java.io File)))

(set! *warn-on-reflection* true)

(defn ^:skip-wiki valid-region
  "For internal use. Don't call directly.

  Return the credential region if valid, otherwise nil."
  [region]
  ;; TODO: (dchelimsky 2018-07-27) maybe validate this against known regions?
  (when-not (str/blank? region) region))

(defprotocol RegionProvider
  (fetch [_] "Returns the region found by this provider, or nil."))

(defn chain-region-provider
  "Chain together multiple region providers.

  `fetch` calls each provider in order until one returns a non-nil result,
  or returns nil.

  Alpha. Subject to change."
  [providers]
  (reify RegionProvider
    (fetch [_]
      (or (valid-region (some fetch providers))
          (throw (ex-info "No region found by any region provider."
                          {:providers (map class providers)}))))))

(defn environment-region-provider
  "Returns the region from the AWS_REGION env var, or nil if not present.

  Alpha. Subject to change."
  []
  (reify RegionProvider
    (fetch [_] (valid-region (u/getenv "AWS_REGION")))))

(defn system-property-region-provider
  "Returns the region from the aws.region system property, or nil if not present.

  Alpha. Subject to change."
  []
  (reify RegionProvider
    (fetch [_] (valid-region (u/getProperty "aws.region")))))

(defn profile-region-provider
  "Returns the region from an AWS configuration profile.

  Arguments:

    f             File    The profile configuration file. (default: ~/.aws/config)
    profile-name  string  The name of the profile in the file. (default: default)

  Parsed properties:

    region        required

  Alpha. Subject to change."
  ([]
   (profile-region-provider (or (u/getenv "AWS_PROFILE")
                                (u/getProperty "aws.profile")
                                "default")))
  ([profile-name]
   (profile-region-provider profile-name (or (io/file (u/getenv "AWS_CONFIG_FILE"))
                                             (io/file (u/getProperty "user.home") ".aws" "config"))))
  ([profile-name ^File f]
   (reify RegionProvider
     (fetch [_]
       (when (.exists f)
         (try
           (let [profile (get (config/parse f) profile-name)]
             (valid-region (get profile "region")))
           (catch Throwable t
             (log/error t "Unable to fetch region from the AWS config file " (str f)))))))))

(defn instance-region-provider
  "Returns the region from the ec2 instance's metadata service,
  or nil if the service can not be found.

  Alpha. Subject to change."
  [http-client]
  (let [cached-region (atom nil)]
    (reify RegionProvider
      (fetch [_]
        (or @cached-region
            (reset! cached-region (valid-region (ec2/get-ec2-instance-region http-client))))))))

(defn default-region-provider
  "Returns a chain-region-provider with, in order:

    environment-region-provider
    system-property-region-provider
    profile-region-provider
    instance-region-provider

  Alpha. Subject to change."
  [http-client]
  (chain-region-provider
    [(environment-region-provider)
     (system-property-region-provider)
     (profile-region-provider)
     (instance-region-provider http-client)]))

(defn fetch-async
  "Returns a channel that will produce the result of calling fetch on
  the provider.

  Alpha. Subject to change."
  [provider]
  (u/fetch-async fetch provider "region"))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.endpoint
  "Impl, don't call directly."
  (:refer-clojure :exclude [resolve])
  (:require
   [clojure.edn :as edn]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [com.grzm.awyeah.service :as service]))

(set! *warn-on-reflection* true)

(defn descriptor-resource-path [] (format "%s/endpoints.edn" service/base-resource-path))

(defn read-endpoints-description []
  (if-let [resource (io/resource (descriptor-resource-path))]
    (edn/read-string (slurp resource))
    (throw (ex-info (str "Cannot find resource " (descriptor-resource-path) ".") {}))))

(defn resolver
  "Create a new endpoint resolver."
  []
  (read-endpoints-description))

(defn render-uri
  "Given a template, e.g. \"{a}.{b}.{c}\", and a map of replacements
  with keys matching those in the template, replaces {a} with the
  value bound to :a in replacements, then {b}, then {c}."
  [replacements template]
  (str/replace template
               #"\{([^}]+)\}"
               #(get replacements (second %))))

(defn service-resolve
  "Resolve the endpoint for the given service."
  [partition service-name service region-key]
  (let [endpoint (get-in service [:endpoints region-key])
        region (name region-key)
        result (merge (:defaults partition)
                      (:defaults service)
                      endpoint
                      {:partition (:partition partition)
                       :region region
                       :dnsSuffix (:dnsSuffix partition)})
        uri-parts {"service" service-name
                   "region" region
                   "dnsSuffix" (:dnsSuffix partition)}]
    (cond-> result
      (:hostname result)
      (update :hostname (partial render-uri uri-parts))

      (:sslCommonName result)
      (update :sslCommonName (partial render-uri uri-parts)))))

(defn partition-resolve
  [{:keys [services] :as partition} service-key region-key]
  (when (contains? (-> partition :regions keys set) region-key)
    (let [{:keys [partitionEndpoint isRegionalized] :as service} (get services service-key)
          endpoint-key (if (and partitionEndpoint (not isRegionalized))
                         (keyword partitionEndpoint)
                         region-key)]
      (service-resolve partition (name service-key) service endpoint-key))))

(defn resolve*
  "Resolves an endpoint for a given service and region.

  service keyword Identify a AWS service (e.g. :s3)
  region keyword  Identify a AWS region (e.g. :us-east-1).

  Return a map with the following keys:

  :partition            The name of the partition.
  :region               The region of the endpoint.
  :hostname             The hostname to use.
  :sslCommonName        The sslCommonName to use (optional).
  :credentialScope      The Signature v4 credential scope (optional).
  :signatureVersions    A list of possible signature versions (optional).
  :protocols            A list of supported protocols."
  [service-key region]
  (some #(partition-resolve % service-key region)
        (:partitions (resolver))))

(def resolve (memoize resolve*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defprotocol EndpointProvider
  (-fetch [provider region]))

(defn default-endpoint-provider [endpointPrefix endpoint-override]
  (reify EndpointProvider
    (-fetch [_ region]
      (if-let [ep (resolve (keyword endpointPrefix) (keyword region))]
        (merge ep (if (string? endpoint-override)
                    {:hostname endpoint-override}
                    endpoint-override))
        {:cognitect.anomalies/category :cognitect.anomalies/fault
         :cognitect.anomalies/message "No known endpoint."}))))

(defn fetch [provider region]
  (-fetch provider region))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.dynaload)

(set! *warn-on-reflection* true)

(defonce ^:private dynalock (Object.))

(defn load-ns [ns]
  (locking dynalock
    (require (symbol ns))))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns com.grzm.awyeah.credentials
  "Contains credentials providers and helpers for discovering credentials.

  Alpha. Subject to change."
  (:require
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.tools.logging :as log]
   [com.grzm.awyeah.config :as config]
   [com.grzm.awyeah.ec2-metadata-utils :as ec2]
   [com.grzm.awyeah.util :as u])
  (:import
   (java.io File)
   (java.time Duration
              Instant)
   (java.util Date)
   (java.util.concurrent Executors
                         Future
                         ScheduledExecutorService
                         ThreadFactory
                         TimeUnit)))

(set! *warn-on-reflection* true)

(defprotocol CredentialsProvider
  (fetch [provider]
    "Return the credentials found by this provider, or nil.

    Credentials should be a map with the following keys:

    :aws/access-key-id                      string  required
    :aws/secret-access-key                  string  required
    :aws/session-token                      string  optional
    :cognitect.aws.credentials/ttl          number  optional  Time-to-live in seconds"))

(defprotocol Stoppable
  (-stop [_]))

(extend-protocol Stoppable
  Object
  (-stop [_]))

;; Credentials subsystem

(defonce ^:private scheduled-executor-service
  (delay
    (Executors/newScheduledThreadPool 1 (reify ThreadFactory
                                          (newThread [_ r]
                                            (doto (Thread. r)
                                              (.setName "cognitect.aws-api.credentials-provider")
                                              (.setDaemon true)))))))

(defn ^:skip-wiki refresh!
  "For internal use. Don't call directly.

  Invokes `(fetch provider)`, resets the `credentials-atom` with and
  returns the result.

  If the result includes a ::ttl, schedules a refresh after ::ttl
  seconds using `scheduler`, resetting `scheduled-refresh` with the
  resulting `ScheduledFuture`.

  If the credentials returned by the provider are not valid, resets
  both atoms to nil and returns nil."
  [credentials-atom scheduled-refresh-atom provider scheduler]
  (try
    (let [{:keys [::ttl] :as new-creds} (fetch provider)]
      (reset! scheduled-refresh-atom
              (when ttl
                #?(:bb (.schedule ^ScheduledExecutorService scheduler
                                  #(refresh! credentials-atom scheduled-refresh-atom provider scheduler)
                                  ^long ttl
                                  TimeUnit/SECONDS)
                   :clj (.schedule ^ScheduledExecutorService scheduler
                                   ^Runnable #(refresh! credentials-atom scheduled-refresh-atom provider scheduler)
                                   ^long ttl
                                   TimeUnit/SECONDS))))
      (reset! credentials-atom new-creds))
    (catch Throwable t
      (reset! scheduled-refresh-atom nil)
      (log/error t "Error fetching credentials."))))

(defn cached-credentials-with-auto-refresh
  "Returns a CredentialsProvider which wraps `provider`, caching
  credentials returned by `fetch`, and auto-refreshing the cached
  credentials in a background thread when the credentials include a
  ::ttl.

  Call `stop` to cancel future auto-refreshes.

  The default ScheduledExecutorService uses a ThreadFactory that
  spawns daemon threads. You can override this by providing your own
  ScheduledExecutorService.

  Alpha. Subject to change."
  ([provider]
   (cached-credentials-with-auto-refresh provider @scheduled-executor-service))
  ([provider scheduler]
   (let [credentials-atom (atom nil)
         scheduled-refresh-atom (atom nil)]
     (reify
       CredentialsProvider
       (fetch [_]
         (or @credentials-atom
             (refresh! credentials-atom scheduled-refresh-atom provider scheduler)))
       Stoppable
       (-stop [_]
         (-stop provider)
         (when-let [r @scheduled-refresh-atom]
           (.cancel ^Future r true)))))))

(defn ^:deprecated auto-refreshing-credentials
  "Deprecated. Use cached-credentials-with-auto-refresh"
  ([provider] (cached-credentials-with-auto-refresh provider))
  ([provider scheduler] (cached-credentials-with-auto-refresh provider scheduler)))

(defn stop
  "Stop auto-refreshing the credentials.

  Alpha. Subject to change."
  [credentials]
  (-stop credentials)
  nil)

(defn ^:skip-wiki valid-credentials
  "For internal use. Don't call directly."
  ([credentials]
   (valid-credentials credentials nil))
  ([{:keys [aws/access-key-id aws/secret-access-key] :as credentials}
    credential-source]
   (if (and (not (str/blank? access-key-id))
            (not (str/blank? secret-access-key)))
     (do
       (when credential-source
         (log/debug (str "Fetched credentials from " credential-source ".")))
       credentials)
     (when credential-source
       (log/debug (str "Unable to fetch credentials from " credential-source "."))
       nil))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Providers

(defn chain-credentials-provider
  "Returns a credentials-provider which chains together multiple
  credentials providers.

  `fetch` calls each provider in order until one returns a non-nil
  result. This provider is then cached for future calls to `fetch`.

  `fetch` returns nil if none of the providers return credentials.

  Alpha. Subject to change."
  [providers]
  (let [cached-provider (atom nil)]
    (reify
      CredentialsProvider
      (fetch [_]
        (valid-credentials
          (if @cached-provider
            (fetch @cached-provider)
            (some (fn [provider]
                    (when-let [creds (fetch provider)]
                      (reset! cached-provider provider)
                      creds))
                  providers))))
      Stoppable
      (-stop [_] (run! -stop providers)))))

(defn environment-credentials-provider
  "Return the credentials from the environment variables.

  Look at the following variables:
  * AWS_ACCESS_KEY_ID      required
  * AWS_SECRET_ACCESS_KEY  required
  * AWS_SESSION_TOKEN      optional

  Returns nil if any of the required variables is blank.

  Logs error if one required variable is blank but the other
  is not.

  Alpha. Subject to change."
  []
  (cached-credentials-with-auto-refresh
    (reify CredentialsProvider
      (fetch [_]
        (valid-credentials
          {:aws/access-key-id (u/getenv "AWS_ACCESS_KEY_ID")
           :aws/secret-access-key (u/getenv "AWS_SECRET_ACCESS_KEY")
           :aws/session-token (u/getenv "AWS_SESSION_TOKEN")}
          "environment variables")))))

(defn system-property-credentials-provider
  "Return the credentials from the system properties.

  Look at the following properties:
  * aws.accessKeyId  required
  * aws.secretKey    required

  Returns nil if any of the required properties is blank.

  Logs error if one of the required properties is blank but
  the other is not.

  Alpha. Subject to change. "
  []
  (cached-credentials-with-auto-refresh
    (reify CredentialsProvider
      (fetch [_]
        (valid-credentials
          {:aws/access-key-id (u/getProperty "aws.accessKeyId")
           :aws/secret-access-key (u/getProperty "aws.secretKey")
           :aws/session-token (u/getProperty "aws.sessionToken")}
          "system properties")))))

(defn profile-credentials-provider
  "Return credentials in an AWS configuration profile.

  Arguments:

  profile-name  string  The name of the profile in the file. (default: default)
  f             File    The profile configuration file. (default: ~/.aws/credentials)

  https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html
    Parsed properties:

    aws_access_key        required
    aws_secret_access_key required
    aws_session_token     optional

  Alpha. Subject to change."
  ([]
   (profile-credentials-provider (or (u/getenv "AWS_PROFILE")
                                     (u/getProperty "aws.profile")
                                     "default")))
  ([profile-name]
   (profile-credentials-provider profile-name (or (some-> (u/getenv "AWS_SHARED_CREDENTIALS_FILE") io/file)  ;; aws-cli and java sdk v2
                                                  (some-> (u/getenv "AWS_CREDENTIAL_PROFILES_FILE") io/file) ;; java sdk v1
                                                  (io/file (u/getProperty "user.home") ".aws" "credentials"))))
  ([profile-name ^File f]
   (cached-credentials-with-auto-refresh
     (reify CredentialsProvider
       (fetch [_]
         (when (.exists f)
           (try
             (let [profile (get (config/parse f) profile-name)]
               (valid-credentials
                 {:aws/access-key-id (get profile "aws_access_key_id")
                  :aws/secret-access-key (get profile "aws_secret_access_key")
                  :aws/session-token (get profile "aws_session_token")}
                 "aws profiles file"))
             (catch Throwable t
               (log/error t "Error fetching credentials from aws profiles file")))))))))

(defn- ->instant
  "Takes various types representing a time value and returns an Instant
  object of the same instant in time. The supported conversions are:
  java.util.Date, CharSequence, Number, and Instant objects, which are
  returned outright."
  [t]
  (cond
    (instance? Date t) (.toInstant ^Date t)
    (instance? CharSequence t) (Instant/parse t)
    (number? t) (Instant/ofEpochMilli (.longValue ^Number t))
    :else t))

(defn calculate-ttl
  "Primarily for internal use, returns time to live (ttl, in seconds),
  based on `:Expiration` in credentials.  If `credentials` contains no
  `:Expiration`, defaults to 3600.

  `:Expiration` can be a string parsable by java.time.Instant/parse
  (returned by ec2/ecs instance credentials), a java.util.Date
  (returned from :AssumeRole on aws sts client), a numeric value
  representing milliseconds since the epoch of 1970-01-01T00:00:00Z,
  or an Instant object."
  [{:keys [Expiration]}]
  (if Expiration
    (-> (Instant/now)
        (Duration/between ^Instant (->instant Expiration))
        .getSeconds
        (- 300)
        (max 60))
    3600))

(defn container-credentials-provider
  "For internal use. Do not call directly.

  Return credentials from ECS iff one of
  AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or
  AWS_CONTAINER_CREDENTIALS_FULL_URI is set.

  Alpha. Subject to change."
  [http-client]
  (cached-credentials-with-auto-refresh
    (reify CredentialsProvider
      (fetch [_]
        (when-let [creds (ec2/container-credentials http-client)]
          (valid-credentials
            {:aws/access-key-id (:AccessKeyId creds)
             :aws/secret-access-key (:SecretAccessKey creds)
             :aws/session-token (:Token creds)
             ::ttl (calculate-ttl creds)}
            "ecs container"))))))

(defn instance-profile-credentials-provider
  "For internal use. Do not call directly.

  Return credentials from EC2 metadata service iff neither of
  AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or
  AWS_CONTAINER_CREDENTIALS_FULL_URI
  is set.

  Alpha. Subject to change."
  [http-client]
  (cached-credentials-with-auto-refresh
    (reify CredentialsProvider
      (fetch [_]
        (when-let [creds (ec2/instance-credentials http-client)]
          (valid-credentials
            {:aws/access-key-id (:AccessKeyId creds)
             :aws/secret-access-key (:SecretAccessKey creds)
             :aws/session-token (:Token creds)
             ::ttl (calculate-ttl creds)}
            "ec2 instance"))))))

(defn default-credentials-provider
  "Returns a chain-credentials-provider with (in order):

    environment-credentials-provider
    system-property-credentials-provider
    profile-credentials-provider
    container-credentials-provider
    instance-profile-credentials-provider

  Alpha. Subject to change."
  [http-client]
  (chain-credentials-provider
    [(environment-credentials-provider)
     (system-property-credentials-provider)
     (profile-credentials-provider)
     (container-credentials-provider http-client)
     (instance-profile-credentials-provider http-client)]))

(defn basic-credentials-provider
  "Given a map with :access-key-id and :secret-access-key,
  returns an implementation of CredentialsProvider which returns
  those credentials on fetch.

  Alpha. Subject to change."
  [{:keys [access-key-id secret-access-key]}]
  (assert access-key-id "Missing")
  (assert secret-access-key "Missing")
  (reify CredentialsProvider
    (fetch [_]
      {:aws/access-key-id access-key-id
       :aws/secret-access-key secret-access-key})))

(defn fetch-async
  "Returns a channel that will produce the result of calling fetch on
  the provider.

  Alpha. Subject to change."
  [provider]
  (u/fetch-async fetch provider "credentials"))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns com.grzm.awyeah.client.shared
  (:require
   [com.grzm.awyeah.credentials :as credentials]
   [com.grzm.awyeah.http :as http]
   [com.grzm.awyeah.region :as region]))

(set! *warn-on-reflection* true)

(declare http-client)

(def ^:private shared-http-client
  (delay (http/resolve-http-client nil)))

(def ^:private shared-credentials-provider
  (delay (credentials/default-credentials-provider (http-client))))

(def ^:private shared-region-provider
  (delay (region/default-region-provider (http-client))))

(defn http-client
  "Returns the globally shared instance of http-client (created on the
  first call).

  Alpha. Subject to change."
  []
  @shared-http-client)

(defn credentials-provider
  "Returns the globally shared instance of credentials-provider, which
  uses the globally shared instance of http-client.

  Alpha. Subject to change."
  []
  @shared-credentials-provider)

(defn region-provider
  "Returns the globally shared instance of region-provider, which
  uses the globally shared instance of http-client.

  Alpha. Subject to change."
  []
  @shared-region-provider)

(defn ^:private shared-http-client?
  "For internal use.

  Alpha. Subject to change."
  [candidate-http-client]
  (identical? candidate-http-client
              (and (realized? shared-http-client) @shared-http-client)))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.client.protocol
  "Impl, don't call directly.")

(defprotocol Client
  (-get-info [_] "Used by fns in com.grzm.awyeah.client.api. Implementors must supply
                  :service, and may also supply anything else needed by the other
                  protocol functions.

                  The com.grzm.awyeah.client.api/client uses the following:
                    :retriable?
                    :backoff
                    :http-client
                    :endpoint-provider
                    :region-provider
                    :credentials-provider
                    :validate-requests?")
  (-invoke [this op-map] "Packages and ships a request and returns a response")
  (-invoke-async [this op-map] "Packages and ships a request and returns a channel that will contain a response")
  (-stop [this] "Release resources managed by this client"))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.protocols
  "Impl, don't call directly. "
  (:require
   [clojure.string :as str]
   [com.grzm.awyeah.json :as json]
   [com.grzm.awyeah.util :as util])
  (:import
   (java.util Date)))

(set! *warn-on-reflection* true)

(defmulti parse-http-response
  "HTTP response -> AWS response"
  (fn [service _op-map _http-response]
    (get-in service [:metadata :protocol])))

(defmulti build-http-request
  "AWS request -> HTTP request."
  (fn [service _op-map]
    (get-in service [:metadata :protocol])))

(defn ^:private status-code->anomaly-category [^long code]
  (case code
    304 :cognitect.anomalies/conflict
    403 :cognitect.anomalies/forbidden
    404 :cognitect.anomalies/not-found
    429 :cognitect.anomalies/busy
    503 :cognitect.anomalies/busy
    504 :cognitect.anomalies/unavailable
    (if (<= 300 code 499)
      :cognitect.anomalies/incorrect
      :cognitect.anomalies/fault)))

(defn sanitize-error-code
  "Per https://smithy.io/2.0/aws/protocols/aws-restjson1-protocol.html#operation-error-serialization:
    If a : character is present, then take only the contents before the first : character in the value.
    If a # character is present, then take only the contents after the first # character in the value."
  [error-code]
  (some-> error-code
          (str/split #":")
          first
          (str/split #"#" 2)
          last))

(defn error-code
  "Attempt to extract an error code from well known locations in an
   error response body. Returns nil if none are found.

   See:
     https://smithy.io/2.0/aws/protocols/aws-restjson1-protocol.html#operation-error-serialization
     https://smithy.io/2.0/aws/protocols/aws-json-1_0-protocol.html#operation-error-serialization
     https://smithy.io/2.0/aws/protocols/aws-json-1_1-protocol.html#operation-error-serialization
     https://smithy.io/2.0/aws/protocols/aws-restxml-protocol.html#error-response-serialization
     https://smithy.io/2.0/aws/protocols/aws-query-protocol.html#operation-error-serialization
     https://smithy.io/2.0/aws/protocols/aws-ec2-query-protocol.html#operation-error-serialization"
  [http-response]
  (or (-> http-response :headers (get "x-amzn-errortype"))
      (-> http-response :body :__type)
      (-> http-response :body :code)
      (-> http-response :body :Error :Code)
      (-> http-response :body :ErrorResponse :Error :Code)
      (-> http-response :body :Response :Errors :Error :Code)))

(defn ^:private error-code->anomaly-category
  "Given an error message extracted from an error response body *that we
   understand*, returns the appropriate anomaly category, or nil if none
   are found."
  [error-code]
  (condp = error-code
    "ThrottlingException" :cognitect.anomalies/busy
    nil))

(defn ^:private anomaly-category
  "Given an http-response with the body already coerced to a Clojure map,
   attempt to return an anomaly-category for a specific error message or
   status. Returns nil if none are found."
  [status sanitized-error-code]
  (or (error-code->anomaly-category sanitized-error-code)
      (status-code->anomaly-category status)))

(defn ^:private anomaly-message
  "Given 301 with an x-amz-bucket-region header, returns a clear message with direction
   for the user to resubmit the request to the correct region. Else returns nil."
  [response-map]
  (when-let [region (and (= 301 (:status response-map))
                         (get (:headers response-map) "x-amz-bucket-region"))]
    (str "The bucket is in this region: " region ". Please use this region to retry the request.")))

(defn headers [service operation]
  (let [{:keys [protocol targetPrefix jsonVersion]} (:metadata service)]
    (cond-> {"x-amz-date" (util/format-date util/x-amz-date-format (Date.))}
      (contains? #{"json" "rest-json"} protocol)
      (assoc "x-amz-target" (str targetPrefix "." (:name operation))
             "content-type" (str "application/x-amz-json-" jsonVersion)
             ;; NOTE: apigateway returns application/hal+json unless
             ;; we specify the accept header
             "accept" "application/json")
      (contains? #{"query" "ec2"} protocol)
      (assoc "content-type" "application/x-www-form-urlencoded; charset=utf-8"))))

(defn ^:private parse-encoded-string
  "Given non-nil String, determine the encoding (currently either XML or JSON). Return a Map
   representation of the encoded data.

   Returns nil if encoded-str is nil."
  [encoded-str]
  (when (seq encoded-str)
    (if (= \< (first encoded-str))
      (-> encoded-str util/xml-read util/xml->map)
      (-> encoded-str (json/read-str)))))

(defn parse-http-error-response
  "Given an http error response (any status code 300 or above), return an aws-api-specific response
  Map."
  [{:keys [status] :as http-response}]
  (let [http-response* (update http-response :body #(some-> % util/bbuf->str parse-encoded-string))
        sanitized-error-code (-> http-response* error-code sanitize-error-code)
        category (anomaly-category (:status http-response) sanitized-error-code)
        message (anomaly-message http-response*)]
    (with-meta
      (cond-> (assoc (:body http-response*) :cognitect.aws.http/status status)
        category (assoc :cognitect.anomalies/category category)
        message  (assoc :cognitect.anomalies/message message)
        sanitized-error-code (assoc :cognitect.aws.error/code sanitized-error-code))
      http-response)))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.interceptors
  "Impl, don't call directly."
  (:require
   [com.grzm.awyeah.service :as service]
   [com.grzm.awyeah.util :as util]))

(set! *warn-on-reflection* true)

(defmulti modify-http-request (fn [service _op-map _http-request]
                                (service/service-name service)))

(defmethod modify-http-request :default [_service _op-map http-request] http-request)

(def md5-blacklist
  "Set of ops that should not get the Content-MD5 header.

  See https://github.com/aws/aws-sdk-java-v2/blob/master/services/s3/src/main/java/software/amazon/awssdk/services/s3/internal/handlers/AddContentMd5HeaderInterceptor.java "
  #{:PutObject :UploadPart})

(defmethod modify-http-request "s3" [service op-map http-request]
  (if (and (= "md5" (get-in service [:metadata :checksumFormat]))
           (not (md5-blacklist (:op op-map)))
           (:body http-request))
    (update http-request :headers assoc "Content-MD5" (-> http-request :body util/md5 util/base64-encode))
    http-request))

(defmethod modify-http-request "apigatewaymanagementapi" [_service op-map http-request]
  (if (= :PostToConnection (:op op-map))
    (update http-request :uri str (-> op-map :request :ConnectionId))
    http-request))

;; See https://github.com/aws/aws-sdk-java-v2/blob/985ec92c0dfac868b33791fe4623296c68e2feab/services/glacier/src/main/java/software/amazon/awssdk/services/glacier/internal/GlacierExecutionInterceptor.java#L40
(defmethod modify-http-request "glacier" [service _op-map http-request]
  (assoc-in http-request
            [:headers "x-amz-glacier-version"]
            (get-in service [:metadata :apiVersion])))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.client.validation
  "For internal use. Don't call directly."
  (:require
   [com.grzm.awyeah.client.protocol :as client.protocol]
   [com.grzm.awyeah.service :as service]))

(set! *warn-on-reflection* true)

(defn validate-requests?
  "For internal use. Don't call directly."
  [client]
  (some-> client client.protocol/-get-info :validate-requests? deref))

(def ^:private registry-ref (delay (requiring-resolve 'clojure.spec.alpha/registry)))
(defn registry
  "For internal use. Don't call directly."
  [& args] (apply @registry-ref args))

(def ^:private valid?-ref (delay (requiring-resolve 'clojure.spec.alpha/valid?)))
(defn valid?
  "For internal use. Don't call directly."
  [& args] (apply @valid?-ref args))

(def ^:private explain-data-ref (delay (requiring-resolve 'clojure.spec.alpha/explain-data)))
(defn explain-data
  "For internal use. Don't call directly."
  [& args] (apply @explain-data-ref args))

(defn request-spec
  "For internal use. Don't call directly."
  [service op]
  (when-let [spec (service/request-spec-key service op)]
    (when (contains? (-> (registry) keys set) spec)
      spec)))

(defn invalid-request-anomaly
  "For internal use. Don't call directly."
  [spec request]
  (assoc (explain-data spec request)
         :cognitect.anomalies/category :cognitect.anomalies/incorrect))

(defn unsupported-op-anomaly
  "For internal use. Don't call directly."
  [service op]
  {:cognitect.anomalies/category :cognitect.anomalies/unsupported
   :cognitect.anomalies/message "Operation not supported"
   :service (keyword (service/service-name service))
   :op op})
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns ^:skip-wiki com.grzm.awyeah.client.impl
  "Impl, don't call directly."
  (:require
   [clojure.core.async :as a]
   [com.grzm.awyeah.client.protocol :as client.protocol]
   [com.grzm.awyeah.client.shared :as shared]
   [com.grzm.awyeah.client.validation :as validation]
   [com.grzm.awyeah.credentials :as credentials]
   [com.grzm.awyeah.endpoint :as endpoint]
   [com.grzm.awyeah.http :as http]
   [com.grzm.awyeah.interceptors :as interceptors]
   [com.grzm.awyeah.protocols :as aws.protocols]
   [com.grzm.awyeah.region :as region]
   [com.grzm.awyeah.retry :as retry]
   [com.grzm.awyeah.signers :as signers]
   [com.grzm.awyeah.util :as util]))

(set! *warn-on-reflection* true)

;; TODO convey throwable back from impl
(defn ^:private handle-http-response
  [service op-map {:keys [status] :as http-response}]
  (try
    (if (:cognitect.anomalies/category http-response)
      http-response
      (if (< status 300)
        (aws.protocols/parse-http-response service op-map http-response)
        (aws.protocols/parse-http-error-response http-response)))
    (catch Throwable t
      {:cognitect.anomalies/category :cognitect.anomalies/fault
       ::throwable t})))

(defn ^:private with-endpoint [req {:keys [protocol hostname port path]}]
  (cond-> (-> req
              (assoc-in [:headers "host"] hostname)
              (assoc :server-name hostname))
    protocol (assoc :scheme protocol)
    port (assoc :server-port port)
    path (assoc :uri path)))

(defn ^:private put-throwable [result-ch t response-meta op-map]
  (a/put! result-ch (with-meta
                      {:cognitect.anomalies/category :cognitect.anomalies/fault
                       ::throwable t}
                      (swap! response-meta
                             assoc :op-map op-map))))

(defn ^:private send-request
  [client op-map http-request]
  (let [{:keys [service http-client region-provider credentials-provider endpoint-provider]}
        (client.protocol/-get-info client)
        response-meta (atom {})
        region-ch (region/fetch-async region-provider)
        creds-ch (credentials/fetch-async credentials-provider)
        response-ch (a/chan 1)
        result-ch (a/promise-chan)]
    (a/go
      (let [region (a/<! region-ch)
            creds (a/<! creds-ch)
            endpoint (endpoint/fetch endpoint-provider region)]
        (cond
          (:cognitect.anomalies/category region)
          (a/>! result-ch region)
          (:cognitect.anomalies/category creds)
          (a/>! result-ch creds)
          (:cognitect.anomalies/category endpoint)
          (a/>! result-ch endpoint)
          :else
          (try
            (let [http-request (signers/sign-http-request service endpoint
                                                          creds
                                                          (-> http-request
                                                              (with-endpoint endpoint)
                                                              ((partial interceptors/modify-http-request service op-map))))]
              (swap! response-meta assoc :http-request http-request)
              (http/submit http-client http-request response-ch))
            (catch Throwable t
              (put-throwable result-ch t response-meta op-map))))))
    (a/go
      (try
        (let [response (a/<! response-ch)]
          (a/>! result-ch (with-meta
                            (handle-http-response service op-map response)
                            (swap! response-meta assoc
                                   :http-response (update response :body util/bbuf->input-stream)))))
        (catch Throwable t
          (put-throwable result-ch t response-meta op-map))))
    result-ch))

(defrecord Client [info]
  client.protocol/Client
  (-get-info [_] info)

  (-invoke [client op-map]
    (a/<!! (client.protocol/-invoke-async client op-map)))

  (-invoke-async [client {:keys [op request] :as op-map}]
    (let [result-chan (or (:ch op-map) (a/promise-chan))
          {:keys [service retriable? backoff]} (client.protocol/-get-info client)
          spec (and (validation/validate-requests? client) (validation/request-spec service op))]
      (cond
        (not (contains? (:operations service) (:op op-map)))
        (a/put! result-chan (validation/unsupported-op-anomaly service op))

        (and spec (not (validation/valid? spec request)))
        (a/put! result-chan (validation/invalid-request-anomaly spec request))

        :else
        ;; In case :body is an InputStream, ensure that we only read
        ;; it once by reading it before we send it to with-retry.
        (let [req (-> (aws.protocols/build-http-request service op-map)
                      (update :body util/->bbuf))]
          (retry/with-retry
            #(send-request client op-map req)
            result-chan
            (or (:retriable? op-map) retriable?)
            (or (:backoff op-map) backoff))))

      result-chan))

  (-stop [aws-client]
    (let [{:keys [http-client]} (client.protocol/-get-info aws-client)]
      (when-not (#'shared/shared-http-client? http-client)
        (http/stop http-client)))))

;; ->Client is intended for internal use
(alter-meta! #'->Client assoc :skip-wiki true)

(defn client [client-meta info]
  (let [region (some-> info :region-provider region/fetch)]
    (-> (with-meta (->Client info) @client-meta)
        (assoc :api (-> info :service :metadata :cognitect.aws/service-name)
               :region region
               :endpoint (some-> info :endpoint-provider (endpoint/fetch region))
               :credentials (some-> info :credentials-provider credentials/fetch)
               :service (some-> info :service (select-keys [:metadata]))
               :http-client (:http-client info)))))
;; Copyright (c) Cognitect, Inc.
;; All rights reserved.

(ns com.grzm.awyeah.client.api
  "API functions for using a client to interact with AWS services."
  (:require
   [clojure.string :as str]
   [clojure.tools.logging :as log]
   [com.grzm.awyeah.client.impl :as client]
   [com.grzm.awyeah.client.protocol :as client.protocol]
   [com.grzm.awyeah.client.shared :as shared]
   [com.grzm.awyeah.credentials]
   [com.grzm.awyeah.dynaload :as dynaload]
   [com.grzm.awyeah.endpoint :as endpoint]
   [com.grzm.awyeah.http :as http]
   [com.grzm.awyeah.region :as region]
   [com.grzm.awyeah.retry :as retry]
   [com.grzm.awyeah.service :as service]
   [com.grzm.awyeah.signers]))

(set! *warn-on-reflection* true)

(declare ops)

(defn client
  "Given a config map, create a client for specified api. Supported keys:

  :api                  - required, name of the api you want to interact with e.g. s3, cloudformation, etc
  :http-client          - optional, to share http-clients across aws-clients
                          Default: default-http-client
  :region-provider      - optional, implementation of aws-clojure.region/RegionProvider
                          protocol, defaults to com.grzm.awyeah.region/default-region-provider.
                          Ignored if :region is also provided
  :region               - optional, the aws region serving the API endpoints you
                          want to interact with, defaults to region provided by
                          by the region-provider
  :credentials-provider - optional, implementation of
                          com.grzm.awyeah.credentials/CredentialsProvider protocol
                          Default: com.grzm.awyeah.credentials/default-credentials-provider
  :endpoint-override    - optional, map to override parts of the endpoint. Supported keys:
                            :protocol     - :http or :https
                            :hostname     - string
                            :port         - int
                            :path         - string
                          If the hostname includes an AWS region, be sure to use the same
                          region for the client (either via out of process configuration
                          or the :region key supplied to this fn).
                          Also supports a string representing just the hostname, though
                          support for a string is deprecated and may be removed in the
                          future.
  :retriable?           - optional, predicate fn of http-response (see com.grzm.awyeah.http/submit),
                          which should return a truthy value if the request is
                          retriable.
                          Default: com.grzm.awyeah.retry/default-retriable?
  :backoff              - optional, fn of number of retries so far. Should return
                          number of milliseconds to wait before the next retry
                          (if the request is retriable?), or nil if it should stop.
                          Default: com.grzm.awyeah.retry/default-backoff.

  By default, all clients use shared http-client, credentials-provider, and
  region-provider instances which use a small collection of daemon threads.

  Primarily for debugging, clients support keyword access for :api (String),
  :region, :endpoint, :credentials, :service (with :metadata), and :http-client.

  Alpha. Subject to change."
  [{:keys [api region region-provider retriable? backoff credentials-provider endpoint-override http-client]
    :or   {endpoint-override {}}}]
  (when (string? endpoint-override)
    (log/warn
      (format
        "DEPRECATION NOTICE: :endpoint-override string is deprecated.\nUse {:endpoint-override {:hostname \"%s\"}} instead."
        endpoint-override)))
  (let [service (service/service-description (name api))
        http-client (if http-client
                      (http/resolve-http-client http-client)
                      (shared/http-client))
        region-provider (cond region (reify region/RegionProvider (fetch [_] region))
                              region-provider region-provider
                              :else (shared/region-provider))
        credentials-provider (or credentials-provider (shared/credentials-provider))
        endpoint-provider (endpoint/default-endpoint-provider
                            (get-in service [:metadata :endpointPrefix])
                            endpoint-override)]
    (dynaload/load-ns (symbol (str "com.grzm.awyeah.protocols." (get-in service [:metadata :protocol]))))
    (client/client
      (atom {'clojure.core.protocols/datafy (fn [c]
                                              (let [info (client.protocol/-get-info c)
                                                    region (region/fetch (:region-provider info))
                                                    endpoint (endpoint/fetch (:endpoint-provider info) region)]
                                                (-> info
                                                    (select-keys [:service])
                                                    (assoc :api (-> info :service :metadata :cognitect.aws/service-name))
                                                    (assoc :region region :endpoint endpoint)
                                                    (update :endpoint select-keys [:hostname :protocols :signatureVersions])
                                                    (update :service select-keys [:metadata])
                                                    (assoc :ops (ops c)))))})
      {:service service
       :retriable? (or retriable? retry/default-retriable?)
       :backoff (or backoff retry/default-backoff)
       :http-client http-client
       :endpoint-provider endpoint-provider
       :region-provider region-provider
       :credentials-provider credentials-provider
       :validate-requests? (atom nil)})))

(defn default-http-client
  "Create an http-client to share across multiple aws-api clients."
  []
  (http/resolve-http-client nil))

(defn invoke
  "Packages and sends a request to AWS and returns the result.

  Supported keys in op-map:

  :op                   - required, keyword, the op to perform
  :request              - required only for ops that require them.
  :retriable?           - optional, defaults to :retriable? on the client.
                          See client.
  :backoff              - optional, defaults to :backoff on the client.
                          See client.

  Will validate :request after calling (validate-requests client true).

  Alpha. Subject to change."
  [client op-map]
  (client.protocol/-invoke client op-map))

(defn invoke-async
  "Packages and sends a request to AWS and returns a channel which
  will contain the result.

  Supported keys in op-map:

  :ch                   - optional, channel to deliver the result
  :op                   - required, keyword, the op to perform
  :request              - required only for ops that require them.
  :retriable?           - optional, defaults to :retriable? on the client.
                          See client.
  :backoff              - optional, defaults to :backoff on the client.
                          See client.

  Will validate :request after calling (validate-requests client true).

  Alpha. Subject to change."
  [client op-map]
  (client.protocol/-invoke-async client op-map))

(defn validate-requests
  "Given true, uses clojure.spec to validate all invoke calls on client.

  Alpha. Subject to change."
  ([client]
   (validate-requests client true))
  ([client validate-requests?]
   (reset! (-> client client.protocol/-get-info :validate-requests?) validate-requests?)
   (when validate-requests?
     (service/load-specs (-> client client.protocol/-get-info :service)))
   validate-requests?))

(defn request-spec-key
  "Returns the key for the request spec for op.

  Alpha. Subject to change."
  [client op]
  (service/request-spec-key (-> client client.protocol/-get-info :service) op))

(defn response-spec-key
  "Returns the key for the response spec for op.

  Alpha. Subject to change."
  [client op]
  (service/response-spec-key (-> client client.protocol/-get-info :service) op))

(def ^:private pprint-ref (delay (requiring-resolve 'clojure.pprint/pprint)))
(defn ^:skip-wiki pprint
  "For internal use. Don't call directly."
  [& args]
  (binding [*print-namespace-maps* false]
    (apply @pprint-ref args)))

(defn ops
  "Returns a map of operation name to operation data for this client.

  Alpha. Subject to change."
  [client]
  (->> client
       client.protocol/-get-info
       :service
       service/docs))

(defn doc-str
  "Given data produced by `ops`, returns a string
  representation.

  Alpha. Subject to change."
  [{:keys [documentation documentationUrl request required response refs] :as doc}]
  (when doc
    (str/join "\n"
              (cond-> ["-------------------------"
                       (:name doc)
                       ""
                       documentation]
                documentationUrl
                (into [""
                       documentationUrl])
                request
                (into [""
                       "-------------------------"
                       "Request"
                       ""
                       (with-out-str (pprint request))])
                required
                (into ["Required"
                       ""
                       (with-out-str (pprint required))])
                response
                (into ["-------------------------"
                       "Response"
                       ""
                       (with-out-str (pprint response))])
                refs
                (into ["-------------------------"
                       "Given"
                       ""
                       (with-out-str (pprint refs))])))))

(defn doc
  "Given a client and an operation (keyword), prints documentation
  for that operation to the current value of *out*. Returns nil.

  Alpha. Subject to change."
  [client operation]
  (println (or (some-> client ops operation doc-str)
               (str "No docs for " (name operation)))))

(defn stop
  "Has no effect when the underlying http-client is the shared
  instance.

  If you explicitly provided any other instance of http-client, stops
  it, releasing resources.

  Alpha. Subject to change."
  [aws-client]
  (client.protocol/-stop aws-client))
;; See also `malli.generator-ast` for viewing generators as data
(ns malli.generator
  (:require [clojure.spec.gen.alpha :as ga]
            [clojure.string :as str]
            [clojure.test.check :as check]
            [clojure.test.check.generators :as gen]
            [clojure.test.check.properties :as prop]
            [clojure.test.check.random :as random]
            [clojure.test.check.rose-tree :as rose]
            [malli.core :as m]
            [malli.registry :as mr]
            [malli.impl.util :refer [-last -merge]]
            #?(:clj [borkdude.dynaload :as dynaload])))

(declare generator generate -create)

(defprotocol Generator
  (-generator [this options] "returns generator for schema"))

;;
;; generators
;;


;; # Notes for implementors
;;
;; For the most part, -schema-generator is a pretty direct translation from schemas to generators.
;; However, the naive implementation of recursive ref's (creating a generator for the dereferenced ref
;; and cutting off the generation at a certain depth) tends to create exponentially large test cases.
;;
;; We use a more sophisticated algorithm to achieve linearly sized test cases with recursive refs.
;; The next section describes the strategy implementors should use to participate in this improved behavior.
;; The theory behind this strategy is described in the section below ("Approach for recursive generators").
;;
;; ## Implementation strategy
;;
;; Say you have a composite schema you want to generate values for. You should extend `-schema-generator` and
;; call `generator` recursively on the `m/children`. Now, for every child generator, you need to consider the case
;; that the child generator generates no values, and how this might change the final generator.
;;
;; Use `-unreachable-gen?` to test whether your child generator generates no values (we'll call this an "unreachable" schema/generator).
;; If your parent generator cannot generate values, use `-never-gen` to return an unreachable generator.
;; 
;; Here are a few examples---compare them with the logic in their respective -schema-generator methods:
;;   [:maybe M] would generate like :nil if M were unreachable.
;;   [:map [:a M]] would itself be unreachable if M were unreachable.
;;   [:map [:a {:optional true} M]] would generate like [:map] if M were unreachable.
;;   [:vector M] would generate like [:= []] if M were unreachable.
;;   [:vector {:min 1} M] would itself be unreachable if M were unreachable.

(def nil-gen (gen/return nil))

(defn -never-gen
  "Return a generator of no values that is compatible with -unreachable-gen?."
  [{::keys [original-generator-schema] :as _options}]
  (with-meta (gen/such-that (fn [_]
                              (throw (ex-info
                                      (str "Cannot generate values due to infinitely expanding schema: "
                                           (if original-generator-schema
                                             (m/form original-generator-schema)
                                             "<no schema form>"))
                                      (cond-> {}
                                        original-generator-schema (assoc :schema (m/form original-generator-schema))))))
                            gen/any)
             {::never-gen true
              ::original-generator-schema original-generator-schema}))

(defn -unreachable-gen?
  "Returns true iff generator g generators no values."
  [g] (-> (meta g) ::never-gen boolean))

(defn -not-unreachable [g] (when-not (-unreachable-gen? g) g))

(defn- -random [seed] (if seed (random/make-random seed) (random/make-random)))

(defn ^:deprecated -recur [_schema options]
  (println (str `-recur " is deprecated, please update your generators. See instructions in malli.generator."))
  [true options])

(defn ^:deprecated -maybe-recur [_schema options]
  (println (str `-maybe-recur " is deprecated, please update your generators. See instructions in malli.generator."))
  options)

(defn -min-max [schema options]
  (let [{:keys [min max] gen-min :gen/min gen-max :gen/max} (m/properties schema options)]
    (when (and min gen-min (< gen-min min))
      (m/-fail! ::invalid-property {:key :gen/min, :value gen-min, :min min}))
    (when (and max gen-max (> gen-max max))
      (m/-fail! ::invalid-property {:key :gen/max, :value gen-min, :max min}))
    {:min (or gen-min min)
     :max (or gen-max max)}))

(defn- -double-gen [options] (gen/double* (merge {:infinite? false, :NaN? false} options)))

(defn- gen-vector-min [gen min options]
  (cond-> (gen/sized #(gen/vector gen min (+ min %)))
    (::generator-ast options) (vary-meta assoc ::generator-ast
                                         {:op :vector-min
                                          :generator gen
                                          :min min})))

(defn- -string-gen [schema options]
  (let [{:keys [min max]} (-min-max schema options)]
    (cond
      (and min (= min max)) (gen/fmap str/join (gen/vector gen/char-alphanumeric min))
      (and min max) (gen/fmap str/join (gen/vector gen/char-alphanumeric min max))
      min (gen/fmap str/join (gen-vector-min gen/char-alphanumeric min options))
      max (gen/fmap str/join (gen/vector gen/char-alphanumeric 0 max))
      :else gen/string-alphanumeric)))

(defn- -coll-gen [schema f options]
  (let [{:keys [min max]} (-min-max schema options)
        child (-> schema m/children first)
        gen (generator child options)]
    (if (-unreachable-gen? gen)
      (if (<= (or min 0) 0 (or max 0))
        (gen/fmap f (gen/return []))
        (-never-gen options))
      (gen/fmap f (cond
                    (and min (= min max)) (gen/vector gen min)
                    (and min max) (gen/vector gen min max)
                    min (gen-vector-min gen min options)
                    max (gen/vector gen 0 max)
                    :else (gen/vector gen))))))

(defn- -coll-distinct-gen [schema f options]
  (let [{:keys [min max]} (-min-max schema options)
        child (-> schema m/children first)
        gen (generator child options)]
    (gen/fmap f (if (-unreachable-gen? gen)
                  (if (<= (or min 0) 0 (or max 0))
                    (gen/return [])
                    (-never-gen options))
                  (gen/vector-distinct gen {:min-elements min, :max-elements max, :max-tries 100})))))

(defn -and-gen [schema options]
  (if-some [gen (-not-unreachable (-> schema (m/children options) first (generator options)))]
    (gen/such-that (m/validator schema options) gen 100)
    (-never-gen options)))

(defn- gen-one-of [gs]
  (if (= 1 (count gs))
    (first gs)
    (gen/one-of gs)))

(defn -or-gen [schema options]
  (if-some [gs (not-empty
                (into [] (keep #(-not-unreachable (generator % options)))
                      (m/children schema options)))]
    (gen-one-of gs)
    (-never-gen options)))

(defn -multi-gen [schema options]
  (if-some [gs (not-empty
                (into [] (keep #(-not-unreachable (generator (last %) options)))
                      (m/entries schema options)))]
    (gen-one-of gs)
    (-never-gen options)))

(defn- -build-map [kvs]
  (persistent!
   (reduce
    (fn [acc [k v]]
      (cond (and (= k ::m/default) (map? v)) (reduce-kv assoc! acc v)
            (nil? k) acc
            :else (assoc! acc k v)))
    (transient {}) kvs)))

(defn- -value-gen [k s options]
  (let [g (generator s options)]
    (cond->> g (-not-unreachable g) (gen/fmap (fn [v] [k v])))))

(defn -map-gen [schema options]
  (loop [[[k s :as e] & entries] (m/entries schema)
         gens []]
    (if (nil? e)
      (gen/fmap -build-map (apply gen/tuple gens))
      (if (-> e -last m/properties :optional)
        ;; opt
        (recur
         entries
         (conj gens
               (if-let [g (-not-unreachable (-value-gen k s options))]
                 (gen-one-of [nil-gen g])
                 nil-gen)))
        ;;; req
        (let [g (-value-gen k s options)]
          (if (-unreachable-gen? g)
            (-never-gen options)
            (recur entries (conj gens g))))))))

(defn -map-of-gen [schema options]
  (let [{:keys [min max]} (-min-max schema options)
        [k-gen v-gen :as gs] (map #(generator % options) (m/children schema options))
        opts (cond
               (and min (= min max)) {:num-elements min}
               (and min max) {:min-elements min :max-elements max}
               min {:min-elements min}
               max {:max-elements max}
               :else {})]
    (if (some -unreachable-gen? gs)
      (if (= 0 (or min 0) (or max 0))
        (gen/return {})
        (-never-gen options))
      (gen/fmap #(into {} %) (gen/vector-distinct (gen/tuple k-gen v-gen) opts)))))

#?(:clj
   (defn -re-gen [schema options]
     ;; [com.gfredericks/test.chuck "0.2.10"+]
     (if-let [string-from-regex @(dynaload/dynaload 'com.gfredericks.test.chuck.generators/string-from-regex {:default nil})]
       (let [re (or (first (m/children schema options)) (m/form schema options))]
         (string-from-regex (re-pattern (str/replace (str re) #"^\^?(.*?)(\$?)$" "$1"))))
       (m/-fail! :test-chuck-not-available))))

;; # Approach for recursive generators
;;
;; `-ref-gen` is the only place where recursive generators can be created, and we use `gen/recursive-gen`
;; to handle the recursion. The challenge is that gen/recursive-gen requires _two_ arguments: the base
;; case (scalar gen) and the recursive case (container gen). We need to automatically split the schema argument into
;; these two cases.
;;
;; The main insight we use is that a base case for the schema cannot contain recursive references to itself.
;; A particularly useful base case is simply to "delete" all recursive references. To simulate this, we have the concept of
;; an "unreachable" generator, which represents a "deleted" recursive reference.
;;
;; For infinitely expanding schemas, this will return an unreachable generator--when the base case generator is used,
;; the error message in `-never-gen` will advise users that their schema is infinite.
;; 
;; 
;; Examples of base cases of some recursive schemas:
;;
;; Schema:    [:schema {:registry {::cons [:maybe [:vector [:tuple pos-int? [:ref ::cons]]]]}} ::cons]
;; Base case: [:schema {:registry {::cons [:nil                                            ]}} ::cons]
;;
;; Schema:    [:schema
;;             {:registry {::ping [:tuple [:= "ping"] [:maybe [:ref ::pong]]]
;;                         ::pong [:tuple [:= "pong"] [:maybe [:ref ::ping]]]}}
;;             ::ping]
;; Base case: [:schema
;;             {:registry {::ping [:tuple [:= "ping"] [:maybe [:ref ::pong]]]
;;                         ::pong [:tuple [:= "pong"] :nil                  ]}}
;;             ::ping]
;;
;; Once we have the base case, we first need determine if the schema is recursive---it's recursive
;; if more than one recursive reference was successfully "deleted" while creating the base case (see below for how we determine recursive references).
;; We can then construct the recursive case by providing `gen/recursive-gen` the base case
;; (this is why this particular base case is so useful) and then propagate the (smaller) generator
;; supplied by `gen/recursive-gen` to convert recursive references.

;; ## Identifying schema recursion
;; 
;; Refs are uniquely identified by their paired name and scope. If we see a ref with the
;; same name and scope as another ref we've dereferenced previously, we know that this is a recursion
;; point back to the previously seen ref. The rest of this section explains why.
;; 
;; Refs resolve via dynamic scope, which means its dereferenced value is the latest binding found
;; while expanding the schema until the point of finding the ref.
;; This makes the (runtime) scope at the ref's location part of a ref's identity---if the scope
;; is different, then it's (possibly) not the same ref because scope determines how schemas
;; transitively expand.
;;
;; To illustrate why a ref's name is an insufficient identifier, here is a schema that is equivalent to `[:= 42]`:
;; 
;;   [:schema {:registry {::a [:schema {:registry {::a [:= 42]}}
;;                             ;; (2)
;;                             [:ref ::a]]}}
;;    ;; (1)
;;    [:ref ::a]]
;;
;; If we identify refs just by name, we would have incorrectly detected (2) to be an (infinitely expanding) recursive
;; reference.
;;
;; In studying the previous example, we might think that since (1) and (2) deref to different schemas, it might sufficient to identify refs just by their derefs.
;; Unfortunately this just pushes the problem elsewhere.
;;
;; For example, here is another schema equivalent to `[:= 42]`:
;;
;;   [:schema {:registry {::a [:ref ::b] ;; (2)
;;                        ::b [:schema {:registry {::a [:ref ::b] ;; (4)
;;                                                 ::b [:= 42]}}
;;                             ;; (3)
;;                             [:ref ::a]]}}
;;    ;; (1)
;;    [:ref ::a]]
;;
;; If we identified ::a by its deref, it would look like (3) deref'ing to (4)
;; is a recursion point after witnessing (1) deref'ing to (2), since (2) == (4). Except this
;; is wrong since it's a different ::b at (2) and (4)! OTOH, if we identified (2) and (4) with their
;; dynamic scopes along with their form, they would be clearly different. Indeed, this
;; is another way to identify refs: pairing their derefs with their deref's scopes.
;; It is slightly more direct to use the ref's direct name and scope, which is why
;; we choose that identifier. The more general insight is that any schema is identified by its form+scope
;; (note: but only after trimming the scope of irrelevant bindings, see next pararaph).
;; That insight may be useful for detecting recursion at places other than refs.
;; 
;; Ref identifiers could be made smarter by trimming irrelevant entries in identifying scope.
;; Not all scope differences are relevant, so generators may expand more than strictly necessary
;; in the quest to find the "same" ref schema again. It could skip over refs that generate exactly the
;; same values, but their scopes are uninterestingly different (eg., unused bindings are different).
;;
;; For example, the following schema is recursive "in spirit" between (1) and (2), but since ::b
;; changes, the scope will differ, so the recursion will be detected between (2) and itself instead
;; (where the scope is constant):
;;
;;   [:schema {:registry {::a [:schema {:registry {::b :boolean}}
;;                             ;; (2)
;;                             [:or [:ref ::a] [:ref ::b]]]}}
;;    [:schema {:registry {::b :int}}
;;     ;; (1)
;;     [:or [:ref ::a] [:ref ::b]]]]

(defn- -identify-ref-schema [schema]
  {:scope (-> schema m/-options m/-registry mr/-schemas)
   :name (m/-ref schema)})

(defn -ref-gen [schema options]
  (let [ref-id (-identify-ref-schema schema)]
    (or (force (get-in options [::rec-gen ref-id]))
        (let [scalar-ref-gen (delay (-never-gen options))
              dschema (m/deref schema)]
          (cond->> (generator dschema (assoc-in options [::rec-gen ref-id] scalar-ref-gen))
            (realized? scalar-ref-gen) (gen/recursive-gen
                                        #(generator dschema (assoc-in options [::rec-gen ref-id] %))))))))

(defn -=>-gen [schema options]
  (let [output-generator (generator (:output (m/-function-info schema)) options)]
    (gen/return (m/-instrument {:schema schema} (fn [& _] (generate output-generator options))))))

(defn -function-gen [schema options]
  (gen/return (m/-instrument {:schema schema, :gen #(generate % options)} options)))

(defn -regex-generator [schema options]
  (if (m/-regex-op? schema)
    (generator schema options)
    (let [g (generator schema options)]
      (cond-> g
        (-not-unreachable g) gen/tuple))))

(defn- entry->schema [e] (if (vector? e) (get e 2) e))

(defn -cat-gen [schema options]
  (let [gs (->> (m/children schema options)
                (map #(-regex-generator (entry->schema %) options)))]
    (if (some -unreachable-gen? gs)
      (-never-gen options)
      (->> gs
           (apply gen/tuple)
           (gen/fmap #(apply concat %))))))

(defn -alt-gen [schema options]
  (let [gs (->> (m/children schema options)
                (keep #(-regex-generator (entry->schema %) options)))]
    (if (every? -unreachable-gen? gs)
      (-never-gen options)
      (gen-one-of (into [] (keep -not-unreachable) gs)))))

(defn -?-gen [schema options]
  (let [child (m/-get schema 0 nil)]
    (if-some [g (-not-unreachable (generator child options))]
      (if (m/-regex-op? child)
        (gen/one-of [g (gen/return ())])
        (gen/vector g 0 1))
      (gen/return ()))))

(defn -*-gen [schema options]
  (let [child (m/-get schema 0 nil)
        mode (::-*-gen-mode options :*)
        options (dissoc options ::-*-gen-mode)]
    (if-some [g (-not-unreachable (generator child options))]
      (cond->> (case mode
                 :* (gen/vector g)
                 :+ (gen-vector-min g 1 options))
        (m/-regex-op? child)
        (gen/fmap #(apply concat %)))
      (case mode
        :* (gen/return ())
        :+ (-never-gen options)))))

(defn -+-gen [schema options]
  (-*-gen schema (assoc options ::-*-gen-mode :+)))

(defn -repeat-gen [schema options]
  (let [child (m/-get schema 0 nil)]
    (if-some [g (-not-unreachable (-coll-gen schema identity options))]
      (cond->> g
        (m/-regex-op? child)
        (gen/fmap #(apply concat %)))
      (gen/return ()))))

(defn -qualified-ident-gen [schema mk-value-with-ns value-with-ns-gen-size pred gen]
  (if-let [namespace-unparsed (:namespace (m/properties schema))]
    (gen/fmap (fn [k] (mk-value-with-ns (name namespace-unparsed) (name k))) value-with-ns-gen-size)
    (gen/such-that pred gen)))

(defn -qualified-keyword-gen [schema]
  (-qualified-ident-gen schema keyword gen/keyword qualified-keyword? gen/keyword-ns))

(defn -qualified-symbol-gen [schema]
  (-qualified-ident-gen schema symbol gen/symbol qualified-symbol? gen/symbol-ns))

(defn- gen-elements [es]
  (if (= 1 (count es))
    (gen/return (first es))
    (gen/elements es)))

(defmulti -schema-generator (fn [schema options] (m/type schema options)) :default ::default)

(defmethod -schema-generator ::default [schema options] (ga/gen-for-pred (m/validator schema options)))

(defmethod -schema-generator :> [schema options] (-double-gen {:min (-> schema (m/children options) first inc)}))
(defmethod -schema-generator :>= [schema options] (-double-gen {:min (-> schema (m/children options) first)}))
(defmethod -schema-generator :< [schema options] (-double-gen {:max (-> schema (m/children options) first dec)}))
(defmethod -schema-generator :<= [schema options] (-double-gen {:max (-> schema (m/children options) first)}))
(defmethod -schema-generator := [schema options] (gen/return (first (m/children schema options))))
(defmethod -schema-generator :not= [schema options] (gen/such-that #(not= % (-> schema (m/children options) first)) gen/any-printable 100))
(defmethod -schema-generator 'pos? [_ _] (gen/one-of [(-double-gen {:min 0.00001}) (gen/fmap inc gen/nat)]))
(defmethod -schema-generator 'neg? [_ _] (gen/one-of [(-double-gen {:max -0.0001}) (gen/fmap (comp dec -) gen/nat)]))

(defmethod -schema-generator :not [schema options] (gen/such-that (m/validator schema options) (ga/gen-for-pred any?) 100))
(defmethod -schema-generator :and [schema options] (-and-gen schema options))
(defmethod -schema-generator :or [schema options] (-or-gen schema options))
(defmethod -schema-generator :orn [schema options] (-or-gen (m/into-schema :or (m/properties schema) (map last (m/children schema)) (m/options schema)) options))
(defmethod -schema-generator ::m/val [schema options] (generator (first (m/children schema)) options))
(defmethod -schema-generator :map [schema options] (-map-gen schema options))
(defmethod -schema-generator :map-of [schema options] (-map-of-gen schema options))
(defmethod -schema-generator :multi [schema options] (-multi-gen schema options))
(defmethod -schema-generator :vector [schema options] (-coll-gen schema identity options))
(defmethod -schema-generator :sequential [schema options] (-coll-gen schema identity options))
(defmethod -schema-generator :set [schema options] (-coll-distinct-gen schema set options))
(defmethod -schema-generator :enum [schema options] (gen-elements (m/children schema options)))

(defmethod -schema-generator :maybe [schema options]
  (let [g (-> schema (m/children options) first (generator options) -not-unreachable)]
    (gen-one-of (cond-> [nil-gen]
                  g (conj g)))))

(defmethod -schema-generator :tuple [schema options]
  (let [gs (map #(generator % options) (m/children schema options))]
    (if (not-any? -unreachable-gen? gs)
      (apply gen/tuple gs)
      (-never-gen options))))
#?(:clj (defmethod -schema-generator :re [schema options] (-re-gen schema options)))
(defmethod -schema-generator :any [_ _] (ga/gen-for-pred any?))
(defmethod -schema-generator :some [_ _] gen/any-printable)
(defmethod -schema-generator :nil [_ _] nil-gen)
(defmethod -schema-generator :string [schema options] (-string-gen schema options))
(defmethod -schema-generator :int [schema options] (gen/large-integer* (-min-max schema options)))
(defmethod -schema-generator :double [schema options]
  (gen/double* (merge (let [props (m/properties schema options)]
                        {:infinite? (get props :gen/infinite? false)
                         :NaN? (get props :gen/NaN? false)})
                      (-min-max schema options))))
(defmethod -schema-generator :boolean [_ _] gen/boolean)
(defmethod -schema-generator :keyword [_ _] gen/keyword)
(defmethod -schema-generator :symbol [_ _] gen/symbol)
(defmethod -schema-generator :qualified-keyword [schema _] (-qualified-keyword-gen schema))
(defmethod -schema-generator :qualified-symbol [schema _] (-qualified-symbol-gen schema))
(defmethod -schema-generator :uuid [_ _] gen/uuid)

(defmethod -schema-generator :=> [schema options] (-=>-gen schema options))
(defmethod -schema-generator :function [schema options] (-function-gen schema options))
(defmethod -schema-generator 'ifn? [_ _] gen/keyword)
(defmethod -schema-generator :ref [schema options] (-ref-gen schema options))
(defmethod -schema-generator :schema [schema options] (generator (m/deref schema) options))
(defmethod -schema-generator ::m/schema [schema options] (generator (m/deref schema) options))

(defmethod -schema-generator :merge [schema options] (generator (m/deref schema) options))
(defmethod -schema-generator :union [schema options] (generator (m/deref schema) options))
(defmethod -schema-generator :select-keys [schema options] (generator (m/deref schema) options))

(defmethod -schema-generator :cat [schema options] (-cat-gen schema options))
(defmethod -schema-generator :catn [schema options] (-cat-gen schema options))
(defmethod -schema-generator :alt [schema options] (-alt-gen schema options))
(defmethod -schema-generator :altn [schema options] (-alt-gen schema options))

(defmethod -schema-generator :? [schema options] (-?-gen schema options))
(defmethod -schema-generator :* [schema options] (-*-gen schema options))
(defmethod -schema-generator :+ [schema options] (-+-gen schema options))
(defmethod -schema-generator :repeat [schema options] (-repeat-gen schema options))

;;
;; Creating a generator by different means, centralized under [[-create]]
;;

(defn- -create-from-return [props]
  (when (contains? props :gen/return)
    (gen/return (:gen/return props))))

(defn- -create-from-elements [props]
  (some-> (:gen/elements props) gen-elements))

(extend-protocol Generator
  #?(:clj Object, :cljs default)
  (-generator [schema options]
    (-schema-generator schema (assoc options ::original-generator-schema schema))))

(defn- -create-from-gen
  [props schema options]
  (or (:gen/gen props)
      (when-not (:gen/elements props)
        (-generator schema options))))

(defn- -create-from-schema [props options]
  (some-> (:gen/schema props) (generator options)))

(defn- -create-from-fmap [props schema options]
  (when-some [fmap (:gen/fmap props)]
    (gen/fmap (m/eval fmap (or options (m/options schema)))
              (or (-create-from-return props)
                  (-create-from-elements props)
                  (-create-from-schema props options)
                  (-create-from-gen props schema options)
                  nil-gen))))

(defn- -create [schema options]
  (let [props (-merge (m/type-properties schema)
                      (m/properties schema))]
    (or (-create-from-fmap props schema options)
        (-create-from-return props)
        (-create-from-elements props)
        (-create-from-schema props options)
        (-create-from-gen props schema options)
        (m/-fail! ::no-generator {:options options
                                  :schema schema}))))

;;
;; public api
;;

(defn generator
  ([?schema]
   (generator ?schema nil))
  ([?schema options]
   (if (::rec-gen options)
     ;; disable cache while calculating recursive schemas. caches don't distinguish options.
     (-create (m/schema ?schema options) options)
     (m/-cached (m/schema ?schema options) :generator #(-create % options)))))

(defn generate
  ([?gen-or-schema]
   (generate ?gen-or-schema nil))
  ([?gen-or-schema {:keys [seed size] :or {size 30} :as options}]
   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]
     (rose/root (gen/call-gen gen (-random seed) size)))))

(defn sample
  ([?gen-or-schema]
   (sample ?gen-or-schema nil))
  ([?gen-or-schema {:keys [seed size] :or {size 10} :as options}]
   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]
     (->> (gen/make-size-range-seq size)
          (map #(rose/root (gen/call-gen gen %1 %2))
               (gen/lazy-random-states (-random seed)))
          (take size)))))

;;
;; functions
;;

(defn function-checker
  ([?schema] (function-checker ?schema nil))
  ([?schema {::keys [=>iterations] :or {=>iterations 100} :as options}]
   (let [schema (m/schema ?schema options)
         check (fn [schema]
                 (let [{:keys [input output]} (m/-function-info schema)
                       input-generator (generator input options)
                       output-validator (m/validator output options)
                       validate (fn [f args] (output-validator (apply f args)))]
                   (fn [f]
                     (let [{:keys [result shrunk]} (->> (prop/for-all* [input-generator] #(validate f %))
                                                        (check/quick-check =>iterations))
                           smallest (-> shrunk :smallest first)]
                       (when-not (true? result)
                         (let [explain-input (m/explain input smallest)
                               response (when-not explain-input
                                          (try (apply f smallest) (catch #?(:clj Exception, :cljs js/Error) e e)))
                               explain-output (when-not explain-input (m/explain output response))]
                           (cond-> shrunk
                             explain-input (assoc ::explain-input explain-input)
                             explain-output (assoc ::explain-output explain-output)
                             (ex-message result) (-> (update :result ex-message)
                                                     (dissoc :result-data)))))))))]
     (condp = (m/type schema)
       :=> (check schema)
       :function (let [checkers (map #(function-checker % options) (m/-children schema))]
                   (fn [x] (->> checkers (keep #(% x)) (seq))))
       (m/-fail! ::invalid-function-schema {:type (m/-type schema)})))))

(defn check
  ([?schema f] (check ?schema f nil))
  ([?schema f options]
   (let [schema (m/schema ?schema options)]
     (m/explain (m/-update-options schema #(assoc % ::m/function-checker function-checker)) f))))
(ns confr.core
  (:require [cheshire.core :as json]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [malli.core :as m]
            [malli.generator :as mg]
            [malli.util :as mu]
            [com.grzm.awyeah.client.api :as aws]
            [taoensso.timbre :as log]))

(log/set-level! :fatal)

(defn load-schema [{:keys [conf-dir]}]
  (-> (slurp (format "%s/schema.edn" conf-dir))
      (edn/read-string)
      (mu/closed-schema)))

(defn- deep-merge [& xs]
  (if (every? map? xs)
    (apply merge-with deep-merge xs)
    (last xs)))

(defn- file-in-dir [dir file]
  (io/file (format "%s/%s" dir file)))

(defn- env-dir [{:keys [conf-dir]}]
  (format "%s/environments" conf-dir))

(declare load-env)

(defn- resolve-includes [{:confr/keys [include] :as env}
                         {:keys [loaded-includes] :as opts
                          :or {loaded-includes #{}}}]
  (when-let [circ (some loaded-includes include)]
    (binding [*out* *err*]
      (println "Circular dependency detected while loading" circ))
    (System/exit 1))
  (let [opts (update opts :loaded-includes (fnil into #{}) include)]
    (->> (conj (mapv #(load-env % opts) include) (dissoc env :confr/include))
         (apply deep-merge))))

(defn load-env [env opts]
  (let [env (-> (file-in-dir (env-dir opts) (str env ".edn"))
                (slurp)
                (edn/read-string))]
    (resolve-includes env opts)))

(defmulti resolve-val (fn [x _]
                       (when (map? x)
                         (:confr/resolver x))))

(defmethod resolve-val :file/plain [{:keys [file]} opts]
  (slurp (file-in-dir (env-dir opts) file)))

(defmethod resolve-val :file/json [{:keys [json-file]} opts]
  (json/parse-string (slurp (file-in-dir (env-dir opts) json-file)) true))

(defmethod resolve-val :aws.secretsmanager/secret-string [{:keys [secret-id]} _]
  (let [sm (aws/client {:api :secretsmanager})]
    (-> (aws/invoke sm {:op :GetSecretValue
                        :request {:SecretId secret-id}})
        (:SecretString))))

(defmethod resolve-val :default [x opts]
  (cond
    (map? x)
    (update-vals x #(resolve-val % opts))

    (sequential? x)
    (map #(resolve-val % opts) x)

    :else
    x))

(def resolve-vals resolve-val)

(defn validate [schema env]
  (m/explain schema env))

(defn generate [schema]
  (mg/generate schema))

(defn to-env [k]
  (cond
    (string? k) k
    :else
    (let [ns (namespace k)
          k (cond->> (name k)
              ns (str "_"))]
      (-> (str ns k) str/upper-case (str/replace #"[^A-Z0-9]" "_")))))

(defn flat
  ([env]
   (flat env nil))
  ([env path]
   (cond
     (map? env)
     (mapcat #(flat % path) env)

     (map-entry? env)
     (flat (val env) (cond->> (to-env (key env))
                       path (str path "__")))

     (sequential? env)
     (flatten (map-indexed (fn [i v]
                             (let [path (cond->> (str i)
                                          path (str path "__"))]
                               (flat v path)))
                           env))

     (keyword? env)
     [path (name env)]

     :else [path (if (some? env) (pr-str env) "")])))

(defn env-vars [env]
  (partition 2 (flat env)))

(defn export-env-vars [env-vars]
  (->> env-vars
       (map (fn [[k v]]
              (format "export %s=%s" k v)))
       (str/join "\n")))
(ns confr.cli.commands
  (:require [cheshire.core :as json]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [confr.core :as confr]
            [malli.error :as me]
            [lambdaisland.deep-diff2 :as dd]
            [org.httpkit.server :as hks]))

;; Helper-functions

(defn- to-json [env]
  (json/generate-string env {:pretty true}))

(defn- pretty-printer [{:keys [format]}]
  (case format
    "edn" (fn [x]
            (dd/pretty-print x (dd/printer {:print-color (System/console)})))
    "json" (comp println to-json)
    "env-var" (comp println confr/export-env-vars (partial sort-by first) confr/env-vars)
    (comp println pr-str)))

(defmacro fail-with-message [msg-fn & body]
  `(try ~@body
        (catch Exception e#
          (binding [*out* *err*]
            (println (~msg-fn) (ex-message e#))
            (System/exit 1)))))

(defn- load-env [env {:keys [no-resolve] :as opts}]
  (fail-with-message
   #(format "Failed to load env %s" env)
   (cond-> (confr/load-env env opts)
     (not no-resolve) (confr/resolve-vals opts))))

(defn- load-schema [opts]
  (fail-with-message
   (constantly "Failed to load schema")
   (confr/load-schema opts)))

(defn- find-envs [{:keys [conf-dir]}]
  (->> (io/file (str conf-dir "/environments"))
       (file-seq)
       (map (memfn getName))
       (filter #(str/ends-with? % ".edn"))
       (map #(str/replace % #".edn$" ""))))

;; Commands

(defn validate [{{:keys [env] :as opts} :opts}]
  (let [printer (pretty-printer opts)
        schema (load-schema opts)
        envs (if env [env] (find-envs opts))
        results (->> envs
                     (map (juxt identity #(confr/validate schema (load-env % opts))))
                     (filter second))]
    (when (seq results)
      (doseq [[errorenv errors] results]
        (printer (cond->> (me/humanize errors)
                   (not env) (assoc {:environment errorenv}
                              :errors))))
      (System/exit 1))
    (println (format "Environment %s is valid" env))))

(defn generate [{:keys [opts]}]
  (let [printer (pretty-printer opts)]
    (-> (load-schema opts)
        (confr/generate)
        (printer))))

(defn diff [{{:keys [env] :as opts} :opts}]
  (let [printer (pretty-printer opts) #_(case format
                  ;; FIXME: This doesn't work well in all diffs
                  "json" (comp println json/generate-string)
                  dd/pretty-print)]
    (printer (dd/diff (load-env (first env) opts)
                      (load-env (second env) opts)))))

(defn export [{{:keys [env no-validate no-resolve] :as opts} :opts}]
  (let [env (load-env env opts)
        schema (load-schema opts)
        printer (pretty-printer opts)
        errors (and (not no-validate)
                    (not no-resolve)
                    (confr/validate schema env))]
    (when errors
      (binding [*out* *err*]
        (println "Invalid environment")
        (println (pr-str (me/humanize errors))))
      (System/exit 1))
    (printer env)))

(defn serve [{{:keys [env port ip once no-validate no-resolve format] :as opts} :opts}]
  (let [env (load-env env opts)
        schema (load-schema opts)
        formatter (case format
                    "edn" pr-str
                    "json" to-json)
        errors (and (not no-validate)
                    (not no-resolve)
                    (confr/validate schema env))
        shutdown (promise)
        server (atom nil)
        handler (fn [_]
                  (when once
                    (deliver shutdown @server))
                  {:status 200
                   :headers {"Content-type" (str "application/" format)}
                   :body (formatter (confr/resolve-vals env opts))})]
    (when errors
      (binding [*out* *err*]
        (println "Invalid environment")
        (println (pr-str (me/humanize errors))))
      (System/exit 1))
    (reset! server (hks/run-server handler {:port port
                                            :ip ip
                                            :legacy-return-value? true}))
    (@shutdown)))
(ns confr.cli
  (:require [babashka.cli :as cli]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [confr.cli.commands :as cmds]))

(defn error-fn [{:keys [spec type cause msg option] :as data}]
  (binding [*out* *err*]
    (if (= :org.babashka/cli type)
      (case cause
        :require
        (println
         (format "Missing required argument:\n%s"
                 (cli/format-opts {:spec (select-keys spec [option])})))
        (println msg))
      (throw (ex-info msg data))))
  (System/exit 1) )

(defn with-formats
  ([cmd]
   (with-formats cmd ["edn" "json" "env-var"]))
  ([cmd formats]
   (-> cmd
       (update :spec assoc :format {:default (name (first formats))
                                    :desc (format "Output format <%s>" (str/join ", " formats))})
       (update :validate assoc :format (set formats)))))

(defn with-defaults [cmd]
  (-> cmd
      (update :spec assoc :conf-dir {:default "."
                                     :desc "Configuration directory"})
      (update :validate assoc :conf-dir (fn [conf-dir] (.isDirectory (io/file conf-dir))))))

(defn with-no-resolve [cmd]
  (-> cmd
      (update :spec assoc :no-resolve {:default false
                                       :coerce boolean
                                       :desc "Do not resolve external values before processing (implies no-validate)"})))

(defn with-help [cmd]
  (let [cmd (update cmd :spec assoc :help {:default false
                                           :alias :h
                                           :coerce boolean
                                           :desc "Displays this help message"})
        help-fn (fn [_]
                  (println (format "Usage: confr %s %s [options]"
                                   (apply str (:cmds cmd))
                                   (str/join " " (map (comp #(format "<%s>" %) name) (:args->opts cmd)))))
                  (println)
                  (println (cli/format-table
                            {:rows (into [["Alias  " "Option  " "Default value  " "Description"]]
                                         (cli/opts->table (-> cmd
                                                              (update :spec #(apply dissoc % (:args->opts cmd)))
                                                              (dissoc :args->opts))))
                             :indent 4}))
                  (println)
                  (System/exit 1))]
    (-> cmd
        (update :fn (fn [f]
                      (fn [{{:keys [help]} :opts :as cmd'}]
                        (if help
                          (help-fn nil)
                          (f cmd')))))
        (assoc :error-fn help-fn))))

(defn usage [_]
  (println "Usage: confr <command> [args] [options]")
  (println)
  (println "Available commands:")
  (println "  validate  validates an environment")
  (println "  export    exports an environment")
  (println "  diff      shows differences between environments")
  (println "  generate  generates a valid random environment")
  (println "  serve     starts an http server serving the environment")
  (println)
  (println "To get help for a command run:")
  (println "  confr <command> --help")
  (println))

(def dispatch-table
  [(-> {:cmds ["validate"]
        :fn cmds/validate
        :args->opts [:env]}
       (with-defaults)
       (with-no-resolve)
       (with-formats ["edn" "json"])
       (with-help))
   (-> {:cmds ["generate"]
        :fn cmds/generate}
       (with-defaults)
       (with-formats)
       (with-help))
   (-> {:cmds ["diff"]
        :fn cmds/diff
        :args->opts [:env :env]
        :spec {:env {:coerce []
                     :require true}}
        :validate {:env #(= 2 (count %))}}
       (with-defaults)
       (with-formats ["edn" "json"])
       (with-no-resolve)
       (with-help))
   (-> {:cmds ["export"]
        :fn cmds/export
        :args->opts [:env]
        :spec {:no-validate {:default false
                             :coerce boolean
                             :desc "Skip validation"}}
        :validate {:env not-empty}
        :require [:env]}
       (with-defaults)
       (with-no-resolve)
       (with-formats)
       (with-help))
   (-> {:cmds ["serve"]
        :fn cmds/serve
        :args->opts [:env]
        :spec {:env {:require true}
               :ip {:default "127.0.0.1"
                    :desc "Which ip address to listen on"}
               :port {:coerce :int
                      :default 8177
                      :desc "Port number for http server"}
               :once {:coerce boolean
                      :default true
                      :desc "Shuts down after one request"}}}
       (with-defaults)
       (with-formats ["edn" "json"])
       (with-help))
   (-> {:cmds []
        :fn usage}
       (with-help))])

(defn main [& args]
  (cli/dispatch dispatch-table args))
(ns user (:require [confr.cli])) (apply confr.cli/main *command-line-args*)
